{
    "collab_server" : "",
    "contents" : "'#\n  Authors\nTorsten Pook, torsten.pook@uni-goettingen.de\n\nCopyright (C) 2017 -- 2018  Torsten Pook\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 3\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n'#\n\n#' Erstellung Datensatz im Diploiden\n#'\n#' Generation der Startliste ($info, erste Generation)\n#' @param dataset SNP dataset, use \"random\", \"allhetero\" \"all0\" when generating a dataset via nsnp,nindi\n#' @param nsnp number of markers to generate in a random dataset\n#' @param nindi number of inidividuals to generate in a random dataset\n#' @param freq frequency of allele 1 when randomly generating a dataset\n#' @param population Population list\n#' @param gender.s Specify with newly added individuals are male (1) or female (2)\n#' @param gender.quota Share of newly added female individuals (deterministic if gender.s=\"fixed\", alt: gender.s=\"random\")\n#' @param add.individual If TRUE add additional individuals to the dataset\n#' @param add.chromosom If TRUE add an additional chromosome to the dataset\n#' @param generation Generation of the newly added individuals (default: 1)\n#' @param migration.level Migration level of the newly added individuals\n#' @param chromosom.length Length of the newly added chromosome (default: 5)\n#' @param length.before Length before the first SNP of the dataset (default: 5)\n#' @param length.behind Length after the last SNP of the dataset (default: 5)\n#' @param snps.equidistant Use equidistant markers (computationally faster! ; default: TRUE)\n#' @param snp.position Location of each marker on the genetic map\n#' @param change.order If TRUE sort markers according to given marker positions\n#' @param bve.total Number of traits (If more than traits via real.bv.X use traits with no directly underlying QTL)\n#' @param polygenic_variance Genetic variance of traits with no underlying QTL\n#' @param bit.storing Set to TRUE if the RekomBre (not-miraculix! bit-storing is used)\n#' @param nbits Bits available in RekomBre-bit-storing\n#' @param randomSeed Set random seed of the process\n#' @param miraculix If TRUE use miraculix package for data storage and computation time relevant computations\n#' @param n_additive Number of additive QTL\n#' @param n_dominante Number of dominante QTL\n#' @param n_qualitative Number of qualitative epistatic QTL\n#' @param n_quantitative Number of quantitative epistatic QTL\n#' @param var_additive_l Variance of additive QTL\n#' @param var_dominante_l Variance of dominante QTL\n#' @param var_qualitative_l Variance of qualitative epistatic QTL\n#' @param var_quantitative_l Variance of quantitative epistatic QTL\n#' @param exclude_snps Marker were no QTL are simulated on\n#' @param replace_real_bv If TRUE delete the simulated traits added before\n#' @param shuffle_traits Combine different traits into a joined trait\n#' @param shuffle_cor Target Correlation between shuffeled traits\n#' @param real.bv.add Single Marker effects\n#' @param real.bv.mult Two Marker effects\n#' @param real.bv.dice Multi-marker effects\n#' @param bve.mult.factor Multiplicate trait value times this\n#' @param bve.poly.factor Potency trait value over this\n#' @param base.bve Average genetic value of a trait\n#' @param add_chromosomends Add chromosome ends as recombination points\n#' @param new.phenotype.correlation Correlation of the simulated enviromental variance\n#' @param new.breeding.correlation Correlation of the simulated genetic variance (child share! heritage is not influenced!\n#' @param add.architecture Add genetic architecture (marker positions)\n#' @param position.scaling Manual scaling of bp position to postion in M\n#' @param name.cohort Name of the newly added cohort\n#' @examples\n#' creating.diploid(dataset=\"random\", nindi=100, nsnp=1000)\n#' @export\n\ncreating.diploid <- function(dataset=NULL, nsnp=0, nindi=0, freq=0.5, population=NULL, gender.s=\"fixed\", add.individual=FALSE,\n                             add.chromosom=FALSE, generation=1, migration.level=0L,\n                             gender.quota = 0.5, chromosom.length=5,length.before=5, length.behind=5,\n                             real.bv.add=NULL, real.bv.mult=NULL, real.bv.dice=NULL, snps.equidistant=NULL,\n                             change.order=TRUE, bve.total=0, polygenic_variance=100,\n                             bve.mult.factor=NULL, bve.poly.factor=NULL,\n                             base.bve=NULL, add_chromosomends=TRUE,\n                             new.phenotype.correlation=NULL,\n                             new.breeding.correlation=NULL,\n                             add.architecture=NULL, snp.position=NULL,\n                             position.scaling=FALSE,\n                             bit.storing=FALSE,\n                             nbits=30, randomSeed=NULL,\n                             miraculix=FALSE,\n                             n_additive=0,\n                             n_dominante=0,\n                             n_qualitative=0,\n                             n_quantitative=0,\n                             var_additive_l=NULL,\n                             var_dominante_l=NULL,\n                             var_qualitative_l=NULL,\n                             var_quantitative_l=NULL,\n                             exclude_snps=NULL,\n                             replace_real_bv=FALSE,\n                             shuffle_traits=NULL,\n                             shuffle_cor=NULL,\n                             name.cohort=NULL){\n\n  if(length(randomSeed)>0){\n    set.seed(randomSeed)\n  }\n\n  if(nsnp>0 && length(freq)<nsnp){\n    freq <- rep(freq, length.out=nsnp)\n  }\n  if(length(freq)>1 && length(freq)>nsnp){\n    nsnp <- length(freq)\n  }\n\n\n  if(!is.list(var_additive_l) ){\n    var_additive_l <- list(var_additive_l)\n  }\n  if(!is.list(var_dominante_l)){\n    var_dominante_l <- list(var_dominante_l)\n  }\n  if(!is.list(var_qualitative_l)){\n    var_qualitative_l <- list(var_qualitative_l)\n  }\n  if(!is.list(var_quantitative_l)){\n    var_quantitative_l <- list(var_quantitative_l)\n  }\n\n  trait_sum <- n_additive + n_dominante + n_qualitative + n_quantitative\n  test <- list(NULL)\n  if(length(var_additive_l) < length(trait_sum)){\n    var_additive_l <- c(var_additive_l, rep(test,length.out=length(trait_sum)-length(var_additive_l)))\n  }\n  if(length(var_dominante_l) < length(trait_sum)){\n    var_dominante_l <- c(var_dominante_l, rep(test,length.out=length(trait_sum)-length(var_dominante_l)))\n  }\n  if(length(var_qualitative_l) < length(trait_sum)){\n    var_qualitative_l <- c(var_qualitative_l, rep(test,length.out=length(trait_sum)-length(var_qualitative_l)))\n  }\n  if(length(var_quantitative_l) < length(trait_sum)){\n    var_quantitative_l <- c(var_quantitative_l, rep(test,length.out=length(trait_sum)-length(var_quantitative_l)))\n  }\n\n  ntraits <- length(trait_sum)\n  n_additive <- c(n_additive, rep(0, length.out=ntraits-length(n_additive)))\n  n_dominante <- c(n_dominante, rep(0, length.out=ntraits-length(n_dominante)))\n  n_qualitative <- c(n_qualitative, rep(0, length.out=ntraits-length(n_qualitative)))\n  n_quantitative <- c(n_quantitative, rep(0, length.out=ntraits-length(n_quantitative)))\n\n  if(length(unlist(c(var_qualitative_l, var_quantitative_l, var_additive_l, var_dominante_l)))>0){\n    ntraits <- max(length(trait_sum), length(var_additive_l),length(var_dominante_l), length(var_qualitative_l), length(var_quantitative_l) )\n    n_additive <- c(n_additive, rep(0, length.out=ntraits-length(n_additive)))\n    n_dominante <- c(n_dominante, rep(0, length.out=ntraits-length(n_dominante)))\n    n_qualitative <- c(n_qualitative, rep(0, length.out=ntraits-length(n_qualitative)))\n    n_quantitative <- c(n_quantitative, rep(0, length.out=ntraits-length(n_quantitative)))\n    trait_sum <- n_additive + n_dominante + n_qualitative + n_quantitative\n    if(length(var_additive_l) < length(trait_sum)){\n      var_additive_l <- rep(var_additive_l, length.out=length(trait_sum))\n    }\n    if(length(var_dominante_l) < length(trait_sum)){\n      var_dominante_l <- rep(var_dominante_l, length.out=length(trait_sum))\n    }\n    if(length(var_qualitative_l) < length(trait_sum)){\n      var_qualitative_l <- rep(var_qualitative_l, length.out=length(trait_sum))\n    }\n    if(length(var_quantitative_l) < length(trait_sum)){\n      var_quantitative_l <- rep(var_quantitative_l, length.out=length(trait_sum))\n    }\n  }\n\n\n\n\n  if(length(population)>0){\n    if(length(real.bv.add)==0 && replace_real_bv==FALSE){\n      real.bv.add <- population$info$real.bv.add\n      real.bv.add[[population$info$bve.calc+1]] <- NULL\n    } else if(replace_real_bv==FALSE){\n      if(!is.list(real.bv.add)){\n        real.bv.add <- list(real.bv.add)\n      }\n      real.bv.add <- c(population$info$real.bv.add, real.bv.add)\n      real.bv.add[[population$info$bve.calc+1]] <- NULL\n    }\n    if(length(real.bv.mult)==0 && replace_real_bv==FALSE){\n      real.bv.mult <- population$info$real.bv.mult\n      real.bv.mult[[population$info$bve.calc+1]] <- NULL\n    } else if(replace_real_bv==FALSE){\n      if(!is.list(real.bv.mult)){\n        real.bv.mult <- list(real.bv.mult)\n      }\n      real.bv.mult <- c(population$info$real.bv.mult, real.bv.mult)\n      real.bv.mult[[population$info$bve.calc+1]] <- NULL\n    }\n    if(length(real.bv.dice)==0 && replace_real_bv==FALSE){\n      real.bv.dice <- population$info$real.bv.dice\n      real.bv.dice[[population$info$bve.calc+1]] <- NULL\n    } else if(replace_real_bv==FALSE){\n      if(!is.list(real.bv.dice)){\n        real.bv.dice <- list(real.bv.dice)\n      }\n      real.bv.dice <- c(population$info$real.bv.dice, real.bv.dice)\n      real.bv.dice[[population$info$bve.calc+1]] <- NULL\n    }\n\n  }\n  if(length(real.bv.add)>0 && !is.list(real.bv.add)){\n    real.bv.add <- list(real.bv.add)\n  }\n  if(length(real.bv.mult)>0 && !is.list(real.bv.mult)){\n    real.bv.mult <- list(real.bv.mult)\n  }\n  if(length(real.bv.dice)>0 && !is.list(real.bv.dice)){\n    real.bv.dice <- list(real.bv.dice)\n  }\n  so_far <- max(length(real.bv.dice), length(real.bv.add), length(real.bv.mult))\n  if(length(trait_sum)){\n    for(index_trait in 1:length(trait_sum)){\n      var_additive <- var_additive_l[[index_trait]]\n      var_dominante <- var_dominante_l[[index_trait]]\n      var_qualitative <- var_qualitative_l[[index_trait]]\n      var_quantitative <- var_quantitative_l[[index_trait]]\n      if(n_additive[index_trait]>0 && length(var_additive)<n_additive[index_trait]){\n        if(length(var_additive)==0){\n          var_additive <- 1\n        }\n        var_additive <- rep(1, length.out=n_additive[index_trait])\n      }\n      if(n_dominante[index_trait]>0 && length(var_dominante)<n_dominante[index_trait]){\n        if(length(var_dominante)==0){\n          var_dominante <- 1\n        }\n        var_dominante <- rep(1, length.out=n_dominante[index_trait])\n      }\n      if(n_qualitative[index_trait]>0 && length(var_qualitative)<n_qualitative[index_trait]){\n        if(length(var_qualitative)==0){\n          var_qualitative <- 1\n        }\n        var_qualitative <- rep(1, length.out=n_qualitative[index_trait])\n      }\n      if(n_quantitative[index_trait]>0 && length(var_quantitative)<n_quantitative[index_trait]){\n        if(length(var_quantitative)==0){\n          var_quantitative <- 1\n        }\n        var_quantitative <- rep(1, length.out=n_quantitative[index_trait])\n      }\n\n      if(length(var_additive)!= n_additive[index_trait]){\n        n_additive[index_trait] <- length(var_additive)\n      }\n      if(length(var_dominante)!= n_dominante[index_trait]){\n        n_dominante[index_trait] <- length(var_dominante)\n      }\n      if(length(var_qualitative)!= n_qualitative[index_trait]){\n        n_qualitative[index_trait] <- length(var_qualitative)\n      }\n      if(length(var_quantitative)!= n_quantitative[index_trait]){\n        n_quantitative[index_trait] <- length(var_quantitative)\n      }\n\n\n\n      snpdata <- population$info$snp\n\n      #This part is only needed in creating.diploid\n      if(nsnp>0){\n        snpdata <- c(snpdata, nsnp)\n      } else if(is.matrix(dataset) && nrow(dataset)){\n        snpdata <- c(snpdata, nrow(dataset))\n      }\n\n      # Generating additive\n      effect_marker <- (1:sum(snpdata))\n      if(length(exclude_snps)>0){\n        effect_marker <- effect_marker[-exclude_snps]\n      }\n\n      add_marker <- sample(effect_marker, n_additive[index_trait])\n      dom_marker <- sample(effect_marker, n_dominante[index_trait])\n      epi1_marker <- sample(effect_marker, n_quantitative[index_trait]*2)\n      epi2_marker <- sample(effect_marker, n_qualitative[index_trait]*2)\n\n\n\n      cum_snp <- cumsum(snpdata)\n      real.bv.add.new <- NULL\n      real.bv.mult.new <- NULL\n      if(n_additive[index_trait]>0){\n        add_snp <- add_chromo <- numeric(n_additive[index_trait])\n        for(index in 1:n_additive[index_trait]){\n          add_chromo[index] <- sum(add_marker[index] > cum_snp) + 1\n          add_snp[index] <- add_marker[index] - c(0,cum_snp)[add_chromo[index]]\n        }\n        add_effect <- stats::rnorm(n_additive[index_trait], 1, var_additive)\n        real.bv.add.new <- cbind(add_snp, add_chromo, add_effect,0,-add_effect)\n      }\n      if(n_dominante[index_trait]>0){\n        dom_snp <- dom_chromo <- numeric(n_dominante[index_trait])\n        for(index in 1:n_dominante[index_trait]){\n          dom_chromo[index] <- sum(dom_marker[index] > cum_snp) + 1\n          dom_snp[index] <- dom_marker[index] - c(0,cum_snp)[dom_chromo[index]]\n        }\n        dom_effect <- stats::rnorm(n_dominante[index_trait], 1, var_dominante)\n        real.bv.add.new <- rbind(real.bv.add.new, cbind(dom_snp, dom_chromo, 0 ,dom_effect,dom_effect))\n\n      }\n\n      if(n_quantitative[index_trait]){\n        epi1_snp <- epi1_chromo <- numeric(n_quantitative[index_trait]*2)\n        for(index in 1:(n_quantitative[index_trait]*2)){\n          epi1_chromo[index] <- sum(epi1_marker[index] > cum_snp) + 1\n          epi1_snp[index] <- epi1_marker[index] - c(0,cum_snp)[epi1_chromo[index]]\n        }\n\n        effect_matrix <- matrix(0,nrow=n_quantitative[index_trait], ncol=9)\n        for(index in 1:n_quantitative[index_trait]){\n          d1 <- sort(abs(stats::rnorm(3, 1, var_quantitative[index])))\n          d2 <- sort(abs(stats::rnorm(3, 1, var_quantitative[index])))\n          effect_matrix[index,] <- c(d1*d2[1], d1*d2[2], d1*d2[3])\n        }\n        real.bv.mult.new <- cbind(epi1_snp[1:n_quantitative[index_trait]], epi1_chromo[1:n_quantitative[index_trait]],\n                                                  epi1_snp[-(1:n_quantitative[index_trait])], epi1_chromo[-(1:n_quantitative[index_trait])],\n                                                  effect_matrix)\n      }\n\n      if(n_qualitative[index_trait]>0){\n        epi2_snp <- epi2_chromo <- numeric(n_qualitative[index_trait]*2)\n        for(index in 1:(n_qualitative[index_trait]*2)){\n          epi2_chromo[index] <- sum(epi2_marker[index] > cum_snp) + 1\n          epi2_snp[index] <- epi2_marker[index] - c(0,cum_snp)[epi2_chromo[index]]\n        }\n\n        effect_matrix <- matrix(0,nrow=n_qualitative[index_trait], ncol=9)\n        for(index in 1:n_qualitative[index_trait]){\n\n          d1 <- -abs(stats::rnorm(9, 1, var_qualitative[index]))\n          d1[c(3,7)] <- -d1[c(3,7)]\n          effect_matrix[index,] <- d1\n        }\n        real.bv.mult.new <- rbind(real.bv.mult.new, cbind(epi2_snp[1:n_qualitative[index_trait]], epi2_chromo[1:n_qualitative[index_trait]],\n                                                  epi2_snp[-(1:n_qualitative[index_trait])], epi2_chromo[-(1:n_qualitative[index_trait])],\n                                                  effect_matrix))\n      }\n\n      real.bv.add[[index_trait+so_far]] <- real.bv.add.new\n      real.bv.mult[[index_trait+so_far]] <- real.bv.mult.new\n\n    }\n  }\n\n\n\n\n\n  perserve_bve <- length(population)==0\n\n  if(length(population)>0 && length(population$info$bitstoring)>0){\n    nbits <- population$info$bitstoring\n    leftover <- population$info$leftover\n    bit.storing <- TRUE\n  }\n  if(length(population)>0 && length(population$info$miraculix)>0 && population$info$miraculix){\n    miraculix <- TRUE\n  }\n  if (requireNamespace(\"miraculix\", quietly = TRUE)) {\n    codeOriginsU <- miraculix::codeOrigins\n    decodeOriginsU <- miraculix::decodeOrigins\n  } else{\n    codeOriginsU <- codeOriginsR\n    decodeOriginsU <- decodeOriginsR\n  }\n\n\n  nbv <- max(if(is.list(real.bv.add)){length(real.bv.add)} else{as.numeric(length(real.bv.add)>0)},\n             if(is.list(real.bv.mult)){length(real.bv.mult)} else{as.numeric(length(real.bv.mult)>0)},\n             if(is.list(real.bv.dice)){length(real.bv.dice)} else{as.numeric(length(real.bv.dice)>0)})\n  if(nbv >= bve.total){\n    bve.total <- nbv\n    bve.calc <- nbv\n    bv.random <- rep(FALSE, bve.total)\n    bv.random.variance <- c(rep(0, nbv))\n  }\n  if(bve.total > nbv){\n    if(length(polygenic_variance)< (bve.total - nbv)){\n      polygenic_variance <- rep(polygenic_variance, bve.total - nbv)\n    }\n    bv.random <- c(rep(FALSE, nbv), rep(TRUE, bve.total - nbv))\n\n    bv.random.variance <- c(rep(0, nbv), polygenic_variance)\n    bve.calc <- nbv +1 ## WARUM STEHT HIER +1 SINN ist calc nicht gerade anzahl der ZW mit berechenbaren wert? # ALLES SO RICHTIG in breeding.diploid!\n  }\n\n  if(length(dataset)==0){\n    dataset <- matrix((c(rep(0,nindi*2*nsnp))),ncol=nindi*2, nrow=nsnp)\n  }\n  if(length(dataset)==1 && dataset==\"all0\"){\n    dataset <- matrix((c(rep(0,nindi*2*nsnp))),ncol=nindi*2, nrow=nsnp)\n  }\n  if(length(dataset)==1 && dataset==\"random\"){\n    dataset <- matrix((c(stats::rbinom(nindi*2*nsnp,1,freq))),ncol=nindi*2, nrow=nsnp)\n  }\n  if(length(dataset)==1 && dataset==\"allhetero\"){\n    dataset <- matrix((c(rep(0,nindi*2*nsnp))),ncol=nindi*2, nrow=nsnp)\n    dataset[,1:nindi*2] <- 1\n  }\n\n\n  if(change.order && length(snp.position)>0){\n    order <- sort(snp.position,index.return=TRUE)$ix\n    snp.position <- snp.position[order]\n    dataset <- dataset[order,]\n  }\n\n\n  if(gender.s[1]==\"random\"){\n\n    gender.s <- stats::rbinom((ncol(dataset))/2, 1,gender.quota) +1\n    if(add.chromosom==TRUE){\n      gender.s <- population$info$gender\n    }\n  }\n  if(gender.s[1]==\"fixed\"){\n    gender.s <- rep(1, ncol(dataset)/2*(1-gender.quota))\n    gender.s <- c(gender.s, rep(2, ncol(dataset)/2-length(gender.s)))\n  }\n\n\n\n  if(is.numeric(dataset[1,1])){\n    hom0 <- integer(nrow(dataset))\n    hom1 <- rep(1L,nrow(dataset))\n  } else{\n    hom0 <- hom1 <- numeric(nrow(dataset))\n  }\n\n\n\n\n  if(is.numeric(dataset[1,1])){\n    data.matrix <- dataset\n    if(storage.mode(data.matrix)!= \"integer\"){\n      storage.mode(data.matrix) <- \"integer\"\n    }\n\n  } else{\n    data.matrix <- matrix(0L,nrow=nrow(dataset),ncol=(ncol(dataset)))\n    for(index in 1:nrow(dataset)){\n      gen <- as.character(as.matrix(dataset[index,]))\n      hom0[index] <- as.character(dataset[index,1])\n      ungleich <- which(hom0[index]!= gen)\n      if(length(ungleich)>0){\n        hom1[index] <- as.character(as.matrix(dataset[index,(ungleich[1])]))\n        data.matrix[index,] <- (gen==hom1[index])\n      } else{\n        hom1[index] <- hom0[index]\n      }\n      if(index%%1000==0) print(index)\n    }\n\n\n\n  }\n\n  if(length(snp.position)>0 && snp.position[1]<=0){\n    snp.position[1] <- snp.position[2]/2\n    print(paste(\"Illegal position for SNP 1 - changed to\",snp.position[1]))\n  }\n  if(length(snp.position)>1 && snp.position[length(snp.position)]>=chromosom.length){\n    snp.position[length(snp.position)] <- mean(c(snp.position[length(snp.position)-1], chromosom.length))\n    print(paste(\"Illegal position for last SNP - changed to\",snp.position[length(snp.position)]))\n  }\n\n\n  position <- snp.position\n  if(length(snp.position)>0 && length(snps.equidistant)==0){\n    snps.equidistant <- FALSE\n  } else if(length(snps.equidistant)==0){\n    snps.equidistant <- TRUE\n  }\n  if(snps.equidistant){\n    position <- 0.5:(nrow(data.matrix))*10\n  }\n\n  if(snps.equidistant || position.scaling || max(position) > chromosom.length ){\n    min.p <- min(position)\n    max.p <- max(position)\n    #  position.scal <- (position - (min.p - length.before)) / (max.p-min.p + length.before+ length.behind) * chromosom.length\n    position <- (position) / (max.p-min.p + length.before+ length.behind) * chromosom.length\n\n  }\n\n\n  if(length(population)==0){\n    population <- list()\n\n    ## KEINE EDITS ZWISCHEN [[1]] und [[18]] snps.equidistant ++ Miraculix aenderungen sonst erforderlich!\n    population$info <- list()\n    population$info$schlather_slot1 <- \"miraculix_not_activated\"\n    population$info$chromosom <- 1L\n    population$info$snp <- nrow(dataset)\n    population$info$position <- list()\n    population$info$position[[1]] <- position\n    population$info$snp.base <- rbind(hom0,hom1, deparse.level = 0)\n    population$info$snp.position <- position\n    population$info$length <- chromosom.length\n    population$info$length.total <- c(0,population$info$length)\n    population$info$func <- FALSE\n    population$info$size <- matrix(0L,nrow=1, ncol=2)\n    population$info$bve <- FALSE\n    population$info$bve.calculated <- FALSE\n    population$info$breeding.totals <- list()\n    population$info$bve.data <- list()\n    population$info$bve.nr <- 1 # default um fallunterscheidung zu vermeiden\n    population$info$bv.random <- bv.random\n    population$info$bv.random.variance <- bv.random.variance\n    population$info$snps.equidistant <- snps.equidistant\n    population$info$origin_gen <- 1L\n    population$info$cumsnp <- nrow(dataset)\n    if(length(bve.mult.factor)==0){\n      population$info$bve.mult.factor <- rep(1L, bve.total)\n    } else{\n      population$info$bve.mult.factor <- bve.mult.factor\n    }\n    if(length(bve.poly.factor)==0){\n      population$info$bve.poly.factor <- rep(1L, bve.total)\n    } else{\n      population$info$bve.poly.factor <- bve.poly.factor\n    }\n    if(length(base.bve)==0){\n      population$info$base.bve <- rep(100L, bve.total)\n    } else{\n      population$info$base.bve <- base.bve\n    }\n\n\n  } else if(add.chromosom==TRUE){\n    population$info$chromosom <- population$info$chromosom + 1L\n    population$info$snp <- c(population$info$snp, nrow(dataset))\n    population$info$position[[length(population$info$position)+1]] <- position\n    population$info$snp.position <- c(population$info$snp.position, position + max(population$info$length.total))\n    population$info$length <- c(population$info$length, chromosom.length)\n    population$info$length.total <- cumsum(c(0,population$info$length))\n    population$info$snp.base <- cbind(population$info$snp.base , rbind(hom0,hom1, deparse.level = 0), deparse.level = 0)\n    population$info$cumsnp <- c(population$info$cumsnp, sum(population$info$snp))\n  }\n  if(generation!=1){\n    take <- which(population$info$origin_gen==generation)\n    if(length(take)==1){\n      origin_code <- population$info$origin_gen[take]\n    } else{\n      if(length(population$info$origin_gen)<64){\n        population$info$origin_gen <- c(population$info$origin_gen, as.integer(generation))\n        origin_code <- length(population$info$origin_gen)\n      } else{\n        print(\"To many origin generation!\")\n        print(\"Delete second lowest origin_gen\")\n        switch <- sort(population$info$origin_gen, index.return=TRUE)[[2]]\n        population$info$origin_gen[switch] <- as.integer(generation)\n        origin_code <- switch\n      }\n    }\n  } else{\n    origin_code <- generation\n  }\n\n\n\n\n  if(bve.total>0 ||length(real.bv.add)>0  || length(real.bv.mult) >0 || length(real.bv.dice)>0){\n    population$info$bve <- TRUE\n    if(is.list(real.bv.add)){\n      population$info$real.bv.add <- real.bv.add\n    } else{\n      population$info$real.bv.add <- list(real.bv.add)\n    }\n    if(is.list(real.bv.mult)){\n      population$info$real.bv.mult <- real.bv.mult\n    } else{\n      population$info$real.bv.mult <- list(real.bv.mult)\n    }\n    if(is.list(real.bv.dice)){\n      population$info$real.bv.dice <- real.bv.dice\n    } else{\n      if(length(real.bv.dice)>0){\n        print(\"Keine vorschriftmaessige Eingabe fuer real.bv.dice!\")\n      }\n      population$info$real.bv.dice <- list(real.bv.dice)\n    }\n\n    population$info$bve.nr <- bve.total\n    population$info$bve.calc <- bve.calc\n\n    population$info$real.bv.length <- c(length(population$info$real.bv.add),\n                                         length(population$info$real.bv.mult),\n                                         length(population$info$real.bv.dice))\n\n    population$info$real.bv.add[[nbv+1]] <- \"placeholder\" # Use nbv instead of bve.calc\n    population$info$real.bv.mult[[nbv+1]] <- \"placeholder\"\n    population$info$real.bv.dice[[nbv+1]] <- \"placeholder\"\n\n\n\n  } else if(perserve_bve){\n    population$info$bve <- FALSE\n    population$info$bve.nr <- 0\n    population$info$bve.calc <- 0\n    population$info$real.bv.length <- c(0,0,0)\n  }\n  if(length(population)==1){\n    population$breeding <- list()\n    population$breeding[[1]] <- list()\n  }\n  if(length(population$breeding)==0 || length(population$breeding[[1]])==0){\n    population$breeding[[1]][[1]] <- list()\n  }\n  if(length(population$breeding[[1]])==1 ){\n    population$breeding[[1]][[2]] <- list()\n  }\n\n  if(generation!=1){\n    if(length(population$breeding)==(generation-1) || length(population$breeding[[generation]])==0){\n      population$breeding[[generation]] <- list()\n      population$breeding[[generation]][[1]] <- list()\n      population$info$size <- rbind(population$info$size,0L, deparse.level = 0)\n    }\n    if(length(population$breeding[[generation]])==1){\n      population$breeding[[generation]][[2]] <- list()\n    }\n  }\n  if(bve.total>0){\n    population$info$pheno.correlation <- diag(1L, bve.total)\n  }\n  if(length(new.phenotype.correlation)>0){\n    population$info$pheno.correlation <- t(chol(new.phenotype.correlation))\n  }\n  if(bve.total>0){\n    population$info$bv.correlation <- diag(1L, bve.total)\n  }\n  if(length(new.breeding.correlation)>0){\n    population$info$bv.correlation <- new.breeding.correlation\n  }\n  counter <- c(length(population$breeding[[generation]][[1]]),length(population$breeding[[generation]][[2]]))+1L # maennlich/weibliche Tiere bisher\n  counter.start <- counter\n  if(add.chromosom==FALSE){\n    for(index in 1:length(gender.s)){\n      gender <- gender.s[index]\n\n      population$breeding[[generation]][[gender]][[counter[gender]]] <- list()\n      population$breeding[[generation]][[gender]][[counter[gender]]][[1]] <- c(0, sum(population$info$length))\n      population$breeding[[generation]][[gender]][[counter[gender]]][[2]] <- c(0,sum(population$info$length))\n      if(add_chromosomends==TRUE){\n        population$breeding[[generation]][[gender]][[counter[gender]]][[1]] <- population$info$length.total\n        population$breeding[[generation]][[gender]][[counter[gender]]][[2]] <- population$info$length.total\n      }\n      population$breeding[[generation]][[gender]][[counter[gender]]][[3]] <- NULL\n      population$breeding[[generation]][[gender]][[counter[gender]]][[4]] <- NULL\n      population$breeding[[generation]][[gender]][[counter[gender]]][[5]] <- codeOriginsU(matrix(c(origin_code, gender, counter[gender], 1),nrow=(length(population$breeding[[generation]][[gender]][[counter[gender]]][[1]])-1), ncol=4, byrow=TRUE))\n      population$breeding[[generation]][[gender]][[counter[gender]]][[6]] <- codeOriginsU(matrix(c(origin_code, gender, counter[gender], 2),nrow=(length(population$breeding[[generation]][[gender]][[counter[gender]]][[2]])-1), ncol=4, byrow=TRUE))\n      population$breeding[[generation]][[gender]][[counter[gender]]][[7]] <- c(generation, gender, counter[gender])\n      population$breeding[[generation]][[gender]][[counter[gender]]][[8]] <- c(generation, gender, counter[gender])\n\n      if(miraculix){\n        population$breeding[[generation]][[gender]][[counter[gender]]][[9]] <- miraculix::codeHaplo(t(data.matrix[,(index*2-c(1,0))]))\n        population$breeding[[generation]][[gender]][[counter[gender]]][[10]] <- \"Placeholder_Pointer_Martin\"\n      } else if(bit.storing){\n        population$breeding[[generation]][[gender]][[counter[gender]]][[9]] <- bit.storing(data.matrix[,(index*2-1)], nbits)\n        population$breeding[[generation]][[gender]][[counter[gender]]][[10]] <- bit.storing(data.matrix[,(index*2)], nbits)\n      } else{\n        population$breeding[[generation]][[gender]][[counter[gender]]][[9]] <- as.integer(data.matrix[,(index*2-1)])\n        population$breeding[[generation]][[gender]][[counter[gender]]][[10]] <- as.integer(data.matrix[,(index*2)])\n      }\n\n      population$breeding[[generation]][[gender]][[counter[gender]]][[11]] <- NULL\n      population$breeding[[generation]][[gender]][[counter[gender]]][[12]] <- NULL\n#      population$breeding[[generation]][[gender]][[counter[gender]]][[13]] <- \"test\"\n      population$breeding[[generation]][[gender]][[counter[gender]]][[15]] <- 0\n      population$breeding[[generation]][[gender]][[counter[gender]]][[16]] <- 0\n      population$info$size[generation,gender] <- population$info$size[generation,gender] +1L\n      counter[gender] <- counter[gender] + 1L\n    }\n\n    if(length(population$breeding[[generation]])==2){\n      population$breeding[[generation]][[3]] <- matrix(0, nrow= population$info$bve.nr, ncol=counter[1]-1) # Selektionsfunktion\n      population$breeding[[generation]][[4]] <- matrix(0, nrow= population$info$bve.nr, ncol=counter[2]-1)\n      population$breeding[[generation]][[5]] <- rep(migration.level,counter[1]-1) # Migrationslevel\n      population$breeding[[generation]][[6]] <- rep(migration.level,counter[2]-1)\n      population$breeding[[generation]][[7]] <- matrix(0, nrow= population$info$bve.nr, ncol=counter[1]-1) # realer ZW\n      population$breeding[[generation]][[8]] <- matrix(0, nrow= population$info$bve.nr, ncol=counter[2]-1)\n      population$breeding[[generation]][[9]] <- matrix(0, nrow= population$info$bve.nr, ncol=counter[1]-1) # geschaetzer ZW\n      population$breeding[[generation]][[10]] <- matrix(0, nrow= population$info$bve.nr, ncol=counter[2]-1)\n\n      # calculate Real-ZW\n    } else{\n      population$breeding[[generation]][[3]] <- cbind(population$breeding[[generation]][[3]], matrix(0, nrow= population$info$bve.nr, ncol=counter[1]-counter.start[1])) # Selektionsfunktion\n      population$breeding[[generation]][[4]] <- cbind(population$breeding[[generation]][[4]], matrix(0, nrow= population$info$bve.nr, ncol=counter[2]-counter.start[2]))\n      population$breeding[[generation]][[5]] <- c(population$breeding[[generation]][[5]], rep(migration.level ,counter[1]-counter.start[1])) # Migrationslevel\n      population$breeding[[generation]][[6]] <- c(population$breeding[[generation]][[6]], rep(migration.level ,counter[2]-counter.start[2]))\n      population$breeding[[generation]][[7]] <- cbind(population$breeding[[generation]][[7]] , matrix(0, nrow= population$info$bve.nr, ncol=counter[1]-counter.start[1])) # realer ZW\n      population$breeding[[generation]][[8]] <- cbind(population$breeding[[generation]][[8]] , matrix(0, nrow= population$info$bve.nr, ncol=counter[2]-counter.start[2]))\n      population$breeding[[generation]][[9]] <- cbind(population$breeding[[generation]][[9]] , matrix(0, nrow= population$info$bve.nr, ncol=counter[1]-counter.start[1])) # geschaetzer ZW\n      population$breeding[[generation]][[10]] <-cbind(population$breeding[[generation]][[10]] , matrix(0, nrow= population$info$bve.nr, ncol=counter[2]-counter.start[2]))\n    }\n    if(add.individual==FALSE){\n      population$info$gender <- gender.s\n    } else{\n      population$info$gender <- c(population$info$gender, gender.s)\n    }\n\n  } else{\n    counter <- c(1,1)\n    for(index in 1:length(gender.s)){\n      gender <- gender.s[index]\n      population$breeding[[generation]][[gender]][[counter[gender]]][[1]][2] <- sum(population$info$length)\n      population$breeding[[generation]][[gender]][[counter[gender]]][[2]][2] <- sum(population$info$length)\n      if(add_chromosomends==TRUE){\n        population$breeding[[generation]][[gender]][[counter[gender]]][[1]] <- population$info$length.total\n        population$breeding[[generation]][[gender]][[counter[gender]]][[2]] <- population$info$length.total\n        population$breeding[[generation]][[gender]][[counter[gender]]][[5]] <- codeOriginsU(matrix(c(origin_code, gender, counter[gender], 1),nrow=(length(population$breeding[[generation]][[gender]][[counter[gender]]][[1]])-1), ncol=4, byrow=TRUE))\n        population$breeding[[generation]][[gender]][[counter[gender]]][[6]] <- codeOriginsU(matrix(c(origin_code, gender, counter[gender], 2),nrow=(length(population$breeding[[generation]][[gender]][[counter[gender]]][[2]])-1), ncol=4, byrow=TRUE))\n\n      }\n      population$breeding[[generation]][[gender]][[counter[gender]]][[7]] <- c(generation, gender, counter[gender])\n      population$breeding[[generation]][[gender]][[counter[gender]]][[8]] <- c(generation, gender, counter[gender])\n      if(miraculix){\n        population$breeding[[generation]][[gender]][[counter[gender]]][[9]] <- miraculix::codeHaplo(cbind(miraculix::decodeHaplo(population$breeding[[generation]][[gender]][[counter[gender]]][[9]]),t(data.matrix[,(index*2-c(1,0))])))\n        population$breeding[[generation]][[gender]][[counter[gender]]][[10]] <- \"Placeholder_Pointer_Martin\"\n      } else if(bit.storing){\n        if(leftover==0){\n          population$breeding[[generation]][[gender]][[counter[gender]]][[9]] <- c(population$breeding[[generation]][[gender]][[counter[gender]]][[9]], bit.storing(data.matrix[,(index*2-1)]),nbits)\n          population$breeding[[generation]][[gender]][[counter[gender]]][[10]] <- c(population$breeding[[generation]][[gender]][[counter[gender]]][[10]], bit.storing(data.matrix[,(index*2)]), nbits)\n        } else{\n          population$breeding[[generation]][[gender]][[counter[gender]]][[9]] <- c(population$breeding[[generation]][[gender]][[counter[gender]]][[9]][-length(population$breeding[[generation]][[gender]][[counter[gender]]][[9]])],\n                                                                                   bit.storing(c(bit.snps(population$breeding[[generation]][[gender]][[counter[gender]]][[9]][length(population$breeding[[generation]][[gender]][[counter[gender]]][[9]])], nbits)[(nbits-leftover+1):nbits],data.matrix[,(index*2-1)]),nbits))\n          population$breeding[[generation]][[gender]][[counter[gender]]][[10]] <- c(population$breeding[[generation]][[gender]][[counter[gender]]][[10]][-length(population$breeding[[generation]][[gender]][[counter[gender]]][[10]])],\n                                                                                    bit.storing(c(bit.snps(population$breeding[[generation]][[gender]][[counter[gender]]][[10]][length(population$breeding[[generation]][[gender]][[counter[gender]]][[10]])], nbits)[(nbits-leftover+1):nbits],data.matrix[,(index*2)]),nbits))\n\n        }\n      } else{\n        population$breeding[[generation]][[gender]][[counter[gender]]][[9]] <- c(population$breeding[[generation]][[gender]][[counter[gender]]][[9]], as.integer(data.matrix[,(index*2-1)]))\n        population$breeding[[generation]][[gender]][[counter[gender]]][[10]] <- c(population$breeding[[generation]][[gender]][[counter[gender]]][[10]], as.integer(data.matrix[,(index*2)]))\n\n      }\n\n      counter[gender] <- counter[gender] + 1\n    }\n\n  }\n\n  if(length(shuffle_traits)>0){\n    if(length(shuffle_traits)==1){\n      shuffle_traits <- which(population$info$bv.random==FALSE)\n    }\n    LT <- chol(shuffle_cor)\n    if(nrow(LT)!=length(shuffle_traits)){\n      stop(\"Dimension of shuffle correlation matrix doesnt work with traits to shuffle\")\n    } else{\n      store.add <- population$info$real.bv.add\n      store.mult <- population$info$real.bv.mult\n      store.dice <- population$info$real.bv.dice\n\n\n      col <- 1\n      for(index in shuffle_traits){\n        new.add <- new.mult <- new.dice1 <- new.dice2 <- NULL\n        row <- 1\n        for(index2 in shuffle_traits){\n          if(length(store.add[[index2]])>0){\n            new.add <- rbind(new.add, store.add[[index2]] %*% diag(c(1,1,rep(LT[row,col],3))))\n          }\n          if(length(store.mult[[index2]])>0){\n            new.mult <- rbind(new.mult, store.mult[[index2]] %*% diag(c(1,1,1,1,rep(LT[row,col],9))))\n          }\n          if(length(store.dice[[index2]])>0){\n            before <- length(new.dice2)\n            new.dice1 <- c(new.dice1,store.dice[[index2]][[1]])\n            new.dice2 <- c(new.dice2,store.dice[[index2]][[2]])\n            for(index3 in (before+1):length(new.dice2)){\n              new.dice2[[index3]] <- new.dice2[[index3]] * LT[row,col]\n            }\n          }\n          row <- row +1\n        }\n        # DONT REMOVE NULL - MORE WORK NEEDED HERE!\n        if(length(new.add)==0){\n\n        } else{\n          population$info$real.bv.add[[index]] <- new.add\n        }\n        if(length(new.mult)==0){\n\n        } else{\n          population$info$real.bv.mult[[index]] <- new.mult\n        }\n        if(length(new.add)==0){\n\n        } else{\n          population$info$real.bv.dice[[index]] <- list(new.dice1,new.dice2)\n        }\n        col <- col +1\n      }\n\n    }\n  }\n\n\n  if(length(add.architecture)>0){\n    population$info$gen_architecture[[length(population$info$gen_architecture)+1]] <- list()\n    population$info$gen_architecture[[length(population$info$gen_architecture)]]$length.total <- cumsum(c(0,add.architecture[[1]]))\n    population$info$gen_architecture[[length(population$info$gen_architecture)]]$snp.position <- add.architecture[[2]]\n\n  }\n  if(bit.storing){\n   population$info$bitstoring <- nbits\n   population$info$leftover <-  sum(population$info$snp)%%nbits\n  }\n  if(miraculix){\n    population$info$miraculix <- TRUE\n  } else{\n    population$info$miraculix <- FALSE\n  }\n\n  if(length(name.cohort)>0){\n    population$info$cohorts <- rbind(population$info$cohorts, c(current.gen+1, breeding.size[1:2], new.migration.level, current.size-breeding.size))\n    if(nrow(population$info$cohorts)==1){\n      colnames(population$info$cohorts) <- c(\"generation\", \"male individuals\", \"female individuals\", \"migration level\", \"position first male\", \"position first female\")\n    }\n  }\n  return(population)\n}\n",
    "created" : 1535966158384.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "575112554",
    "id" : "83840162",
    "lastKnownWriteTime" : 1535966206,
    "last_content_update" : 1535966206330,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/MoBPS/R/creating.diploid.R",
    "project_path" : "R/creating.diploid.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}