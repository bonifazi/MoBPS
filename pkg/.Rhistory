}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
zcalc <- zcalc + after - before
}
}
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
if(!(length(rest_take)==length(prev_rest_take) && prod(rest_take==prev_rest_take)==1) && !fast.uhat){
A1 <- MASS::ginv(A[rest_take, rest_take])
}
if(miraculix){
if(fast.uhat){
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code2, Rest_term)
} else{
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code2, (A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
} else if(miraculix.mult){
if(fast.uhat){
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,rest_take]), Rest_term)
} else{
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,rest_take]), (A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
} else{
if(fast.uhat){
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% Rest_term)
} else{
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% (A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
z_uhat <- z_uhat + after - before
}
### LOESCHEN WENN FEHLER GEFUNDEN
if(store.bve.parameter){
population$info$p_i[[length(population$info$p_i)+1]] <- p_i
if(miraculix){
population$info$Z.code[[length(population$info$Z.code)+1]] <- as.matrix(Z.code) ## this as.matrix is using miraculix!
} else if(miraculix.mult){
population$info$Zt[[length(population$info$Zt)+1]] <- Zt
} else{
population$info$Ztm[[length(population$info$Ztm)+1]] <- Ztm
}
print("test")
population$info$rest[[length(population$info$rest)+1]] <- Rest_term
}
##########
first <- first + maxZ
last <- min(maxZ*(index3+1), total_n)
}
u_hat <- cbind(u_hat, u_hat_new)
} else{
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
rest_take <- which(duplicated(c(take,take2))[-(1:length(take))])
if(!(length(rest_take)==length(prev_rest_take) && prod(rest_take==prev_rest_take)==1)){
if(miraculix && length(take2)!=nrow(loop_elements)){
Z.code2 <- miraculix::computeSNPS(population, loop_elements[take2,4], loop_elements[take2,5], loop_elements[take2,2], what="geno",
output_compressed = TRUE)
} else{
Z.code2 <- Z.code
}
if(!fast.uhat){
A1 <- MASS::ginv(A[rest_take, rest_take])
}
prev_rest_take <- rest_take
} else if(length(prev_rest_take)==0){
Z.code2 <- Z.code
}
if(miraculix){
if(fast.uhat){
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code2, Rest_term[rest_take]))
} else{
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i)) * miraculix::genoVector(Z.code2, A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
} else if(miraculix.mult){
if(fast.uhat){
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,rest_take]), Rest_term[rest_take]))
} else{
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,rest_take]), A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
} else{
if(fast.uhat){
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% Rest_term[rest_take]))
} else{
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% (A1 %*% (y_hat[rest_take,bven] - beta_hat[bven]))))
}
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
z_uhat <- z_uhat + after - before
}
}
if(rrblup.required){
if(sequenceZ){
stop("Not implemented!")
} else{
if(miraculix){
y_hat[take3,bven] <- u_hat[,bven] %*% (as.matrix(Z.code)[,take3]-2*p_i) + beta_hat[bven]
} else {
y_hat[take3,bven] <- u_hat[,bven] %*% Ztm + beta_hat[bven]
}
}
}
}
} else{
y_hat[,bven] <- y[,bven]
}
u_hat <- NULL
if(BGLR.bve){
Zt <- t(scale(t(Zt), center=TRUE, scale=FALSE))
fixed <- which(is.na(Z[,1]))
if(length(fixed)>0){
Zt <- Zt[-fixed,]
}
ETA <- list(list(K=A, model='RKHS'))
if(min(y[!is.na(y[,bven]),bven])==max(y[!is.na(y[,bven]),bven])){
y_hat[,bven] <- rep(max(y[!is.na(y[,bven]),bven]), length(y[,bven]))
} else{
if(BGLR.save.random){
BGLR.save <- paste0(BGLR.save, sample(1:10000,1))
}
if(requireNamespace("BGLR", quietly = TRUE)){
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
} else{
stop("Use of BGLR without being installed!")
}
y_hat[,bven] <- fm$yHat
}
} else if(emmreml.bve){
check <- sum(is.na(y[,bven]))
if(check == length(y[,bven])){
cat(paste0("No phenotyped individuals for trait ", population$info$trait.name[bven], "\n"))
cat(paste0("Skip this BVE."))
next
}
if(check>0){
cat(paste0("Breeding value estimation with ", check, " NA phenotypes! EMMREML does not support this!\n"))
cat(paste0("No estimation is performed to NA individuals. \n"))
take <- which(!is.na(y[,bven]))
} else{
take <- 1:length(y[,bven])
}
n <- length(y[take,bven])
p <- nrow(Zt)
stopifnot(n == ncol(Zt[,take]))
if(requireNamespace("EMMREML", quietly = TRUE)){
fm <- EMMREML::emmreml(
y[take,bven],
matrix(1,nrow=n),
diag(n),
A[take,take])
} else{
stop("Usage of EMMREML without being installed!")
}
y_hat[take,bven] <- as.numeric(fm$uhat) + as.numeric(fm$betahat)
if(estimate.u){
u_hat <- cbind(u_hat, alpha_to_beta(drop(fm$uhat),A[take,take],t(Zt[,take])))
}
} else if(sommer.bve){
check <- sum(is.na(y[,bven]))
if(check == length(y[,bven])){
cat(paste0("No phenotyped individuals for trait ", population$info$trait.name[bven], "\n"))
cat(paste0("Skip this BVE.\n"))
next
}
traitnames <- (paste0("name", 1:ncol(y)))
traitnames[bven] <- "name"
traitnames <- as.factor(traitnames)
colnames(y) <- traitnames
id <- as.factor(paste0("P", 1:nrow(y)))
y_som <- data.frame(y, id)
rownames(y_som) <- id
colnames(A) <- rownames(A) <- id
test <- sommer::mmer(name ~1, random=~sommer::vs(id, Gu=A), rcov = ~units, data=y_som)
y_hat[,bven] <- test$U[[1]][[1]]
} else if(sommer.multi.bve){
check <- sum(is.na(y))
if(check == length(y)){
cat(paste0("No phenotyped individuals for multi-trait mixed model\n"))
cat(paste0("Skip this BVE.\n"))
next
}
if(bven==population$info$bv.nr){
traitnames <- paste0("name", 1:ncol(y))
colnames(y) <- as.factor(traitnames)
id <- as.factor(paste0("P", 1:nrow(y)))
y_som <- data.frame(y, id)
rownames(y_som) <- id
colnames(A) <- rownames(A) <- id
text <- "cbind("
for(index in 1:length(traitnames)){
if(index==length(traitnames)){
text <- paste0(text, traitnames[index], ")")
} else{
text <- paste0(text, traitnames[index], ",")
}
}
text <- paste0("sommer::mmer(",text,"~1, random=~sommer::vs(id, Gu=A, Gtc=sommer::unsm(bven)), rcov = ~sommer::vs(units, Gtc=diag(bven)), data=y_som)")
test <- eval(parse(text=text))
for(bven1 in 1:bven){
y_hat[,bven1] <- test$U[[1]][[bven1]]
}
if(estimate.u){
cat("U estimation not available in sommer")
}
}
} else if(sigma.e[bven]>0){
check <- sum(is.na(y[,bven]))
u_hat_possible <- TRUE
multi <- y[,bven] - X %*% beta_hat[bven]
rrblup.required <- FALSE
if(check == length(y[,bven])){
cat(paste0("No phenotyped individuals for trait ", population$info$trait.name[bven], "\n"))
cat(paste0("Skip this BVE.\n"))
next
}
if(check>0){
if(sum(genotyped==1 & is.na(y[,bven]))==sum(genotyped==1)){
cat("No genotyped and phenotyped individuals. Application of rrBLUP not possible!\n")
cat("Assume non phenotyped individuals to have average phenotype.\n")
if(bve.0isNA && sum(is.na(multi))>0){
multi[is.na(multi)] <- 0
}
take <- 1:length(y[,bven])
} else if(sum(genotyped==1 & is.na(y[,bven]))>0){
cat("Some genotyped individuals without phenotype.\n")
take <- which(!is.na(y[,bven])) # individuals for GBLUP
rrblup.required <- TRUE
take2 <- which(!is.na(y[,bven]) & genotyped==1) # individuals for rrBLUP
take3 <- which(is.na(y[,bven]) & genotyped==1 & bve.insert) # individuals to estimate via rrBLUP
if(length(take3)>0){
cat("Use rrBLUP to estimate breeding value for those individuals!\n")
}
}
} else{
take <- take2 <- 1:length(y[,bven])
}
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
# Zuchtwertschaetzung an sich
if(estimate.u || rrblup.required){
if(miraculix && miraculix.chol){
temp1 <- miraculix::solveRelMat(A[take,take], sigma.e.hat[bven] / sigma.a.hat[bven], multi[take], beta_hat[bven])
Rest_term <- temp1[[1]]
y_hat[take,bven] <- temp1[[2]]
} else{
Rest_term <- (chol2inv(chol(A[take,take] + R[take,take] *sigma.e.hat[bven] / sigma.a.hat[bven])) %*% multi[take])
y_hat[take,bven] <- A[take,take] %*% Rest_term  + beta_hat[bven]
}
} else{
if(miraculix && miraculix.chol){
y_hat[take,bven] <- miraculix::solveRelMat(A[take,take], sigma.e.hat[bven] / sigma.a.hat[bven], multi[take],beta_hat[bven])[[2]]
} else{
y_hat[take,bven] <- A[take,take] %*% (chol2inv(chol(A[take,take] + R[take,take] *sigma.e.hat[bven] / sigma.a.hat[bven])) %*% multi[take]) + beta_hat[bven]
}
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
z_chol <- after - before
}
# Schaetzung von Marker_effekten
if(estimate.u || rrblup.required){
rest_take <- which(duplicated(c(take,take2))[-(1:length(take))])
if(sequenceZ){
total_n <- sum(population$info$snp)
u_hat_new <- numeric(total_n)
first <- 1
last <- min(maxZ, total_n)
for(index3 in 1:ceiling(total_n/maxZ)){
if(miraculix){
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
Z.code2 <- miraculix::computeSNPS(population, loop_elements[take2,4], loop_elements[take2,5], loop_elements[take2,2],
from_p=first, to_p=last, what="geno", output_compressed=TRUE
)
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
zcalc <- zcalc + after - before
}
} else if(ncore>1){
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
if(backend=="doParallel"){
doParallel::registerDoParallel(cores=ncore)
} else if(backend=="doMPI"){
if (requireNamespace("doMPI", quietly = TRUE)) {
cl <- doMPI::startMPIcluster(count=ncore)
doMPI::registerDoMPI(cl)
} else{
stop("Usage of doMPI without being installed!")
}
} else{
print("No valid backend specified")
}
if (requireNamespace("foreach", quietly = TRUE)) {
} else{
stop("Usage of foreach without being installed!")
}
Zt <- foreach::foreach(indexb=1:ncore, .combine = "cbind", .multicombine = TRUE,.maxcombine = 1000,
.packages="MoBPS") %dopar% {
Ztpar <- array(0,dim=c(sum(population$info$snp), length(batche[[indexb]])))
sub <- min(batche[[indexb]]) -1
for(index in batche[[indexb]]){
k.database <- bve.database[loop_elements[index,3],]
cindex <- loop_elements[index,1] - sub
kindex <- loop_elements[index,2]
Ztpar[,cindex] <- base::as.integer(colSums(compute.snps(population, k.database[1],k.database[2],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))
}
if(Z.integer){
storage.mode(Ztpar) <- "integer"
}
Ztpar
}
if(backend=="doParallel"){
doParallel::stopImplicitCluster()
} else if(backend=="doMPI"){
if (requireNamespace("doMPI", quietly = TRUE)) {
doMPI::closeCluster(cl)
} else{
stop("Usage of doMPI without being installed!")
}
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
zcalc <- zcalc + after - before
}
} else{
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
for(index in 1:n.animals){
k.database <- bve.database[loop_elements[index,3],]
cindex <- loop_elements[index,1]
kindex <- loop_elements[index,2]
Zt[1:(last-first+1), cindex] <- base::as.integer(colSums(compute.snps(population, k.database[1],k.database[2],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last,decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
zcalc <- zcalc + after - before
}
}
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
if(!(length(rest_take)==length(prev_rest_take) && prod(rest_take==prev_rest_take)==1) && !fast.uhat){
A1 <- MASS::ginv(A[rest_take, rest_take])
}
if(miraculix){
if(fast.uhat){
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code2, Rest_term)
} else{
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code2, (A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
} else if(miraculix.mult){
if(fast.uhat){
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,rest_take]), Rest_term)
} else{
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,rest_take]), (A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
} else{
if(fast.uhat){
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% Rest_term)
} else{
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% (A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
z_uhat <- z_uhat + after - before
}
### LOESCHEN WENN FEHLER GEFUNDEN
if(store.bve.parameter){
population$info$p_i[[length(population$info$p_i)+1]] <- p_i
if(miraculix){
population$info$Z.code[[length(population$info$Z.code)+1]] <- as.matrix(Z.code) ## this as.matrix is using miraculix!
} else if(miraculix.mult){
population$info$Zt[[length(population$info$Zt)+1]] <- Zt
} else{
population$info$Ztm[[length(population$info$Ztm)+1]] <- Ztm
}
print("test")
population$info$rest[[length(population$info$rest)+1]] <- Rest_term
}
##########
first <- first + maxZ
last <- min(maxZ*(index3+1), total_n)
}
u_hat <- cbind(u_hat, u_hat_new)
} else{
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
rest_take <- which(duplicated(c(take,take2))[-(1:length(take))])
if(!(length(rest_take)==length(prev_rest_take) && prod(rest_take==prev_rest_take)==1)){
if(miraculix && length(take2)!=nrow(loop_elements)){
Z.code2 <- miraculix::computeSNPS(population, loop_elements[take2,4], loop_elements[take2,5], loop_elements[take2,2], what="geno",
output_compressed = TRUE)
} else{
Z.code2 <- Z.code
}
if(!fast.uhat){
A1 <- MASS::ginv(A[rest_take, rest_take])
}
prev_rest_take <- rest_take
} else if(length(prev_rest_take)==0){
Z.code2 <- Z.code
}
if(miraculix){
if(fast.uhat){
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code2, Rest_term[rest_take]))
} else{
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i)) * miraculix::genoVector(Z.code2, A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
} else if(miraculix.mult){
if(fast.uhat){
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,rest_take]), Rest_term[rest_take]))
} else{
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,rest_take]), A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
} else{
if(fast.uhat){
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% Rest_term[rest_take]))
} else{
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% (A1 %*% (y_hat[rest_take,bven] - beta_hat[bven]))))
}
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
z_uhat <- z_uhat + after - before
}
}
if(rrblup.required){
if(sequenceZ){
stop("Not implemented!")
} else{
if(miraculix){
y_hat[take3,bven] <- u_hat[,bven] %*% (as.matrix(Z.code)[,take3]-2*p_i) + beta_hat[bven]
} else {
y_hat[take3,bven] <- u_hat[,bven] %*% Ztm + beta_hat[bven]
}
}
}
}
} else{
y_hat[,bven] <- y[,bven]
}
y_hat
cor(y_hat, y)
cor(y_hat[,1], y[,1])
y
cor(y_hat[,1], y_real[,1])
check <- sum(is.na(y[,bven]))
if(check == length(y[,bven])){
cat(paste0("No phenotyped individuals for trait ", population$info$trait.name[bven], "\n"))
cat(paste0("Skip this BVE.\n"))
next
}
traitnames <- (paste0("name", 1:ncol(y)))
traitnames[bven] <- "name"
traitnames <- as.factor(traitnames)
colnames(y) <- traitnames
id <- as.factor(paste0("P", 1:nrow(y)))
y_som <- data.frame(y, id)
rownames(y_som) <- id
colnames(A) <- rownames(A) <- id
test <- sommer::mmer(name ~1, random=~sommer::vs(id, Gu=A), rcov = ~units, data=y_som)
y_hat[,bven] <- test$U[[1]][[1]]
cor(y_hat[,1], y_real[,1])
test$U
test$U[1:10]
test$U[[1]][1:10]
test$U[[1]][[1]][1:10]
sort(id)
sort(id, index.return=TRUE)
sort(id, index.return=TRUE)$ix
sort(id)
sort(id, index.return=TRUE)
?sort
sort(as.character(id), index.return=TRUE)
y_hat[sort(as.character(id))$ix,bven] <- test$U[[1]][[1]]
y_hat[sort(as.character(id), index.return=TRUE)$ix,bven] <- test$U[[1]][[1]]
cor(y_hat, y_real)
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
# Zuchtwertschaetzung an sich
if(estimate.u || rrblup.required){
if(miraculix && miraculix.chol){
temp1 <- miraculix::solveRelMat(A[take,take], sigma.e.hat[bven] / sigma.a.hat[bven], multi[take], beta_hat[bven])
Rest_term <- temp1[[1]]
y_hat[take,bven] <- temp1[[2]]
} else{
Rest_term <- (chol2inv(chol(A[take,take] + R[take,take] *sigma.e.hat[bven] / sigma.a.hat[bven])) %*% multi[take])
y_hat[take,bven] <- A[take,take] %*% Rest_term  + beta_hat[bven]
}
} else{
if(miraculix && miraculix.chol){
y_hat[take,bven] <- miraculix::solveRelMat(A[take,take], sigma.e.hat[bven] / sigma.a.hat[bven], multi[take],beta_hat[bven])[[2]]
} else{
y_hat[take,bven] <- A[take,take] %*% (chol2inv(chol(A[take,take] + R[take,take] *sigma.e.hat[bven] / sigma.a.hat[bven])) %*% multi[take]) + beta_hat[bven]
}
}
cor(y_hat, y_real)
id
sort(as.character(id), index.return=TRUE)$ix
