n_animals <- n_animals + nodes[[which(index2==ids)]]$`Number of Individuals`
}
if(n_animals>0){
nodes[[index]]$'Proportion of added genotypes' <- max(0, exp_genotyped - real_genotyped/n_animals)
} else{
nodes[[index]]$'Proportion of added genotypes' <- exp_genotyped
}
}
}
# Check for Split nodes
to_split <- NULL
split_info <- list()
split_part <- list()
for(index in 1:length(edges)){
if(edges[[index]]$'Breeding Type'=="Split"){
to_split <- unique(c(to_split, edges[[index]]$from))
split_nr <- which(to_split==edges[[index]]$from)
nodes_nr <- which(edges[[index]]$from==ids)
split_info[[split_nr]] <- 1:nodes[[nodes_nr]]$'Number of Individuals'
if(length(split_part)>= split_nr){
split_part[[split_nr]] <- c(split_part[[split_nr]], edges[[index]]$to)
} else{
split_part[[split_nr]] <- edges[[index]]$to
}
}
}
############## Founder Phenotypes ########################
if(n_traits>0){
for(index in 1:nrow(population$info$cohorts)){
population <- breeding.diploid(population, heritability = heritability,
new.bv.observation.cohorts =  population$info$cohorts[index,1],
sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
n.observation = pheno_index[which(pheno_index_name==nodes[[which(ids==population$info$cohorts[index,1])]]$'Phenotyping Class'),])
}
}
### derive order of generation
{
simulated <- founder
left <- (1:groups)[-simulated]
generation <- 1
t_index <- 1
time.point.list <- numeric(length(ids))
for(index in founder){
time.point.list[t_index] <- nodes[[index]]$earliest_time
t_index <- t_index +1
}
while(length(left)>0){
generation <- generation + 1
possible <- ids[left]
stock <- ids[-left]
for(index in 1:length(edges)){
there <- which(edges[[index]]$to==possible)
if(length(there)>0){
if(sum(edges[[index]]$from==stock)==0){
possible <- possible[-there]
}
}
}
if(length(intersect(possible, priority_breeding))>0){
possible <- intersect(possible, priority_breeding)
} else{
stock <- ids[-unique(c(left, (n_tester>n_tester_generated)*(1:length(n_tester))))]
for(index in 1:length(edges)){
there <- which(edges[[index]]$to==possible)
if(length(there)>0){
if(sum(edges[[index]]$from==stock)==0){
possible <- possible
}
}
}
}
# Remove group for which not all testers are generated
if(length(possible)==0){
stop("invalite breeding program")
}
for(group in possible){
groupnr <- which(ids==group)
simulated <- c(simulated, groupnr)
time.point <- 0
origins <- nodes[[which(ids==group)]]$origin
time_needed <- as.numeric(nodes[[which(ids==group)]]$'Time Needed')
for(temp1 in 1:length(origins)){
time.point <- max(time.point.list[which(origins[temp1]==ids[simulated])] + time_needed[temp1],time.point)
}
time.point <- max(nodes[[which(ids==group)]]$earliest_time, time.point)
time.point.list[t_index] <- time.point
t_index <- t_index + 1
}
left <- (1:groups)[-simulated]
}
generation_times <- sort(unique(time.point.list))
generation_group <- list()
generation_bv_size <- list()
for(index in 1:length(generation_times)){
nrs <- setdiff(simulated[which(time.point.list==generation_times[[index]])], founder)
btype <- numeric(length(nrs))
if(length(nrs)>0){
for(index2 in 1:length(nrs)){
btype[index2] <- nodes[[nrs[index2]]]$'Breeding Type'
}
}
prio <- which(btype=="Reproduction"| btype=="Selfing" | btype=="DH-Production" | btype=="Cloning" | btype=="Combine")
if(length(prio)>0){
nrs <- c(nrs[prio], nrs[-prio])
}
generation_group[[index]] <- ids[nrs]
changes <- 1
while(changes>0){
changes <- 0
if(length(nrs)>0){
for(index2 in 1:length(nrs)){
if(length(intersect(c(nodes[[nrs[index2]]]$origin, nodes[[nrs[index2]]]$'Manuel selected cohorts'), generation_group[[index]][index2:length(nrs)]))>0){
back <- 0
for(i_origin in c(nodes[[nrs[index2]]]$origin, nodes[[nrs[index2]]]$'Manuel selected cohorts')){
back1 <- which(generation_group[[index]]==i_origin)
back <- max(back, back1[length(back1)])
}
store_temp <- nrs[index2]
nrs[index2:(back-1)] <- nrs[(index2+1):back]
nrs[back] <- store_temp
generation_group[[index]] <- ids[nrs]
changes <- 1
}
}
}
}
btype <- numeric(length(nrs))
if(length(nrs)>0){
for(index2 in 1:length(nrs)){
btype[index2] <- nodes[[nrs[index2]]]$'Breeding Type'
}
}
database_add <- c(0,0)
while(length(btype)>0 && (btype[1]=="Reproduction"| btype[1]=="Selfing" | btype[1]=="DH-Production" | btype[1]=="Cloning" | btype[1]=="Combine")){
sex <- as.numeric(nodes[[nrs[1]]]$'Sex'=="Female") + 1
database_add <- database_add + as.numeric(nodes[[nrs[1]]]$`Number of Individuals`) * c(sex==1, sex==2)
btype <- btype[-1]
nrs <- nrs[-1]
}
generation_bv_size[[index]] <- database_add
}
}
for(index in length(generation_group):1){
if(length(generation_group[[index]])==0){
generation_group[[index]] <- NULL
generation_bv_size[[index]] <- NULL
}
}
############## Actual simulations ########################
{
for(generation in 1:length(generation_group) +1){
cat(paste0("Start simulation of generation:", generation," (time point: ", generation_times[generation-1], ")\n"))
for(group in generation_group[[generation-1]]){
groupnr <- which(ids==group)
sex <- as.numeric(nodes[[groupnr]]$'Sex'=="Female") + 1
breeding.size <- as.numeric(nodes[[groupnr]]$'Number of Individuals') * c(sex==1, sex==2)
involved_cohorts <- nodes[[groupnr]]$origin
cohort_data <- population$info$cohorts[involved_cohorts,,drop=FALSE]
sex_cohorts <- (as.numeric(cohort_data[,3])==0) +1
selection.size <- c(sum(as.numeric(cohort_data[,3])), sum(as.numeric(cohort_data[,4])))
share.genotyped <- as.numeric(nodes[[groupnr]]$`Proportion of genotyped individuals`)
cohorts.m <- involved_cohorts[sex_cohorts==1]
cohorts.f <- involved_cohorts[sex_cohorts==2]
involved_groups <- cbind(as.numeric(cohort_data[,2]), sex_cohorts)
# Derive time.point
time.point <- 0
origins <- nodes[[which(ids==group)]]$origin
time_needed <- as.numeric(nodes[[which(ids==group)]]$'Time Needed')
for(temp1 in 1:length(origins)){
time.point <- as.numeric(population$info$cohorts[population$info$cohorts[,1]==origins[temp1],8]) + time_needed[temp1]
}
time.point <- max(nodes[[which(ids==group)]]$earliest_time, time.point)
bve.database <- NULL
bve.breeding.type <- nodes[[groupnr]]$`Breeding Type`=="Selection" || nodes[[groupnr]]$`Breeding Type`=="Aging" || nodes[[groupnr]]$`Breeding Type`=="Split"
if(length(nodes[[groupnr]]$'Cohorts used in BVE') || bve.breeding.type){
if(length(nodes[[groupnr]]$'Cohorts used in BVE')==0){
bve.database <- involved_groups[,1:2, drop=FALSE]
} else if(nodes[[groupnr]]$'Cohorts used in BVE'=="Last 2 Generations"){
bve.database <- get.database(population, gen=max(1,generation-2):(generation-1))
if(generation_bv_size[[generation-1]][1]>0){
bve.database <- rbind(bve.database, c(generation,1,1,generation_bv_size[[generation-1]][1]))
}
if(generation_bv_size[[generation-1]][2]>0){
bve.database <- rbind(bve.database, c(generation,2,1,generation_bv_size[[generation-1]][2]))
}
} else if(nodes[[groupnr]]$'Cohorts used in BVE'=="All"){
bve.database <- get.database(population, gen=1:(generation-1))
} else if(nodes[[groupnr]]$'Cohorts used in BVE'=="Manual select") {
bve.database <- get.database(population, cohorts=nodes[[groupnr]]$'Manuel selected cohorts')
bve.database <- bve.database[!is.na(bve.database[,1]),, drop=FALSE]
} else if(nodes[[groupnr]]$'Cohorts used in BVE'=="Only this cohort"){
bve.database <- involved_groups[,1:2, drop=FALSE]
}
}
if(bve.breeding.type){
activemmreml <-activesommer <- activemultisommer <- activbglr <-FALSE
singlestep.active <- FALSE
depth <- 0
if(length(nodes[[groupnr]]$'Selection Type')==0){
cat("No selection type selected in some edges. Assume selection type 'Random'")
bve <- FALSE
selection <- "random"
phenotype.bv <- FALSE
computeA <- "vanRaden"
} else if(nodes[[groupnr]]$'Selection Type'=="Phenotypic"){
bve <- FALSE
selection <- "function"
phenotype.bv <- TRUE
computeA <- "vanRaden"
} else if(nodes[[groupnr]]$'Selection Type'=="BVE"){
bve <- TRUE
selection <- "function"
phenotype.bv <- FALSE
if(nodes[[groupnr]]$'Relationship Matrix'=="Pedigree"){
computeA <- "kinship"
depth <- as.numeric(nodes[[groupnr]]$'Depth of Pedigree')
} else if(nodes[[groupnr]]$'Relationship Matrix'=="Single Step"){
computeA <- "vanRaden"
depth <- as.numeric(nodes[[groupnr]]$'Depth of Pedigree')
singlestep.active <- TRUE
} else{
computeA <- "vanRaden"
}
if(nodes[[groupnr]]$'BVE Method'=="REML-GBLUP" || nodes[[groupnr]]$'BVE Method'=="REML-GBLUP (EMMREML)"){
activemmreml <- TRUE
} else if(nodes[[groupnr]]$'BVE Method'=="REML-GBLUP (sommer)") {
activesommer <- TRUE
} else if(nodes[[groupnr]]$'BVE Method'=="Multi-trait REML-GBLUP (sommer)") {
activemultisommer <- TRUE
} else if(nodes[[groupnr]]$'BVE Method'=="RKHS") {
activbglr <- TRUE
}
} else if(nodes[[groupnr]]$'Selection Type'=="Random"){
bve <- FALSE
selection <- "random"
phenotype.bv <- FALSE
computeA <- "vanRaden"
} else{
cat("No selection type selected in some edges. Assume selection type 'Random'")
bve <- FALSE
selection <- "random"
phenotype.bv <- FALSE
computeA <- "vanRaden"
}
if(length(involved_cohorts)>1){
stop("Only one cohort to select from allowed in selection - check for error")
} else{
add.observation <- pheno_index[which(pheno_index_name==nodes[[groupnr]]$'Phenotyping Class'),] -
pheno_index[which(pheno_index_name==nodes[[which(ids==involved_cohorts[1])]]$'Phenotyping Class'),]
add.observation[add.observation<0] <- 0
}
reduced.selection.panel.m <- NULL
reduced.selection.panel.f <- NULL
if(nodes[[groupnr]]$'Breeding Type'=="Selection"){
creating.type <- 1
} else if(nodes[[groupnr]]$'Breeding Type'=="Aging"){
creating.type <- 8
} else if(nodes[[groupnr]]$'Breeding Type'=="Split"){
creating.type <- 9
split_nr <- which(nodes[[groupnr]]$origin==to_split)
reduced.selection.panel.m <- split_info[[split_nr]]
reduced.selection.panel.f <- split_info[[split_nr]]
}
if(nodes[[groupnr]]$'Use Offspring for BVE'=="Yes"){
offspring.bve.parents.database <- get.database(population, cohorts=c(cohorts.m, cohorts.f))
} else{
offspring.bve.parents.database <- NULL
}
population <- breeding.diploid(population, breeding.size=breeding.size,
bve=bve, computation.A = computeA,
offspring.bve.parents.database=offspring.bve.parents.database,
BGLR.bve = activbglr,
emmreml.bve = activemmreml,
sommer.bve = activesommer,
sommer.multi.bve = activemultisommer,
selection.size= breeding.size,
copy.individual = TRUE,
added.genotyped = nodes[[groupnr]]$`Proportion of added genotypes`,
max.offspring = c(1,1),
heritability = heritability,
sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
new.bv.child="addobs",
selection.m = selection,
selection.f = selection,
phenotype.bv = phenotype.bv,
add.gen = generation,
bve.database = bve.database,
selfing.mating=TRUE,
selfing.sex=(sex-1),
best1.from.cohort = cohorts.m,
best2.from.cohort = cohorts.f,
new.class = new_mig[sex],
multiple.bve.scale=TRUE,
multiple.bve.weights = selection_index[which(selection_index_name==nodes[[groupnr]]$'Selection Index'),],
n.observation = add.observation,
remove.effect.position = remove.effect.position,
name.cohort = nodes[[groupnr]]$label,
time.point = time.point,
creating.type = creating.type,
depth.pedigree = depth,
store.breeding.totals = TRUE,
reduced.selection.panel.m = reduced.selection.panel.m,
reduced.selection.panel.f = reduced.selection.panel.f,
bve.cohorts = c(cohorts.m, cohorts.f),
bve.insert.cohorts = c(cohorts.m, cohorts.f),
display.progress=progress.bars,
singlestep.active=singlestep.active,
share.genotyped = share.genotyped
)
if(nodes[[groupnr]]$'Breeding Type'=="Split"){
split_info[[split_nr]] <- sort(setdiff(split_info[[split_nr]], split_info[[split_nr]][population$info$breeding.totals[[length(population$info$breeding.totals)]][[7]][[sex]]]))
}
} else if(nodes[[groupnr]]$'Breeding Type'=="Reproduction"){
generation.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
if(generation.sex==0 || generation.sex==1){
same.sex.activ <- TRUE
same.sex.sex <- generation.sex
}
population <- breeding.diploid(population, breeding.size=breeding.size,
selection.size= selection.size,
heritability = heritability,
sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
new.bv.child="obs",
selection.m = "random",
add.gen = generation,
bve.database = bve.database,
best1.from.cohort = cohorts.m,
best2.from.cohort = cohorts.f,
n.observation = pheno_index[which(pheno_index_name==nodes[[groupnr]]$'Phenotyping Class'),],
new.class = new_mig[sex],
same.sex.activ = same.sex.activ,
same.sex.sex = same.sex.sex,
same.sex.selfing = FALSE,
name.cohort = nodes[[groupnr]]$label,
time.point = time.point,
creating.type = 2,
store.breeding.totals = TRUE,
display.progress=progress.bars,
share.genotyped = share.genotyped,
added.genotyped = nodes[[groupnr]]$`Proportion of added genotypes`,
ogc = nodes[[groupnr]]$OGC=="Yes",
ogc_cAc = if(length(nodes[[groupnr]]$ogc_cAc)>0){nodes[[groupnr]]$ogc_cAc} else{NA},
multiple.bve.scale=TRUE,
multiple.bve.weights = selection_index[max(1,which(selection_index_name==nodes[[to_node]]$OGC_index)),],
repeat.mating = nodes[[groupnr]]$repeat_mating,
max.offspring = nodes[[groupnr]]$max_offspring
)
} else if(nodes[[groupnr]]$'Breeding Type'=="Selfing"){
selfing.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
population <- breeding.diploid(population, breeding.size=breeding.size,
selection.size= selection.size,
selfing.mating = TRUE,
selfing.sex =  selfing.sex,
heritability = heritability,
sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
new.bv.child="obs",
selection.m = "random",
add.gen = generation,
bve.database = bve.database,
best1.from.cohort = cohorts.m,
best2.from.cohort = cohorts.f,
n.observation = pheno_index[which(pheno_index_name==nodes[[groupnr]]$'Phenotyping Class'),],
new.class = new_mig[sex],
name.cohort = nodes[[groupnr]]$label,
time.point = time.point,
creating.type = 4,
store.breeding.totals = TRUE,
display.progress=progress.bars,
share.genotyped = share.genotyped,
added.genotyped = nodes[[groupnr]]$`Proportion of added genotypes`,
repeat.mating = nodes[[groupnr]]$repeat_mating,
max.offspring = nodes[[groupnr]]$max_offspring)
} else if(nodes[[groupnr]]$'Breeding Type'=="DH-Production"){
dh.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
population <- breeding.diploid(population, breeding.size=breeding.size,
selection.size= selection.size,
dh.mating = TRUE,
dh.sex =  dh.sex,
selfing.mating = TRUE,
selfing.sex = dh.sex,
heritability = heritability,
sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
new.bv.child="obs",
selection.m = "random",
add.gen = generation,
bve.database = bve.database,
best1.from.cohort = cohorts.m,
best2.from.cohort = cohorts.f,
n.observation = pheno_index[which(pheno_index_name==nodes[[groupnr]]$'Phenotyping Class'),],
new.class = new_mig[sex],
name.cohort = nodes[[groupnr]]$label,
time.point = time.point,
creating.type = 5,
store.breeding.totals = TRUE,
display.progress=progress.bars,
share.genotyped = share.genotyped,
added.genotyped = nodes[[groupnr]]$`Proportion of added genotypes`,
repeat.mating = nodes[[groupnr]]$repeat_mating,
max.offspring = nodes[[groupnr]]$max_offspring)
} else if(nodes[[groupnr]]$'Breeding Type'=="Recombination"){
population <- breeding.diploid(population, breeding.size=breeding.size,
mutation.rate = nodes[[groupnr]]$mutation,
remutation.rate = nodes[[groupnr]]$remutation,
recombination.rate = nodes[[groupnr]]$recom,
selection.size= selection.size,
heritability = heritability,
sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
new.bv.child="obs",
selection.m = "random",
add.gen = generation,
bve.database = bve.database,
best1.from.cohort = cohorts.m,
best2.from.cohort = cohorts.f,
n.observation = pheno_index[which(pheno_index_name==nodes[[groupnr]]$'Phenotyping Class'),],
new.class = new_mig[sex],
name.cohort = nodes[[groupnr]]$label,
time.point = time.point,
creating.type = 3,
store.breeding.totals = TRUE,
display.progress=progress.bars,
share.genotyped = share.genotyped,
added.genotyped = nodes[[groupnr]]$`Proportion of added genotypes`,
repeat.mating = nodes[[groupnr]]$repeat_mating,
max.offspring = nodes[[groupnr]]$max_offspring)
} else if(nodes[[groupnr]]$'Breeding Type'=="Cloning"){
selfing.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
if(length(involved_cohorts)>1){
stop("Only one cohort to select from allowed in selection - check for error")
} else{
add.observation <- pheno_index[which(pheno_index_name==nodes[[groupnr]]$'Phenotyping Class'),] -
pheno_index[which(pheno_index_name==nodes[[which(ids==involved_cohorts[1])]]$'Phenotyping Class'),]
add.observation[add.observation<0] <- 0
}
population <- breeding.diploid(population, breeding.size=breeding.size,
selection.size= selection.size,
copy.individual = TRUE,
added.genotyped = nodes[[groupnr]]$`Proportion of added genotypes`,
selfing.mating = TRUE,
selfing.sex =  selfing.sex,
heritability = heritability,
sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
new.bv.child="addobs",
selection.m = "random",
add.gen = generation,
bve.database = bve.database,
best1.from.cohort = cohorts.m,
best2.from.cohort = cohorts.f,
n.observation = pheno_index[which(pheno_index_name==nodes[[groupnr]]$'Phenotyping Class'),],
new.class = new_mig[sex],
name.cohort = nodes[[groupnr]]$label,
time.point = time.point,
creating.type = 6,
store.breeding.totals = TRUE,
display.progress=progress.bars,
share.genotyped = share.genotyped,
repeat.mating = nodes[[groupnr]]$repeat_mating,
max.offspring = nodes[[groupnr]]$max_offspring)
} else if(nodes[[groupnr]]$'Breeding Type'=="Combine"){
selfing.sex <- (as.numeric(selection.size[2])>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
if(FALSE){
stop("Only one cohort to select from allowed in selection - check for error")
} else{
add.observation <- pheno_index[which(pheno_index_name==nodes[[groupnr]]$'Phenotyping Class'),] -
pheno_index[which(pheno_index_name==nodes[[which(ids==involved_cohorts[1])]]$'Phenotyping Class'),]
add.observation[add.observation<0] <- 0
cat(paste0("Newly added phenotypes for combine note derived based on ", involved_cohorts[1],"\n"))
}
population <- breeding.diploid(population, breeding.size=breeding.size,
selection.size= breeding.size,
copy.individual = TRUE,
added.genotyped = nodes[[groupnr]]$`Proportion of added genotypes`,
max.offspring = c(1,1),
new.bv.child="addobs",
selection.m = "random",
selfing.mating=TRUE,
selfing.sex=selfing.sex,
add.gen = generation,
best1.from.cohort = cohorts.m,
best2.from.cohort = cohorts.f,
n.observation = add.observation,
new.class = new_mig[sex],
name.cohort = nodes[[groupnr]]$label,
time.point = time.point,
creating.type = 7,
store.breeding.totals = TRUE,
display.progress=progress.bars,
share.genotyped = share.genotyped)
}
position[groupnr,] <- c(generation, sex, new_mig[sex], sum(breeding.size))
new_mig[sex] <- new_mig[sex] + 1
if(phenotype_groups[groupnr]==0){
tested <- which(duplicated(c(nodes[[groupnr]]$origin, ids))[-(1:length(nodes[[groupnr]]$origin))])
n_tester_generated[tested] <- n_tester_generated[tested] + 1
}
}
cat("Generated groups:")
cat(generation_group[[generation-1]])
cat("\n")
}
}
############## Attach json-infos ########################
housing <- list(housing_index, housing_index_name)
phenotyping <- list(pheno_index_costs, pheno_index_name, pheno_index)
population$info$json <- list(nodes, edges, geninfo, traitinfo, major, housing, phenotyping, ids)
}
############ Plots  ####################
bv.development(population, json=TRUE, display.time.point = TRUE, display.creating.type = TRUE,
equal.spacing = TRUE, display.sex = TRUE, development = 1, display.cohort.name = TRUE,
bvrow=1)
bv.development.box(population, json=TRUE, display.selection = FALSE, display.reproduction = FALSE,
bvrow=1)
summary(population)
