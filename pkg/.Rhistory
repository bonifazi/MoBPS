}
}
t2 <- as.numeric(Sys.time())
if(verbose) cat(paste0(round(t2-t1, digits=2), " seconds for BVE.\n"))
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
z_chol <- after - before
}
# Estimation of marker effects via rrBLUP
if(estimate.u || rrblup.required){
while(bven>1 && (length(u_hat)==0 || ncol(u_hat)<(bven-1))){
u_hat <- cbind(u_hat,rep(0, sum(population$info$snp)))
}
rest_take <- which(duplicated(c(take,take2))[-(1:length(take))])
if(sequenceZ){
total_n <- sum(population$info$snp)
u_hat_new <- numeric(total_n)
first <- 1
last <- min(maxZ, total_n)
for(index3 in 1:ceiling(total_n/maxZ)){
if(miraculix){
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
if (requireNamespace("miraculix", quietly = TRUE)) {
Z.code2 <- miraculix::computeSNPS(population, loop_elements[take2,4], loop_elements[take2,5], loop_elements[take2,2],
from_p=first, to_p=last, what="geno", output_compressed=TRUE
)
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
zcalc <- zcalc + after - before
}
} else if(ncore>1){
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
if(backend=="doParallel"){
doParallel::registerDoParallel(cores=ncore)
} else if(backend=="doMPI"){
if (requireNamespace("doMPI", quietly = TRUE)) {
cl <- doMPI::startMPIcluster(count=ncore)
doMPI::registerDoMPI(cl)
} else{
stop("Usage of doMPI without being installed!")
}
} else{
if(verbose) cat("No valid backend specified.\n")
}
if (requireNamespace("foreach", quietly = TRUE)) {
} else{
stop("Usage of foreach without being installed!")
}
Zt <- foreach::foreach(indexb=1:ncore, .combine = "cbind", .multicombine = TRUE,.maxcombine = 1000,
.packages="MoBPS") %dopar% {
Ztpar <- array(0,dim=c(sum(population$info$snp), length(batche[[indexb]])))
sub <- min(batche[[indexb]]) -1
for(index in batche[[indexb]]){
k.database <- bve.database[loop_elements[index,3],]
cindex <- loop_elements[index,1] - sub
kindex <- loop_elements[index,2]
Ztpar[,cindex] <- base::as.integer(colSums(compute.snps(population, k.database[1],k.database[2],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))
}
if(Z.integer){
storage.mode(Ztpar) <- "integer"
}
Ztpar
}
if(backend=="doParallel"){
doParallel::stopImplicitCluster()
} else if(backend=="doMPI"){
if (requireNamespace("doMPI", quietly = TRUE)) {
doMPI::closeCluster(cl)
} else{
stop("Usage of doMPI without being installed!")
}
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
zcalc <- zcalc + after - before
}
} else{
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
for(index in 1:n.animals){
k.database <- bve.database[loop_elements[index,3],]
cindex <- loop_elements[index,1]
kindex <- loop_elements[index,2]
Zt[1:(last-first+1), cindex] <- base::as.integer(colSums(compute.snps(population, k.database[1],k.database[2],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last,decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
zcalc <- zcalc + after - before
}
}
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
if(!(length(rest_take)==length(prev_rest_take) && prod(rest_take==prev_rest_take)==1) && !fast.uhat){
A1 <- MASS::ginv(A[take2[rest_take], take2[rest_take]])
}
if(computation.A!="vanRaden"){
if(miraculix){
if (requireNamespace("miraculix", quietly = TRUE)) {
p_i <- miraculix::allele_freq(Z.code2)
}
} else{
p_i <- rowSums(Zt[,take2[rest_take]])/2
}
}
if(miraculix){
if (requireNamespace("miraculix", quietly = TRUE)) {
if(fast.uhat){
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code2, Rest_term[rest_take])
} else{
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code2, (A1 %*% (y_hat[take2[rest_take],bven] - beta_hat[bven])))
}
}
} else if(miraculix.mult){
if (requireNamespace("miraculix", quietly = TRUE)) {
if(fast.uhat){
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,take2[rest_take]]), Rest_term[rest_take])
} else{
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,take2[rest_take]]), (A1 %*% (y_hat[take2[rest_take],bven] - beta_hat[bven])))
}
}
} else{
if(fast.uhat){
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% Rest_term[rest_take])
} else{
u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))*(Zt[,rest_take] %*% (A1 %*% (y_hat[rest_take,bven] - beta_hat[bven])))
}
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
z_uhat <- z_uhat + after - before
}
first <- first + maxZ
last <- min(maxZ*(index3+1), total_n)
}
u_hat <- cbind(u_hat, u_hat_new)
} else{
if(store.comp.times.bve){
before <- as.numeric(Sys.time())
}
rest_take <- which(duplicated(c(take,take2))[-(1:length(take))])
if(!(length(rest_take)==length(prev_rest_take) && prod(rest_take==prev_rest_take)==1)){
if(miraculix && length(take2)!=nrow(loop_elements)){
if (requireNamespace("miraculix", quietly = TRUE)) {
Z.code2 <- miraculix::computeSNPS(population, loop_elements[take2,4], loop_elements[take2,5], loop_elements[take2,2], what="geno",
output_compressed = TRUE)
}
} else if(length(take2)!=nrow(loop_elements)){
Zt2 <- Zt[,take2[rest_take]]
} else if(miraculix){
Z.code2 <- Z.code
} else {
Zt2 <- Zt
}
if(!fast.uhat){
A1 <- MASS::ginv(A[take2[rest_take], take2[rest_take]])
}
prev_rest_take <- rest_take
} else if(length(prev_rest_take)==0){
if(miraculix){
Z.code2 <- Z.code
} else{
Zt2 <- Zt
}
}
if(computation.A!="vanRaden"){
if(miraculix){
if (requireNamespace("miraculix", quietly = TRUE)) {
p_i <- miraculix::allele_freq(Z.code2)
}
} else{
p_i <- rowSums(Zt[,take2[rest_take]])/2
}
}
if(miraculix){
if (requireNamespace("miraculix", quietly = TRUE)) {
if(fast.uhat){
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code2, Rest_term[rest_take]))
} else{
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i)) * miraculix::genoVector(Z.code2, A1 %*% (y_hat[take2[rest_take],bven] - beta_hat[bven])))
}
}
} else if(miraculix.mult){
if (requireNamespace("miraculix", quietly = TRUE)) {
if(fast.uhat){
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,take2[rest_take]]), Rest_term[rest_take]))
} else{
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::genomicmatrix(Zt[,take2[rest_take]]), A1 %*% (y_hat[take2[rest_take],bven] - beta_hat[bven])))
}
}
} else{
if(fast.uhat){
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))*(Zt[,take2[rest_take]] %*% Rest_term[rest_take]))
} else{
u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))*(Zt[,take2[rest_take]] %*% (A1 %*% (y_hat[take2[rest_take],bven] - beta_hat[bven]))))
}
}
if(store.comp.times.bve){
after <- as.numeric(Sys.time())
z_uhat <- z_uhat + after - before
}
}
if(rrblup.required){
if(sequenceZ){
stop("Not implemented!")
} else{
if(miraculix){
if (requireNamespace("miraculix", quietly = TRUE)) {
y_hat[take3,bven] <- u_hat[,bven] %*% (as.matrix(Z.code)[,take3]-2*p_i) + beta_hat[bven]
}
} else {
y_hat[take3,bven] <- u_hat[,bven] %*% Ztm[,take3] + beta_hat[bven]
}
}
}
}
} else{
y_hat[,bven] <- y[,bven]
}
if(store.comp.times.bve==TRUE){
comp.times.bve[4] <- as.numeric(Sys.time())
}
if(report.accuracy && bven==population$info$bv.nr){
if(verbose) cat("Correlation between genetic values and BVE:\n")
if(n.rep==0){
y_hat_temp <- y_hat
y_hat_temp[y_hat_temp==0] <- NA
acc <- suppressWarnings(stats::cor(y_real[bve.insert,], y_hat_temp[bve.insert,], use="pairwise.complete.obs"))
} else{
insert.temp <- numeric(length(bve.insert.copy))
if(length(stay.loop.elements)>0){
for(index in (1:nrow(loop_elements_copy))[bve.insert.copy]){
insert.temp[index] <- which(stay.loop.elements==loop_elements_copy[index,6])
}
} else{
for(index in (1:nrow(loop_elements_copy))[bve.insert.copy]){
insert.temp[index] <- loop_elements_copy[index,6]
}
}
y_hat_temp <- rbind(y_hat[bve.insert,,drop=FALSE], y_hat[insert.temp,,drop=FALSE])
y_hat_temp[y_hat_temp==0] <- NA
acc <- suppressWarnings(stats::cor(rbind(y_real[bve.insert,,drop=FALSE], y_real[insert.temp,, drop=FALSE]),
y_hat_temp, use="pairwise.complete.obs"))
}
if(length(acc)==1){
acc <- matrix(acc,nrow=1)
}
if(sum(is.na(acc))>0){
acc[is.na(acc)] <- 0
}
if(verbose) cat(diag(acc))
if(verbose) cat("\n")
}
for(index in (1:nrow(loop_elements))[bve.insert]){
population$breeding[[loop_elements[index,4]]][[loop_elements[index,5]+2]][, loop_elements[index,2]] <- y_hat[index,]
}
if(calculate.reliability){
for(index in (1:nrow(loop_elements))[bve.insert]){
population$breeding[[loop_elements[index,4]]][[loop_elements[index,5]+18]][, loop_elements[index,2]] <- y_reli[index,]
}
}
if(n.rep>0){
for(index in (1:nrow(loop_elements_copy))[bve.insert.copy]){
if(length(stay.loop.elements)>0){
non_copy <- which(stay.loop.elements==loop_elements_copy[index,6])
} else{
non_copy <- loop_elements_copy[index,6]
}
if(length(non_copy)==1){
population$breeding[[loop_elements_copy[index,4]]][[loop_elements_copy[index,5]+2]][, loop_elements_copy[index,2]] <- y_hat[non_copy,]
}
}
}
#  GWAS CODE NOT WRITEN FOR PARALLEL COMPUTING
if(gwas.u){
if(y.gwas.used=="pheno"){
y_gwas <- y
} else if(y.gwas.used=="bv"){
y_gwas <- y_real
} else if(y.gwas.used=="bve"){
y_gwas <- y_hat
}
if(nrow(gwas.database)!=nrow(bve.database) || prod(gwas.database==bve.database)==0){
loop_elements_gwas_list <- derive.loop.elements(population=population, bve.database=bve.database,
bve.class=bve.class, bve.avoid.duplicates=bve.avoid.duplicates,
store.adding=TRUE)
loop_elements_gwas <- loop_elements_gwas_list[[1]]
n.animals.gwas <- nrow(loop_elements_gwas)
}
if(gwas.group.standard){
gwas_start <- loop_elements_gwas_list[[2]]
}
if(sequenceZ){
if(nrow(gwas.database)!=nrow(bve.database) || prod(gwas.database==bve.database)==0){
if(maxZtotal>0){
maxZ <- floor(maxZtotal / n.animals.gwas)
}
if(ncore<=1 && miraculix==FALSE){
Zt <- array(0L,dim=c(maxZ,n.animals.gwas))
}
y_gwas <- array(0, dim=c(n.animals.gwas, population$info$bv.nr))
}
total_n <- sum(population$info$snp)
x_mean <- x2_mean <- xy_mean <- numeric(total_n)
first <- 1
last <- min(maxZ, total_n)
for(index3 in 1:ceiling(total_n/maxZ)){
cindex <- 1
for(index in 1:n.animals.gwas){
k.database <- gwas.database[loop_elements_gwas[index,3],]
if(miraculix){
if (requireNamespace("miraculix", quietly = TRUE)) {
Zt[1:(last-first+1), cindex] <- miraculix::computeSNPS(population, k.database[1],k.database[2],kindex, from_p=first, to_p=last, what="geno", output_compressed=FALSE)
}
} else{
Zt[1:(last-first+1), cindex] <- base::as.integer(colSums(compute.snps(population, k.database[1],k.database[2],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))
}
population$breeding[[k.database[1]]][[k.database[2]]][[kindex]][[16]] <- 1
for(bven in 1:population$info$bv.nr){
# HIER EVENTUELL SNPs auslesen!
if(y.gwas.used=="pheno"){
y_gwas[cindex,bven] <- population$breeding[[k.database[1]]][[8+k.database[2]]][bven,kindex]
} else if(y.gwas.used=="bv"){
y_gwas[cindex,bven] <- population$breeding[[k.database[1]]][[6+k.database[2]]][bven,kindex]
} else if(y.gwas.used=="bve"){
y_gwas[cindex,bven] <- population$breeding[[k.database[1]]][[2+k.database[2]]][bven,kindex]
}
}
cindex <- cindex +1
}
}
if(gwas.group.standard){
for(indexg in 1:(length(gwas_start)-1)){
if(gwas_start[indexg]<=(gwas_start[indexg+1]-1)){
y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven] <- y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven] - mean(y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven])
}
}
}
x_mean[first:last] <- rowMeans(Zt[1:(last-first+1),])
x2_mean[first:last] <- rowMeans(Zt[1:(last-first+1),]^2)
xy_mean[first:last] <- rowMeans(Zt[1:(last-first+1),]*y_gwas[,bven])
first <- first + maxZ
last <- min(maxZ*(index3+1), total_n)
} else{
if(nrow(gwas.database)!=nrow(bve.database) || prod(gwas.database==bve.database)==0){
Zt <- array(0L,dim=c(sum(population$info$snp), n.animals.gwas))
y_gwas <- array(0, dim=c(n.animals.gwas, population$info$bv.nr))
cindex <- 1
for(index in 1:n.animals.gwas){
k.database <- gwas.database[loop_elements_gwas[index,3],]
if(miraculix){
if (requireNamespace("miraculix", quietly = TRUE)) {
Zt[,cindex] <- miraculix::computeSNPS(population, k.database[1],k.database[2],kindex, what="geno", output_compressed=FALSE)
}
} else{
Zt[,cindex] <- base::as.integer(colSums(compute.snps(population, k.database[1],k.database[2],kindex, import.position.calculation=import.position.calculation, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))
}
for(bven in 1:population$info$bv.nr){
# HIER EVENTUELL SNPs auslesen!
if(y.gwas.used=="pheno"){
y_gwas[cindex,bven] <- population$breeding[[k.database[1]]][[8+k.database[2]]][bven,kindex]
} else if(y.gwas.used=="bv"){
y_gwas[cindex,bven] <- population$breeding[[k.database[1]]][[6+k.database[2]]][bven,kindex]
} else if(y.gwas.used=="bve"){
y_gwas[cindex,bven] <- population$breeding[[k.database[1]]][[2+k.database[2]]][bven,kindex]
}
}
cindex <- cindex +1
}
}
if(gwas.group.standard){
for(indexg in 1:(length(gwas_start)-1)){
if(gwas_start[indexg]>=(gwas_start[indexg+1]-1)){
y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven] <- y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven] - mean(y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven])
}
}
}
x_mean <- rowMeans(Zt)
x2_mean <- rowMeans(Zt^2)
#          xy_mean <- colMeans(Z*y_gwas[,bven])
xy_mean <- colMeans(t(Zt)*y_gwas[,bven])
}
n <- length(y_gwas[,bven])
y_mean <- mean(y_gwas[,bven])
b1 <- (n *xy_mean - n *x_mean * y_mean) / (x2_mean*n - n *x_mean^2)
if(approx.residuals==FALSE){
sigma1 <- 1/(n * (x2_mean-(x_mean)^2))
b0 <- y_mean - b1 * x_mean
var1 <- numeric(length(sigma1))
for(index in 1:length(sigma1)){
var1[index] <- sigma1[index] * stats::var(y_gwas[,bven] - b1[index] * Zt[index,] - b0[index]) * (n-1)/(n-2)
}
} else{
var1 <- 1/(n * (x2_mean-(x_mean)^2)) * stats::var(y_gwas[,bven])
}
test <- b1/sqrt(var1)
gwas_hat <- cbind(gwas_hat, test)
#sorted <- sort(abs(test), index.return=TRUE)
}
}
}
if(u_hat_possible && bve && estimate.u && computation.A=="vanRaden"){
population$info$u_hat[[length(population$info$u_hat)+1]] <- u_hat
population$info$u_hat_single[[length(population$info$u_hat)]] <- list()
for(bven in 1:ncol(u_hat)){
population$info$u_hat_single[[length(population$info$u_hat)]][[bven]] <- cbind((-2*p_i) *u_hat[,bven],(-2*p_i+1) *u_hat[,bven],(-2*p_i+2) *u_hat[,bven])
}
} else if(u_hat_possible && bve && estimate.u && computation.A=="CM"){
population$info$u_hat[[length(population$info$u_hat)+1]] <- u_hat
population$info$u_hat_single[[length(population$info$u_hat)]] <- list()
for(bven in 1:ncol(u_hat)){
population$info$u_hat_single[[length(population$info$u_hat)]][[bven]] <- cbind(u_hat[1:nrow(Zt),bven],u_hat[1:nrow(Zt)+ nrow(Zt),bven],u_hat[1:nrow(Zt)+2*nrow(Zt),bven])
}
}
if(gwas.u){
if(sum(is.na(gwas_hat)>0)){
gwas_hat[is.na(gwas_hat)] <- 0
}
population$info$gwas_hat[[length(population$info$gwas_hat)+1]] <- gwas_hat
}
if(store.comp.times.bve){
comp.times.bve[5] <- as.numeric(Sys.time())
}
}
dim(Zt)
if(miraculix){
Zt <- as.matrix(Z.code)
}
Zt <- t(scale(t(Zt), center=TRUE, scale=FALSE))
Zt[1:5,1:5]
fixed <- which(is.na(Z[,1]))
fixed <- which(is.na(Zt[,1]))
fixed
if(length(fixed)>0){
Zt <- Zt[-fixed,]
}
if(BGLR.model=="RKHS"){
ETA <- list(list(K=A, model='RKHS'))
} else if(BGLR.model=="BayesA"){
ETA <- list(list(X=Z, model='BayesA'))
} else if(BGLR.model=="BayesB"){
ETA <- list(list(X=Z, model='BayesB'))
} else if(BGLR.model=="BayesC"){
ETA <- list(list(X=Z, model='BayesC'))
}
ETA <- list(list(K=A, model='RKHS'))
min(y[!is.na(y[,bven]),bven])==max(y[!is.na(y[,bven]),bven])
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
fm$yHat
cor(fm$yHat, y_real[,bven])
ETA <- list(list(X=Zt, model='BayesA'))
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
cor(fm$yHat, y_real[,bven])
ETA <- list(list(X=Zt, model='BayesB'))
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
ETA
dim(y)
dim(Zt)
ETA <- list(list(X=Zt, model='BayesC'))
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
ETA <- list(list(X=t(Zt), model='BayesB'))
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
cor(fm$yHat, y_real[,bven])
ETA <- list(list(X=t(Zt), model='BayesA'))
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
cor(fm$yHat, y_real[,bven])
ETA <- list(list(X=t(Zt), model='BayesC'))
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
cor(fm$yHat, y_real[,bven])
ETA <- list(list(X=t(Zt), model='BL'))
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
cor(fm$yHat, y_real[,bven])
ETA <- list(list(X=t(Zt), model='BRR'))
fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)
cor(fm$yHat, y_real[,bven])
install.packages("vcfR")
install.packages("biomaRt")
install.packages("BiocManager")
BiocManager::install("biomaRt")
MoBPS::generation.individual
??sd
?sd
?var
?useMart
library(BiocManager)
?biomaRt::useMart
install.packages("rlang")
install.packages("rlang")
install.packages("digest")
install.packages("processx")
library("processx", lib.loc="~/R/win-library/3.5")
detach("package:processx", unload=TRUE)
library("processx", lib.loc="~/R/win-library/3.5")
detach("package:processx", unload=TRUE)
install.packages("processx")
install.packages("processx", version="3.4.0")
install.packages("processx", version = "3.4.0")
install.packages("C:/Users/pook/Downloads/biomaRt_2.36.1.tar.gz", repos = NULL, type = "source")
install.packages("Rcpp")
install.packages("C:/Users/pook/Downloads/biomaRt_2.36.1.tar.gz", repos = NULL, type = "source")
install.packages("C:/Users/pook/Downloads/biomaRt_2.36.1.tar.gz", repos = NULL, type = "source")
install.packages("~/GitHub/MoBPS/RandomFieldsUtils_0.5.9.tar.gz", repos = NULL, type = "source")
install.packages("~/GitHub/MoBPS/miraculix_0.9.6.tar.gz", repos = NULL, type = "source")
install.packages("cluster")
install.packages("C:/Users/pook/Desktop/R-Stuff/MoBPSmaps_0.1.7.tar.gz", repos = NULL, type = "source")
MoBPSmaps::map_sorghum1
