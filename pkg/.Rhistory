prev <- 0
it <- nrow(vcf_file@fix)
for(index in 1:it){
if(prev < it && map[prev+1,2]==vcf_file@fix[index,3]){
prev <- prev +1
} else{
prev <- which(map[,2]==vcf_file@fix[index,3])
}
order[index] <- prev
}
haplo <- matrix(0,nrow=nrow(map), ncol=ncol(haplo))
haplo[order,] <- haplo_temp
} else{
stop("Data-import failed! vcfR-package not available! \n")
}
} else if(data_type=="ped"){
cat("Data input identified as Ped-map-file - extract genomic information \n")
if(sum(path==phasing_list)>0){
pedmap.to.phasedbeaglevcf(ped_path=path, map_path=geninfo$`Own Map Path`)
if(requireNamespace("vcfR", quietly = TRUE)){
vcf_file <- vcfR::read.vcfR("/home/nha/Plink/DB/temp_vcf_phased.vcf.gz")
haplo1 <- substr(vcf_file@gt[,-1], start=1, stop=1)
haplo2 <- substr(vcf_file@gt[,-1], start=3, stop=3)
storage.mode(haplo1) <- storage.mode(haplo2) <- "integer"
haplo_temp <- cbind(haplo1, haplo2)
haplo_temp <- haplo_temp[,c(0,ncol(haplo1)) + rep(1:ncol(haplo1), each=2)]
order <- numeric(nrow(map))
prev <- 0
it <- nrow(vcf_file@fix)
for(index in 1:it){
if(prev < it && map[prev+1,2]==vcf_file@fix[index,3]){
prev <- prev +1
} else{
prev <- which(map[,2]==vcf_file@fix[index,3])
}
order[index] <- prev
}
haplo <- matrix(0,nrow=nrow(map), ncol=ncol(haplo))
haplo[order,] <- haplo_temp
} else{
stop("Data-import failed! vcfR-package not available! \n")
}
} else{
cat("Haplotype phase is assumed to be by colum - No internal phasing performed! \n")
ped_file <- utils::read.table(data_path)
haplo12 <- t(ped_file[,-(1:6)])
haplo <- matrix(0, ncol = ncol(haplo12)*2, nrow=nrow(haplo12)/2)
for(index1 in 1:ncol(haplo12)){
haplo[,index1*2+c(-1,0)] <- matrix(haplo12[,index1], ncol=2, byrow=TRUE)
}
}
} else if(data_type=="ata"){
Map <- map ## Lisas subpos contain a element named map"
data_store <- load(data_path)
map <- Map
if(length(data_store)>1){
cat("More than one object contain in .Rdata - unless the data object is named 'haplo' import will fail! \n")
} else{
haplo <- eval(parse(text=map_store[[1]]))
}
}
}
takes <- which(path_list==path)
no_data[takes] <- 1
take <- NULL
for(index in takes){
take <- c(take, starts[index]:(starts[index+1]-1))
}
if(nrow(haplo)!=sum(nsnp)){
if(data_type=="vcf" || data_type==".gz"){
chr.opt <- unique(vcf_file@fix[,1])
nsnp <- numeric(length(chr.opt))
for(index in 1:length(chr.opt)){
nsnp[index] <- sum(vcf_file@fix[,1]==chr.opt[index])
}
} else{
nsnp <- floor(nsnp*nrow(haplo)/sum(nsnp))
nsnp[1] <- nsnp[1] + nrow(haplo)-sum(nsnp)
}
dataset <- matrix(0L, nrow= sum(nsnp), ncol = sum(position[,4])*2)
map <- NULL
for(index in 1:nchromo){
map <- rbind(map, cbind(index, paste0("SNP", 1:nsnp[index]), NA, NA, NA))
}
}
if(length(haplo) != length(dataset[,take])){
cat("Size of Founder-dataset not in concorance with node size!\n")
haplo <- rep(haplo, length.out=length(dataset[,take]))
}
if(storage.mode(haplo)!="integer"){
storage.mode(haplo) <- "integer"
}
dataset[,take] <- haplo
}
if((n_traits)>0){
for(index in 1:n_traits){
major[[index]] <- traitinfo[[index]]$'Trait QTL Info'
if(length(major[[index]])>0 && length(major[[index]][[1]])>1){
ncols <- length(major[[index]][[1]])
mqtl <- matrix(unlist(major[[index]]), ncol=ncols, byrow=TRUE)
to_enter <- mqtl[,c(1,4:8), drop=FALSE]
to_enter_name <- mqtl[,c(2,3), drop=FALSE]
storage.mode(to_enter) <- "numeric"
if(sum(is.na(to_enter[,2]))>0 || sum(is.na(to_enter[,1]))>0){
check_qtl <- unique(c(which(is.na(to_enter[,1])), which(is.na(to_enter[,2]))))
for(sample_index in check_qtl){
take_qtl <- which(to_enter_name[sample_index,1] == map[,2])
if(length(take_qtl)>0){
to_enter[sample_index, 2] <- as.numeric(map[take_qtl[1], 1])
to_enter[sample_index, 1] <- sum(map[1:take_qtl[1], 1] == map[take_qtl[1], 1])
cat("SNP-position assigned via SNP-name\n")
} else{
if(is.na(to_enter[sample_index,2])){
to_enter[sample_index,2] <- 1
cat("Illegal Chromosom-name. Simulate major SNP-effect on chromosome 1")
}
if(!is.na(as.numeric(to_enter_name[sample_index,2]))){
diff_to <- - abs(as.numeric(map[,3]) - as.numeric(to_enter_name[sample_index,2]))
diff_to[map[,1]!=to_enter[sample_index,2]] <- -Inf
take_qtl <- which.max(diff_to)
to_enter[sample_index, 2] <- as.numeric(map[take_qtl[1], 1])
to_enter[sample_index, 1] <- sum(map[1:take_qtl[1], 1] == map[take_qtl[1], 1])
cat("SNP-position assigned via bp position\n")
} else{
to_enter[sample_index,1] <- sample(1:nsnp[to_enter[sample_index,2]],1)
cat(paste0("Illegal SNP-name/bp/position. SNP-effect generated on SNP ", to_enter[sample_index,1],"\n"))
}
}
}
}
to_enter[to_enter[,6]=="",6] <- NA
major_table[[index]] <- to_enter
}
}
}
# Change Allele frequencies according to selection in major QTLs
if(length(major_table)>0){
for(index in 1:length(major_table)){
if(length(major_table[[index]])>0){
for(index2 in 1:nrow(major_table[[index]])){
take <- which(cumsum((map[,1]==major_table[[index]][index2,2]))==major_table[[index]][index2,1])[1]
map[take,5] <- major_table[[index]][index2,6]
}
}
}
}
for(subpop in 1:length(subpopulations)){
if(sum(no_data==0 & founder_pop==subpopulation_info[subpop,1])>0){
takes <- which(no_data==0 & founder_pop==subpopulation_info[subpop,1])
take <- NULL
for(index in takes){
take <- c(take, starts[index]:(starts[index+1]-1))
}
if(sum(no_data==1 & founder_pop==subpopulation_info[subpop,1])>0){
takes2 <- which(no_data==1 & founder_pop==subpopulation_info[subpop,1])
take2 <- NULL
for(index in takes2){
take2 <- c(take2, starts[index]:(starts[index+1]-1))
}
if(miraculix.dataset){
p_i[[subpop]] <- miraculix::allele_freq(miraculix::genomicmatrix(dataset[,take2]))*2
} else{
p_i[[subpop]] <- rowMeans(dataset[,take2])
}
} else{
p_i[[subpop]] <- stats::rbeta(sum(nsnp), shape1=as.numeric(subpopulation_info[subpop,2]),
shape2=as.numeric(subpopulation_info[subpop,3]))
set_zero <- sample(1:sum(nsnp), sum(nsnp) * as.numeric(subpopulation_info[subpop,4]))
if(length(set_zero)>0){
set_one <- sample((1:sum(nsnp))[-set_zero], sum(nsnp) * as.numeric(subpopulation_info[subpop,5]))
} else{
set_one <- sample((1:sum(nsnp)), sum(nsnp) * as.numeric(subpopulation_info[subpop,5]))
}
if(length(set_zero)>0){
p_i[[subpop]][set_zero] <- 0
}
if(length(set_one)>0){
p_i[[subpop]][set_one] <- 1
}
}
if(sum(!is.na(map[,5]))){
p_i[[subpop]][!is.na(map[,5])] <- as.numeric(map[!is.na(map[,5]),5])
}
## Manually selected replaces!
major_sub[[index]] <- subpopulations[[subpop]]$'QTL Info'
if(length(major_sub[[index]])>0 && length(major_sub[[index]][[1]])>1){
ncols <- length(major_sub[[index]][[1]])
mqtl_sub <- matrix(unlist(major_sub[[index]]), ncol=ncols, byrow=TRUE)
to_enter_sub <- mqtl_sub[,c(1,4:6), drop=FALSE]
to_enter_name_sub <- mqtl[,c(2,3), drop=FALSE]
storage.mode(to_enter_sub) <- "numeric"
if(sum(is.na(to_enter_sub[,2]))>0 || sum(is.na(to_enter_sub[,1]))>0){
check_qtl <- unique(c(which(is.na(to_enter_sub[,1])), which(is.na(to_enter_sub[,2]))))
for(sample_index in check_qtl){
take_qtl <- which(to_enter_name_sub[sample_index,1] == map[,2])
if(length(take_qtl)>0){
to_enter_sub[sample_index, 2] <- as.numeric(map[take_qtl[1], 1])
to_enter_sub[sample_index, 1] <- sum(map[1:take_qtl[1], 1] == map[take_qtl[1], 1])
cat("SNP-position assigned via SNP-name\n")
} else{
if(is.na(to_enter_sub[sample_index,2])){
to_enter_sub[sample_index,2] <- 1
cat("Illegal Chromosom-name. Simulate major SNP-effect on chromosome 1")
}
if(!is.na(as.numeric(to_enter_name_sub[sample_index,2]))){
diff_to <- - abs(as.numeric(map[,3]) - as.numeric(to_enter_name_sub[sample_index,2]))
diff_to[map[,1]!=to_enter_sub[sample_index,2]] <- -Inf
take_qtl <- which.max(diff_to)
to_enter_sub[sample_index, 2] <- as.numeric(map[take_qtl[1], 1])
to_enter_sub[sample_index, 1] <- sum(map[1:take_qtl[1], 1] == map[take_qtl[1], 1])
cat("SNP-position assigned via bp position\n")
} else{
to_enter_sub[sample_index,1] <- sample(1:nsnp[to_enter_sub[sample_index,2]],1)
cat(paste0("Illegal SNP-name/bp/position. SNP-effect generated on SNP ", to_enter_sub[sample_index,1],"\n"))
}
}
}
}
to_enter_sub[to_enter_sub[,4]=="",4] <- NA
major_table_sub[[index]] <- to_enter_sub
position_change <- cumsum(c(0, nsnp))[to_enter_sub[,2]] + to_enter_sub[,1]
p_i[[subpop]][position_change] <- to_enter_sub[,3]
}
}
if(miraculix.dataset){
nindi <- (starts[max(takes)+1] - starts[min(takes)])/2
chr.nr <- map[,1]
chr.opt <- unique(chr.nr)
dataset <- list()
for(chr_index in 1:length(chr.opt)){
dataset[[chr_index]] <- miraculix::rhaplo(p_i[[subpop]][which(chr.nr==chr.opt[chr_index])], indiv = nindi, loci = nsnp[chr_index])
}
} else{
for(index in takes){
# Integer * Integer > 2^32 --> NA! conversion to numerics
take <- starts[index]:(starts[index+1]-1)
input_type <- nodes[[founder[index]]]$`Genotype generation`
if(input_type=="Random-sampling"){
dataset[,take] <- stats::rbinom(as.numeric(nrow(dataset))*as.numeric(length(take)),1, prob=p_i[[subpop]])
} else if(input_type=="Fully-homozygous"){
dataset[,take[c(1:(length(take)/2)*2-1,1:(length(take)/2)*2)]] <- stats::rbinom(as.numeric(nrow(dataset))*as.numeric(length(take))/2,1, prob=p_i[[subpop]])
# generate half as many alleles as spots to fill - rest is autocompleted
} else if(input_type=="Fully-heterozygous"){
dataset[,c(1:(length(take)/2)*2)-1] <- 0L # just for safety but not necessary
dataset[,c(1:(length(take)/2)*2)] <- 1L
} else if(input_type=="All-B-Allele"){
dataset[,take] <- 1L
} else if(input_type=="All-A-Allele "){
dataset[,take] <- 0L
} else{
stop("Invalid input type for founder node!")
}
}
}
}
}
population <- NULL
population <- creating.diploid(dataset = dataset, nindi=length(sex.s),
sex.s = sex.s, genotyped.s = genotyped.s,
chromosome.length = chromo.length,
snps.equidistant = if(is.na(map[1,4])) {TRUE} else {FALSE}, miraculix = miraculix,
miraculix.dataset = miraculix.dataset,
chr.nr = map[,1], bp=map[,3], snp.name = map[,2],
freq = map[,5], snp.position = if(is.na(map[1,4])) {NULL} else {map[,4]})
# Cohort names
gender_founder <- numeric(length(founder))
nr <- 1
for(index in 1:length(founder)){
gender_founder[index] <- sex.s[nr]
nr <- nr + position[founder[index],4]
}
founder_temp <- founder[sort(gender_founder,index.return=TRUE)$ix]
cohort_info <- cbind(ids[founder_temp], 1, position[founder_temp,4], position[founder_temp,4], position[founder_temp,3], 1+cumsum(c(0,position[founder_temp,4]))[-(length(founder_temp)+1)], 1+cumsum(c(0,position[founder_temp,4]))[-(length(founder_temp)+1)] - sum(sex.s==1),
earliest_time[founder_temp], 0)
cohort_info[(cohort_info[,7]>=1),c(3,6)] <- 0
cohort_info[(cohort_info[,7]<1),c(4,7)] <- 0
population$info$cohorts <- cohort_info
colnames(population$info$cohorts) <- c("name","generation", "male individuals", "female individuals", "class", "position first male", "position first female",
"time point", "creating.type")
if(n_traits>0){
population <- creating.trait(population, n.additive = as.numeric(trait_matrix[,6]),
shuffle.cor = cor_gen, new.phenotype.correlation = cor_pheno,
shuffle.traits=1:n_traits,
trait.name = trait_matrix[,1])
# Correct Scaling
snp.before <- cumsum(c(0,population$info$snp))
## REASON?!
if(TRUE){
for(index in 1:n_traits){
if(length(population$info$real.bv.add[[index]])>0){
t <- population$info$real.bv.add[[index]]
take <- sort(t[,1]+ snp.before[t[,2]], index.return=TRUE)
t <- t[take$ix,,drop=FALSE]
take <- sort(t[,1]+ t[,2] * 10^10)
keep <- c(0,which(diff(take)!=0), length(take))
if(length(keep) <= nrow(t)){
for(index2 in 2:(length(keep))){
t[keep[index2],3:5] <- colSums(t[(keep[index2-1]+1):keep[index2],3:5, drop=FALSE])
}
population$info$real.bv.add[[index]] <- t[keep,]
}
}
}
}
## Variance Standardization
for(index in 1:n_traits){
new_var <- as.numeric(trait_matrix[index,4])^2
if(population$info$bv.calculated==FALSE){
population <- breeding.diploid(population)
}
active_sub <- subpopulation_info[1,1]
standard_cohort <- population$info$cohorts[which(founder_pop==active_sub),1]
var_test <- stats::var(get.bv(population, cohorts= standard_cohort)[index,])
if(length(population$info$real.bv.add[[index]])>0){
population$info$real.bv.add[[index]][,3:5] <- population$info$real.bv.add[[index]][,3:5] * sqrt(  new_var / var_test)
} else{
cat("You entered a trait without quantitative loci. Is this intentional?\n")
}
}
population$info$bv.calculated <- FALSE
## Mean Standardization
for(index in 1:n_traits){
if(population$info$bv.calculated==FALSE){
population <- breeding.diploid(population)
}
active_sub <- subpopulation_info[1,1]
standard_cohort <- population$info$cohorts[which(founder_pop==active_sub),1]
mean_test <- mean(get.bv(population, cohorts= standard_cohort)[index,])
population$info$base.bv[index] <- traitmean[index] + population$info$base.bv[index] - mean_test
}
population$info$bv.calculated <- FALSE
## Add Major QTL
for(index in 1:n_traits){
if(length(major_table)>=index && length(major_table[[index]])>0){
to_enter <- major_table[[index]][,1:5,drop=FALSE]
} else{
to_enter <- rbind(NULL)
}
if(length(to_enter)>0 || length(population$info$real.bv.add[[index]])>0){
population$info$real.bv.add[[index]] <- rbind(to_enter, population$info$real.bv.add[[index]])
if(population$info$real.bv.length[1]<index && length(to_enter)>0){
population$info$real.bv.length[1] <- index
}
}
}
## Subpopulation differences
if(length(subpopulations)>1){
for(subpop in 1:length(subpopulations)){
if(population$info$bv.calculated==FALSE){
population <- breeding.diploid(population)
}
if(length(subpopulations[[subpop]])>7){
for(indexmod in 8:length(subpopulations[[subpop]])){
active_trait <- as.numeric(substr(names(subpopulations[[subpop]])[[indexmod]], start=2, stop=nchar(names(subpopulations[[subpop]])[[indexmod]])))
valid_markers0 <- valid_markers1 <- which(p_i[[subpop]]>0 & p_i[[subpop]]<1)
for(reduction in (1:length(subpopulations))[-subpop]){
valid_markers0 <- intersect(valid_markers0, which(p_i[[reduction]]==0))
}
for(reduction in (1:length(subpopulations))[-subpop]){
valid_markers1 <- intersect(valid_markers1, which(p_i[[reduction]]==1))
}
valid_markers <- c(valid_markers0, valid_markers1)
subpop_name <- subpopulation_info[subpop,1]
sub_cohort <- population$info$cohorts[which(founder_pop==subpop_name),1]
mean_ref <- mean(get.bv(population, cohorts= standard_cohort )[active_trait,])
mean_sub <- mean(get.bv(population, cohorts= sub_cohort )[active_trait,])
current_diff <- mean_sub - mean_ref
target_diff <- as.numeric(subpopulations[[subpop]][[indexmod]])
if(subpop==1){
change <- target_diff
} else{
change <- target_diff - current_diff
}
diff_freq <- c(p_i[[subpop]][valid_markers0], - p_i[[subpop]][valid_markers1])
effect_size <- change / sum(abs(diff_freq)) / 2
direction <- diff_freq > 0
snp_index <- chromo_index <- numeric(length(valid_markers))
for(index2 in 1:length(valid_markers)){
chromo_index[index2] <- max(which(c(0,population$info$cumsnp)<=valid_markers[index2]))
snp_index[index2] <- valid_markers[index2] - c(0,population$info$cumsnp)[chromo_index[index2]]
}
add.effects <- cbind(snp_index, chromo_index, 2* effect_size, effect_size,   0)
add.effects[direction==TRUE,3:5] <- cbind(0, effect_size, 2*effect_size)
population$info$real.bv.add[[active_trait]] <- rbind(population$info$real.bv.add[[active_trait]], add.effects)
population$info$bv.calculated <- FALSE
if(subpop==1){
population <- breeding.diploid(population)
population$info$bv.calculated <- FALSE
}
}
}
}
}
}
population <- breeding.diploid(population)
get.bv(population, gen=1)
rowMeans(get.bv(population, gen=1)[,1:10]
)
rowMeans(get.bv(population, gen=1)[,11:20]
)
population <- NULL
population <- creating.diploid(dataset = dataset, nindi=length(sex.s),
sex.s = sex.s, genotyped.s = genotyped.s,
chromosome.length = chromo.length,
snps.equidistant = if(is.na(map[1,4])) {TRUE} else {FALSE}, miraculix = miraculix,
miraculix.dataset = miraculix.dataset,
chr.nr = map[,1], bp=map[,3], snp.name = map[,2],
freq = map[,5], snp.position = if(is.na(map[1,4])) {NULL} else {map[,4]})
# Cohort names
gender_founder <- numeric(length(founder))
nr <- 1
for(index in 1:length(founder)){
gender_founder[index] <- sex.s[nr]
nr <- nr + position[founder[index],4]
}
founder_temp <- founder[sort(gender_founder,index.return=TRUE)$ix]
cohort_info <- cbind(ids[founder_temp], 1, position[founder_temp,4], position[founder_temp,4], position[founder_temp,3], 1+cumsum(c(0,position[founder_temp,4]))[-(length(founder_temp)+1)], 1+cumsum(c(0,position[founder_temp,4]))[-(length(founder_temp)+1)] - sum(sex.s==1),
earliest_time[founder_temp], 0)
cohort_info[(cohort_info[,7]>=1),c(3,6)] <- 0
cohort_info[(cohort_info[,7]<1),c(4,7)] <- 0
population$info$cohorts <- cohort_info
colnames(population$info$cohorts) <- c("name","generation", "male individuals", "female individuals", "class", "position first male", "position first female",
"time point", "creating.type")
population <- creating.trait(population, n.additive = as.numeric(trait_matrix[,6]),
shuffle.cor = cor_gen, new.phenotype.correlation = cor_pheno,
shuffle.traits=1:n_traits,
trait.name = trait_matrix[,1])
# Correct Scaling
snp.before <- cumsum(c(0,population$info$snp))
## REASON?!
if(TRUE){
for(index in 1:n_traits){
if(length(population$info$real.bv.add[[index]])>0){
t <- population$info$real.bv.add[[index]]
take <- sort(t[,1]+ snp.before[t[,2]], index.return=TRUE)
t <- t[take$ix,,drop=FALSE]
take <- sort(t[,1]+ t[,2] * 10^10)
keep <- c(0,which(diff(take)!=0), length(take))
if(length(keep) <= nrow(t)){
for(index2 in 2:(length(keep))){
t[keep[index2],3:5] <- colSums(t[(keep[index2-1]+1):keep[index2],3:5, drop=FALSE])
}
population$info$real.bv.add[[index]] <- t[keep,]
}
}
}
}
## Variance Standardization
for(index in 1:n_traits){
new_var <- as.numeric(trait_matrix[index,4])^2
if(population$info$bv.calculated==FALSE){
population <- breeding.diploid(population)
}
active_sub <- subpopulation_info[1,1]
standard_cohort <- population$info$cohorts[which(founder_pop==active_sub),1]
var_test <- stats::var(get.bv(population, cohorts= standard_cohort)[index,])
if(length(population$info$real.bv.add[[index]])>0){
population$info$real.bv.add[[index]][,3:5] <- population$info$real.bv.add[[index]][,3:5] * sqrt(  new_var / var_test)
} else{
cat("You entered a trait without quantitative loci. Is this intentional?\n")
}
}
population$info$bv.calculated <- FALSE
## Mean Standardization
for(index in 1:n_traits){
if(population$info$bv.calculated==FALSE){
population <- breeding.diploid(population)
}
active_sub <- subpopulation_info[1,1]
standard_cohort <- population$info$cohorts[which(founder_pop==active_sub),1]
mean_test <- mean(get.bv(population, cohorts= standard_cohort)[index,])
population$info$base.bv[index] <- traitmean[index] + population$info$base.bv[index] - mean_test
}
population$info$bv.calculated <- FALSE
population <- breeding.diploid(population)
get.bv(population, gen=1)
rowMeans(get.bv(population, gen=1)[,1:10])
rowMeans(get.bv(population, gen=1)[,11:20])
active_sub
active_sub
if(population$info$bv.calculated==FALSE){
population <- breeding.diploid(population)
}
active_sub <- subpopulation_info[1,1]
standard_cohort <- population$info$cohorts[which(founder_pop==active_sub),1]
mean_test <- mean(get.bv(population, cohorts= standard_cohort)[index,])
mean_test
index <- 1
if(population$info$bv.calculated==FALSE){
population <- breeding.diploid(population)
}
active_sub <- subpopulation_info[1,1]
standard_cohort <- population$info$cohorts[which(founder_pop==active_sub),1]
mean_test <- mean(get.bv(population, cohorts= standard_cohort)[index,])
mean_test
standard_cohort
founder_pop
active_sub
population$info$cohorts
founder_pop
active_sub
founder_pop
founder_pop
founder
founder_pop
subpopulation_info
founder_pop
active_sub
founder_temp
founder_pop
founder_temp
founder_pop
