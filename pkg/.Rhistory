link <- rbind(link, c(ori, desti))
link2 <- unique(c(link2, index2))
}
} else{
if(sum(ori==step)>0){
step <- unique(c(step, desti))
#if(incoming_repeat_node[desti]==1 && length(intersect(founder,desti))>0){
#  step_vali <- unique(c(step_vali, desti))
#} else
#if(incoming_repeat_node[desti]==1 || length(intersect(step_vali,ori))>0){
#  step_vali <- unique(c(step_vali, desti))
#  edges_to_repeat <- unique(c(edges_to_repeat, index2))
#}
if(incoming_repeat_node[desti]==1 || length(intersect(step_vali,ori))>0){
step_vali <- unique(c(step_vali, desti))
}
}
}
}
}
}
nodes_to_repeat <- step_vali[!duplicated(c(start, step_vali))[-(1:length(start))]]
nodes_to_repeat <- sort(nodes_to_repeat)
n_rep <- 0
for(index in 1:length(edges)){
if(sum(edges[[index]]$to==ids[nodes_to_repeat])>0 && edges[[index]]$`Breeding Type`!="Repeat"){
edges_to_repeat <- c(edges_to_repeat, index)
}
if(sum(edges[[index]]$from==ids[nodes_to_repeat]) && edges[[index]]$`Breeding Type`=="Repeat"){
n_rep <- as.numeric(edges[[index]]$`Number of Repeat`)
}
}
#    edges_to_repeat <- sort(edges_to_repeat)
link <- unique(link)
#    for(index4 in start){
#      edges[[index4]]$'Breeding Type' <- "PerformedRepeat"
#    }
for(index4 in 1:n_rep){
for(nodrep in nodes_to_repeat){
nodes[[length(nodes)+1]] <- nodes[[nodrep]]
nodes[[length(nodes)]]$Founder <- "No"
nodes[[length(nodes)]]$id <- paste0(nodes[[length(nodes)]]$id, "_",index4)
nodes[[length(nodes)]]$label <- paste0(nodes[[length(nodes)]]$label, "_",index4)
}
for(edgesrep in edges_to_repeat){
edges[[length(edges)+1]] <- edges[[edgesrep]]
test <- ids[start]==edges[[length(edges)]]$from
if(sum(edges[[edgesrep]]$from==ids[step_vali])==0){
cat(paste0("Repeat from edge not included in the repeat: ", edges[[edgesrep]]$from, "\n"))
} else if(sum(test)){
take <- link[which(link[,2]==start[which(test)]),1]
if(index4==1){
edges[[length(edges)]]$from <- paste0(ids[take])
} else{
edges[[length(edges)]]$from <- paste0(ids[take],"_", index4-1)
}
} else{
edges[[length(edges)]]$from <- paste0(edges[[length(edges)]]$from,"_", index4)
}
edges[[length(edges)]]$to <- paste0(edges[[length(edges)]]$to,"_", index4)
edges[[length(edges)]]$id <- paste0(edges[[length(edges)]]$id,"_", index4)
}
}
for(sonstcheck in (1:length(ids))[-step_vali]){
for(edgeindex in 1:length(edges)){
if(edges[[edgeindex]]$to==ids[sonstcheck] && sum(edges[[edgeindex]]$from==ids[nodes_to_repeat])>0){
edges[[edgeindex]]$from <- paste0(edges[[edgeindex]]$from, "_", n_rep)
}
}
}
for(index in 1:length(edges)){
if(edges[[index]]$`Breeding Type`=="Repeat" && sum(ids[step_vali]==edges[[index]]$to)>0){
edges[[index]]$to <- paste0(edges[[index]]$to, "_", n_rep)
}
}
for(index in 1:nrow(link)){
cat(paste0("Successful repeat for ", ids[link[index,1]] ," to ",ids[link[index,2]],"\n" ))
}
cat(paste0(length(nodes)-n_nodes, " Nodes & ", length(edges) - n_edges, " Edges were added to generation script.\n"))
ids <- earliest_time <- numeric(length(nodes))
founder <- NULL
for(index5 in 1:length(nodes)){
if(nodes[[index5]]$Founder=="Yes"){
founder <- c(founder,index5)
}
ids[index5] <- nodes[[index5]]$id
earliest_time[index5] <- nodes[[index5]]$earliest_time
}
for(changeto in sort(link2, decreasing = TRUE)){
edges[[changeto]] <- NULL
}
repeat_node <- incoming_repeat_node <- numeric(length(nodes))
for(index in 1:length(edges)){
if(edges[[index]]$'Breeding Type'=="Repeat"){
repeat_node[which(edges[[index]]$from==ids)] <- 1
incoming_repeat_node[which(edges[[index]]$to==ids)] <- 1
}
}
}
## Determine genetic architecture
if(geninfo$'Use Ensembl Map'=="Yes"){
if(geninfo$'`Ensembl Filter Values`'=="Axiom Genotyping Array"){
map <- map_pig1
} else if(geninfo$'`Ensembl Filter Values`'=="GGP Porcine HD"){
map <- map_pig2
} else if(geninfo$'`Ensembl Filter Values`'=="GGP Porcine LD"){
map <- map_pig3
} else if(geninfo$'`Ensembl Filter Values`'=="Illumina_PorcineSNP60"){
map <- map_pig4
} else if(geninfo$'`Ensembl Filter Values`'=="Affymetrix Chicken600K Array"){
map <- map_chicken1
} else if(geninfo$'`Ensembl Filter Values`'=="Illumina BovineSNP50 BeadChip"){
map <- map_cattle1
} else if(geninfo$'`Ensembl Filter Values`'=="Illumina BovineHD BeadChip"){
map <- map_cattle2
} else if(geninfo$'`Ensembl Filter Values`'=="Illumina BovineLD BeadChip"){
map <- map_cattle3
}else if(geninfo$'`Ensembl Filter Values`'=="Genotyping chip variations"){
map <- map_cattle4
}else if(geninfo$'`Ensembl Filter Values`'=="Illumina EquineSNP50 BeadChip"){
map <- map_horse1
}else if(geninfo$'`Ensembl Filter Values`'=="IlluminaOvineHDSNP"){
map <- map_sheep1
}else if(geninfo$'`Ensembl Filter Values`'=="IlluminaOvineSNP50"){
map <- map_sheep2
} else if(geninfo$'`Ensembl Filter Values`'=="Genotyping chip variants"){
map <- map_sheep3
} else if(geninfo$'`Ensembl Filter Values`'=="Illumina_GoatSNP50"){
map <- map_goat1
} else if(geninfo$'`Ensembl Filter Values`'=="Affy GeneChip500K"){
map <- map_human1
} else if(geninfo$'`Ensembl Filter Values`'=="Illumina_1M-duo"){
map <- map_human2
} else if(geninfo$'`Ensembl Filter Values`'== "Illumina_HumanHap550"){
map <- map_human3
} else if(geninfo$'`Ensembl Filter Values`'== "Affymetrix Axiom Maize Array"){
map <- map_maize1
} else{
map <- ensembl.map(dataset = geninfo$'Ensembl Dataset',
filter = geninfo$'Ensembl Filter',
filter.values = geninfo$'Ensembl Filter Values')
}
if(length(geninfo$'Max Number of SNPs')>0 && as.numeric(geninfo$'Max Number of SNPs')<nrow(map)){
map <- map[sort(sample(1:nrow(map), as.numeric(geninfo$'Max Number of SNPs'))),]
}
nchromo <- max(as.numeric(map[,1]))
nsnp <- chromo.length <- numeric(nchromo)
for(index in 1:nchromo){
nsnp[index] <- sum(map[,1]==index)
chromo.length[index] <- max(as.numeric(map[map[,1]==index,3])) / 100000000
}
cat("Assume 100.000.000 bp/M in Ensembl Map \n")
} else if(geninfo$'Use Own Map'=="Yes" || length(map)>0){
map_path <- geninfo$`Own Map Path`
if(length(map_path)>0){
map_type <- substr(map_path, start= nchar(map_path)-2, stop= nchar(map_path))
if(map_type=="vcf"){
cat("Map identified as vcf-file - extract map information")
if(requireNamespace("vcfR", quietly = TRUE)){
vcf_file <- vcfR::read.vcfR(map_path)
map <- cbind(vcf_file@fix[,c(1,3,2)],NA,NA)
} else{
stop("Map-import failed! vcfR-package not available! \n")
}
} else if(map_type=="map"){
cat("Map identified as Ped-map-file - extract map information")
map_file <- utils::read.table(map_path)
map <- cbind(map_file[,c(1,2,4)], NA,NA)
} else if(map_type=="ata"){
map_store <- load(map_path)
if(length(map_store)>1){
cat("More than one object contain in .Rdata - unless the map is named 'map' import will fail! \n")
} else{
map <- eval(parse(text=map_store[[1]]))
}
}
}
nchromo <- max(as.numeric(map[,1]))
nsnp <- chromo.length <- numeric(nchromo)
for(index in 1:nchromo){
nsnp[index] <- sum(map[,1]==index)
chromo.length[index] <- max(as.numeric(map[map[,1]==index,3])) / 100000000
}
cat("Assume 100.000.000 bp/M in Imported Map \n")
} else if(geninfo$'Chromosomes of Equal Length'=="Yes"){
nchromo <- as.numeric(geninfo$'Number of Chromosomes')
nsnp <- ceiling(rep(as.numeric(geninfo$'Chromosomes Info'[[1]]$Length) * as.numeric(geninfo$'Chromosomes Info'[[1]]$MD), nchromo))
chromo.length <- rep(as.numeric(geninfo$'Chromosomes Info'[[1]]$Length) * as.numeric(geninfo$'Chromosomes Info'[[1]]$Recombination, nchromo) /100, nchromo)
bp <- ceiling((0.5:nsnp[1]) / nsnp[1] * as.numeric(geninfo$'Chromosomes Info'[[1]]$Length) * 1000000)
} else{
nchromo <- as.numeric(geninfo$'Number of Chromosomes')
chromo.length <- nsnp <- numeric(nchromo)
bp <- numeric(sum(nsnp))
prev <- 0
for(index in 1:nchromo){
nsnp[index] <- ceiling(as.numeric(geninfo$'Chromosomes Info'[[index]]$Length) * as.numeric(geninfo$'Chromosomes Info'[[index]]$MD))
chromo.length[index] <- as.numeric(geninfo$'Chromosomes Info'[[index]]$Length) * as.numeric(geninfo$'Chromosomes Info'[[index]]$Recombination, nchromo) /100
bp[(1:nsnp[index])+prev] <- ceiling((0.5:nsnp[index]) / nsnp[index] * as.numeric(geninfo$'Chromosomes Info'[[index]]$Length) * 1000000)
prev <- prev + nsnp[index]
}
}
if(length(map)==0){
for(index in 1:nchromo){
map <- rbind(map, cbind(index, paste0("SNP", 1:nsnp[index]), NA, NA, NA))
}
if(length(bp)>0){
map[,3] <- bp
} else{
cat("Why is there no base-pair in auto generated map?")
}
}
if(n_traits>0){
trait_matrix <- matrix(0, nrow=n_traits, ncol=8)
for(index in 1:n_traits){
trait_matrix[index,] <- unlist(traitinfo[[index]])[1:8]
}
# derive genetic variance based on total variance
trait_matrix[,4] <- as.numeric(trait_matrix[,4]) * sqrt(as.numeric(trait_matrix[,5]))
#traitmean <- as.numeric(c(geninfo[[1]]$MilkYield_Mean, geninfo[[1]]$NonReturnRate_Mean, geninfo[[1]]$SomaticCellScore_Mean))
traitmean <- as.numeric(trait_matrix[,3])
trait_weigths <- as.numeric(trait_matrix[,8])
#heritability <- as.numeric(c(geninfo[[1]]$MilkYield_Hertit, geninfo[[1]]$NonReturnRate_Hertit, geninfo[[1]]$SomaticCellScore_Hertit))
heritability <- as.numeric(trait_matrix[,5])
if(sum(is.na(heritability))>0){
cat("No heritability entered - set heritability to 0.5 for all those traits\n")
heritability[is.na(heritability)]==0
}
} else{
heritability <- NULL
}
groups <- length(nodes)
# Species not needed, traitvariance not needed,
position <- matrix(0, nrow=length(nodes), ncol=4)
rownames(position) <- ids
founding_a <- c(0,0)
mig_m <- numeric(0)
mig_f <- numeric(0)
sex.s <- NULL
# CHECK FOR ME THAN 2 FOUNDERS (MORE THAN 1 of a sex- Migration level...)
new_mig <- c(0,0)
founder_data <- FALSE
for(index in 1:length(founder)){
sex <- as.numeric(nodes[[founder[index]]]$'Sex'=="Female")+1
size <- as.numeric(nodes[[founder[index]]]$'Number of Individuals')
founding_a[sex] <- founding_a[sex] + size
sex.s <- c(sex.s, rep(sex, size))
if(sex==1){
mig_m <- c(mig_m, rep(new_mig[1], size))
mig <- new_mig[1]
new_mig[1] <- new_mig[1] + 1
}
if(sex==2){
mig_f <- c(mig_f, rep(new_mig[2], size))
mig <- new_mig[2]
new_mig[2] <- new_mig[2] + 1
}
position[founder[index],] <- c(1, sex, mig, size)
if(length(nodes[[founder[index]]]$Path)>0 && nchar(nodes[[founder[index]]]$Path)>0){
founder_data <- TRUE
}
}
}
################### Import genetic data #############################
{
dataset <- "random"
if(founder_data){
dataset <- matrix(0L, nrow= sum(nsnp), ncol = sum(position[,4])*2)
path_list <- NULL
no_data <- numeric(length(founder))
for(index in 1:length(founder)){
path_list <- c(path_list, nodes[[founder[index]]]$Path )
}
starts <- cumsum(c(1, position[founder,4]))*2-1
for(path in unique(c("",path_list))[-1]){
data_path <- path
if(length(data_path)>0){
data_type <- substr(data_path, start= nchar(data_path)-2, stop= nchar(data_path))
if(data_path=="vcf"){
cat("Data input identified as vcf-file - extract genomic information \n")
if(requireNamespace("vcfR", quietly = TRUE)){
vcf_file <- vcfR::read.vcfR(data_path)
haplo1 <- substr(vcf_file@gt[,-1], start=1, stop=1)
haplo2 <- substr(vcf_file@gt[,-1], start=3, stop=3)
haplo <- cbind(haplo1, haplo2)
haplo <- haplo[,c(0,ncol(haplo1)) + rep(1:ncol(haplo1), each=2)]
} else{
stop("Data-import failed! vcfR-package not available! \n")
}
} else if(data_type=="ped"){
cat("Data input identified as Ped-map-file - extract genomic information \n")
cat("Haplotype phase is assumed to be by colum - No internal phasing performed! \n")
ped_file <- utils::read.table(data_path)
haplo12 <- t(ped_file[,-(1:6)])
haplo <- matrix(0, ncol = ncol(haplo12)*2, nrow=nrow(haplo12)/2)
for(index1 in 1:(nrow(haplo12)/2)){
haplo[,index1*2+c(-1,0)] <- matrix(haplo12[,index1], ncol=2, byrow=TRUE)
}
} else if(data_type=="ata"){
Map <- map ## Lisas subpos contain a element named map"
data_store <- load(data_path)
map <- Map
if(length(data_store)>1){
cat("More than one object contain in .Rdata - unless the data object is named 'haplo' import will fail! \n")
} else{
haplo <- eval(parse(text=map_store[[1]]))
}
}
}
takes <- which(path_list==path)
no_data[takes] <- 1
take <- NULL
for(index in takes){
take <- c(take, starts[index]:(starts[index+1]-1))
}
if(nrow(haplo)!=sum(nsnp)){
nsnp <- floor(nsnp*nrow(haplo)/sum(nsnp))
nsnp[1] <- nsnp[1] + nrow(haplo)-sum(nsnp)
dataset <- matrix(0L, nrow= sum(nsnp), ncol = sum(position[,4])*2)
map <- NULL
for(index in 1:nchromo){
map <- rbind(map, cbind(index, paste0("SNP", 1:nsnp[index]), NA, NA, NA))
}
}
if(length(haplo) != length(dataset[,take])){
cat("Size of Founder-dataset not in concorance with node size!\n")
haplo <- rep(haplo, length.out=length(dataset[,take]))
}
dataset[,take] <- haplo
}
if(sum(no_data==0)>0){
takes <- which(no_data==0)
take <- NULL
for(index in takes){
take <- c(take, starts[index]:(starts[index+1]-1))
}
if(miraculix){
p_i <- miraculix::allele_freq(miraculix::createSNPmatrix(dataset[,-takes]))*2
} else{
p_i <- rowMeans(dataset[,-takes])
}
if(sum(!is.na(map[,5]))){
cat("Replace allele-freq in dataset generation with Map allele freqs \n")
p_i[!is.na(map[,5])] <- map[!is.na(map[,5]),5]
}
dataset[,take] <- stats::rbinom(nrow(dataset)*length(take),1, prob=p_i)
} else{
if(miraculix){
p_i <- miraculix::allele_freq(miraculix::createSNPmatrix(dataset))*2
} else{
p_i <- rowMeans(dataset[,-takes])
}
}
}
if((n_traits)>0){
for(index in 1:n_traits){
major[[index]] <- traitinfo[[index]]$'Trait QTL Info'
if(length(major[[index]])>0 && length(major[[index]][[1]])>1){
ncols <- length(major[[index]][[1]])
mqtl <- matrix(unlist(major[[index]]), ncol=ncols, byrow=TRUE)
to_enter <- mqtl[,c(1,4:8), drop=FALSE]
storage.mode(to_enter) <- "numeric"
if(sum(is.na(to_enter[,2]))>0){
to_enter[is.na(to_enter[,2]),2] <- 1
cat("Illegal Chromosom-name. Simulate major SNP-effect on chromosome 1")
}
if(sum(is.na(to_enter[,1]))>0){
for(sample_index in which(is.na(to_enter[,1]))){
to_enter[sample_index,1] <- sample(1:nsnp[to_enter[sample_index,2]],1)
cat(paste0("Illegal SNP-name. Simulate major SNP-effect on SNP ", to_enter[sample_index,1],"\n"))
}
}
to_enter[to_enter[,6]=="",6] <- NA
major_table[[index]] <- to_enter
}
}
}
if(length(major_table)>0){
for(index in 1:length(major_table)){
if(length(major_table[[index]])>0){
for(index2 in 1:nrow(major_table[[index]])){
take <- which(cumsum((map[,1]==major_table[[index]][index2,2]))==major_table[[index]][index2,1])[1]
map[take,5] <- major_table[[index]][index2,6]
}
}
}
}
}
mqtl
map
take_qtl <- which(to_enter[sample_index,2] == map[,2])
take_qtl
to_enter[sample_index, c(1,2)]
to_enter
to_enter[sample_index,7]
to_enter <- mqtl[,c(1,4:8,2,3), drop=FALSE]
to_enter
to_enter[sample_index,7]
map[take_qtl[1], 1]
take_qtl
map
which(map[,1]==to_enter[sample_index,2])
to_enter[sample_index,8]
diff_to <- abs(as.numeric(map[,3]) - as.numeric(to_enter[sample_index,8]))
diff_to
plot(diff_to)
abs(as.numeric(map[,3])
as.numeric(map[,3])
as.numeric(to_enter[sample_index,8])
diff_to <- - abs(as.numeric(map[,3]) - as.numeric(to_enter[sample_index,8]))
diff_to
diff_to[map[,1]!=to_enter[sample_index,2]] <- -Inf
plot(diff_to)
which.max(diff_to)
to_enter_name <- mqtl[,c(2,3), drop=FALSE]
to_enter_name
!is.na(as.numeric(to_enter_name[sample_index,2]))
to_enter_name
as.numeric(to_enter_name[sample_index,2])
diff_to <- - abs(as.numeric(map[,3]) - as.numeric(to_enter_name[sample_index,2]))
diff_to[map[,1]!=to_enter[sample_index,2]] <- -Inf
take_qtl <- which.max(diff_to)
take_qtl
to_enter[sample_index, 2] <- as.numeric(map[take_qtl[1], 1])
as.numeric(map[take_qtl[1], 1])
sum(map[1:take_qtl[1], 1] == map[take_qtl[1], 1])
nsnp
if((n_traits)>0){
for(index in 1:n_traits){
major[[index]] <- traitinfo[[index]]$'Trait QTL Info'
if(length(major[[index]])>0 && length(major[[index]][[1]])>1){
ncols <- length(major[[index]][[1]])
mqtl <- matrix(unlist(major[[index]]), ncol=ncols, byrow=TRUE)
to_enter <- mqtl[,c(1,4:8), drop=FALSE]
to_enter_name <- mqtl[,c(2,3), drop=FALSE]
storage.mode(to_enter) <- "numeric"
if(sum(is.na(to_enter[,2]))>0 || sum(is.na(to_enter[,1]))>0){
check_qtl <- unique(c(which(is.na(to_enter[,1])), which(is.na(to_enter[,2]))))
for(sample_index in 1:check_qtl){
take_qtl <- which(to_enter_name[sample_index,1] == map[,2])
if(length(take_qtl)>0){
to_enter[sample_index, 2] <- as.numeric(map[take_qtl[1], 1])
to_enter[sample_index, 1] <- sum(map[1:take_qtl[1], 1] == map[take_qtl[1], 1])
cat("SNP-position assigned via SNP-name\n")
} else{
if(is.na(to_enter[sample_index,2])){
to_enter[sample_index,2] <- 1
cat("Illegal Chromosom-name. Simulate major SNP-effect on chromosome 1")
}
if(!is.na(as.numeric(to_enter_name[sample_index,2]))){
diff_to <- - abs(as.numeric(map[,3]) - as.numeric(to_enter_name[sample_index,2]))
diff_to[map[,1]!=to_enter[sample_index,2]] <- -Inf
take_qtl <- which.max(diff_to)
to_enter[sample_index, 2] <- as.numeric(map[take_qtl[1], 1])
to_enter[sample_index, 1] <- sum(map[1:take_qtl[1], 1] == map[take_qtl[1], 1])
cat("SNP-position assigned via bp position\n")
} else{
to_enter[sample_index,1] <- sample(1:nsnp[to_enter[sample_index,2]],1)
cat(paste0("Illegal SNP-name/bp/position. SNP-effect generated on SNP ", to_enter[sample_index,1],"\n"))
}
}
}
}
to_enter[to_enter[,6]=="",6] <- NA
major_table[[index]] <- to_enter
}
}
}
to_enter
check_qtl
if((n_traits)>0){
for(index in 1:n_traits){
major[[index]] <- traitinfo[[index]]$'Trait QTL Info'
if(length(major[[index]])>0 && length(major[[index]][[1]])>1){
ncols <- length(major[[index]][[1]])
mqtl <- matrix(unlist(major[[index]]), ncol=ncols, byrow=TRUE)
to_enter <- mqtl[,c(1,4:8), drop=FALSE]
to_enter_name <- mqtl[,c(2,3), drop=FALSE]
storage.mode(to_enter) <- "numeric"
if(sum(is.na(to_enter[,2]))>0 || sum(is.na(to_enter[,1]))>0){
check_qtl <- unique(c(which(is.na(to_enter[,1])), which(is.na(to_enter[,2]))))
for(sample_index in check_qtl){
take_qtl <- which(to_enter_name[sample_index,1] == map[,2])
if(length(take_qtl)>0){
to_enter[sample_index, 2] <- as.numeric(map[take_qtl[1], 1])
to_enter[sample_index, 1] <- sum(map[1:take_qtl[1], 1] == map[take_qtl[1], 1])
cat("SNP-position assigned via SNP-name\n")
} else{
if(is.na(to_enter[sample_index,2])){
to_enter[sample_index,2] <- 1
cat("Illegal Chromosom-name. Simulate major SNP-effect on chromosome 1")
}
if(!is.na(as.numeric(to_enter_name[sample_index,2]))){
diff_to <- - abs(as.numeric(map[,3]) - as.numeric(to_enter_name[sample_index,2]))
diff_to[map[,1]!=to_enter[sample_index,2]] <- -Inf
take_qtl <- which.max(diff_to)
to_enter[sample_index, 2] <- as.numeric(map[take_qtl[1], 1])
to_enter[sample_index, 1] <- sum(map[1:take_qtl[1], 1] == map[take_qtl[1], 1])
cat("SNP-position assigned via bp position\n")
} else{
to_enter[sample_index,1] <- sample(1:nsnp[to_enter[sample_index,2]],1)
cat(paste0("Illegal SNP-name/bp/position. SNP-effect generated on SNP ", to_enter[sample_index,1],"\n"))
}
}
}
}
to_enter[to_enter[,6]=="",6] <- NA
major_table[[index]] <- to_enter
}
}
}
to_enter
a <- devtools::check()
