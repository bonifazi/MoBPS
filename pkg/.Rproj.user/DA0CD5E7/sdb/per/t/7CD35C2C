{
    "collab_server" : "",
    "contents" : "'#\n  Authors\nTorsten Pook, torsten.pook@uni-goettingen.de\n\nCopyright (C) 2017 -- 2018  Torsten Pook\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 3\nof the License, or (at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n'#\n\n\n#' Breeding function\n#'\n#' Function to simulate a step in a breeding scheme\n#' @param population Population list\n#' @param mutation.rate Mutation rate in each marker (default: 10^-5)\n#' @param remutation.rate Remutation rate in each marker (default: 10^-5)\n#' @param recombination.rate Average number of recombination per 1 length unit (default: 1M)\n#' @param selection.m Selection criteria for male individuals (default: \"random\", alt: \"function\")\n#' @param selection.w Selection criteria for female individuals (default: selection.m , alt: \"random\", function\")\n#' @param selection.function.matrix Manuel generation of a temporary selection function (Use BVs instead!)\n#' @param selection.size Number of selected individuals for breeding (default: c(0,0) - alt: positive numbers)\n#' @param breeding.size Number of individuals to generate\n#' @param breeding.gender Share of female animals (if single value is used for breeding size; default: 0.5)\n#' @param breeding.gender.random If TRUE randomly chose gender of new individuals (default: FALSE - use expected values)\n#' @param used.generations.m Share of best male individuals chosen from each generation (default: c(0,...,0,1) - only last generation)\n#' @param used.generations.w Share of best female individuals chosen from each generation (default: used.generations.m - only last generation)#'\n#' @param relative.selection Use best.selection.ratio instead!\n#' @param recom.f.indicator Use step function for recombination map (transform snp.positions if possible instead)\n#' @param add.gen New animals are generated in the next generation (default: length(population$breeding))\n#' @param recom.f.polynom Polynomical function to determine expected number of recombinations (transform snp.positions if possible instead)\n#' @param duplication.rate Share of recombination points with a duplication (default: 0 - DEACTIVATED)\n#' @param duplication.length Average length of a duplication (Exponentially distributed)\n#' @param duplication.recombination Average number of recombinations per 1 length uit of duplication (default: 1)\n#' @param new.migration.level Migration level of newly generated individuals (default: 0)\n#' @param bve If TRUE perform a breeding value estimation (default: FALSE)\n#' @param bve.database Groups of individuals to consider in breeding value estimation (default: NULL)\n#' @param bve.database.insert Groups of individuals to compute breeding values for (default: all groups in bve.database)\n#' @param sigma.e Enviromental variance (default: 100)\n#' @param heritability Use sigma.e to obtain a certain heritability (default: NULL)\n#' @param sigma.e.database Groups to consider when estimating sigma.e when using hertability\n#' @param sigma.s Genetic variance (default: 100 - only used if not computed via estimate.sigma.sSigma_s^2 in der Zuchtwertschaetzung (Default: 100)\n#' @param forecast.sigma.s Set FALSE to not estimate sigma.s (Default: TRUE)\n#' @param new.bv.observation Vector of all generation for which breeding values are observed (alt: \"all\" for all & \"non_obs\" for all non-observed individuals)\n#' @param new.bv.child Starting phenotypes of newly generated individuals (default: \"mean\" of both parents, \"obs\" - regular observation, \"zero\" - 0)\n#' @param computation.A Method to calculate pedigree matrix (Default: \"vanRaden\", alt: \"kinship\", \"CE\", \"non_stand\", \"CE2\", \"CM\")\n#' @param delete.haplotypes Generations for with haplotypes of founders can be deleted (only use if storage problem!)\n#' @param delete.individuals Generations for with individuals are completley deleted (only use if storage problem!)\n#' @param praeimplantation Only use matings the lead to a specific genotype in a specific marker\n#' @param new.phenotype.correlation Correlation of the simulated enviromental variance\n#' @param new.breeding.correlation Correlation of the simulated genetic variance (child share! heritage is not influenced!)\n#' @param best1.from.group Groups of individuals to consider as First Parent / Father (also female individuals are possible)\n#' @param best2.from.group Groups of individuals to consider as Second Parent / Mother (also male individuals are possible)\n#' @param fixed.breeding Set of targeted matings to perform\n#' @param fixed.breeding.best Perform targeted matings in the group of selected individuals\n#' @param max.offspring Maximum number of offspring per individual (default: c(Inf,Inf) - (m,w))\n#' @param store.breeding.totals If TRUE store information on selected animals in $info$breeding.totals\n#' @param multiple.bve Way to handle multiple traits in bv/selection (default: \"add\", alt: \"ranking\")\n#' @param multiple.bve.weights Weighting between traits when using \"add\" (default: 1)\n#' @param store.bve.data If TRUE store information of bve in $info$bve.data\n#' @param fixed.assignment Set TRUE for targeted mating of best-best individual till worst-worst (of selected). set to \"bestworst\" for best-worst mating\n#' @param reduce.group Groups of animals for reduce to a new size (by changing migration level to 187)\n#' @param reduce.group.selection Selection criteria for reduction of groups (cf. selection.m / selection.w - default: \"random\")\n#' @param selection.critera If 0 individuals with lowest bve are selected as best individuals (default c(1,1) - (m,w))\n#' @param same.sex.activ If TRUE allow matings of individuals of same sex\n#' @param same.sex.gender Probability to use female individuals as parents (default: 0.5)\n#' @param same.sex.selfing If FALSE no matings between an individual with itself\n#' @param selfing.mating If TRUE generate new individuals via selfing\n#' @param selfing.gender Share of female individuals used for selfing (default: 0.5)\n#' @param multiple.bve.scale If TRUE standardize breeding values for traits according to their standard deviation\n#' @param use.last.sigma.e If TRUE use the sigma.e used in the previous simulation (default: FALSE)\n#' @param migration.level.m Migrationlevels of male individuals to consider for mating process (default: 0)\n#' @param migration.level.w Migrationlevels of female individuals to consider for mating process (default: 0)\n#' @param save.recombination.history If TRUE store the time point of each recombination event\n#' @param martini.selection If TRUE use the group of non-selected individuals as second parent\n#' @param BGLR.bve If TRUE use BGLR to perform breeding value estimation\n#' @param BGLR.burnin Number of burn-in steps in BGLR (default: 1000)\n#' @param BGLR.iteration Number of iterations in BGLR (default: 5000)\n#' @param BGLR.print If TRUE set verbose to TRUE in BGLR\n#' @param BGLR.save Method to use in BGLR (default: \"RKHS\" - alt: NON currently)\n#' @param BGLR.save.random Add random number to store location of internal BGLR computations (only needed when simulating a lot in parallel!)\n#' @param copy.animal If TRUE copy the selected father for a mating\n#' @param dh.mating If TRUE generate a DH-line in mating process\n#' @param dh.gender Share of DH-lines generated from selected female individuals\n#' @param bve.childbase If TRUE determine breeding value based on breeding value of offspring\n#' @param bve.childbase.parents Groups of animals for which to generate breeding values\n#' @param bve.childbase.children Groups of animals to consider as childs\n#' @param n.observation Number of phenotypes generated per individuals (influences enviromental variance)\n#' @param bve.0isNA Individuals with phenotype 0 are used as NA in breeding value estimation\n#' @param phenotype.bv If TRUE use phenotype as estimated breeding value\n#' @param standardize.bv If TRUE standardize breeding value (additive transformation to mean standardize.bv.level)\n#' @param standardize.bv.level Level for the standardization (default: 100)\n#' @param standardize.bv.gen Generations to use in standardize.bv\n#' @param delete.same.ursprung If TRUE delete recombination points when genetic origin of adjacent segments is the same\n#' @param estimate.u If TRUE estimate u in breeding value estimation (Y = Xb + Zu + e)\n#' @param gwas.u If TRUE estimate u via GWAS (relevant for gene editing)\n#' @param approx.residuals If FALSE calculate the variance for each marker separatly instead of using a set variance (doesnt change order - only p-values)\n#' @param gwas.database Groups to consider in GWAS analysis\n#' @param gwas.group.standard If TRUE standardize phenotypes by group mean\n#' @param y.gwas.used What y value to use in GWAS study (Default: \"pheno\", alt: \"bv\", \"bve\")\n#' @param new.bv.observation.gender For which gender phenotypes are observed (Default: c(1,2))\n#' @param remove.effect.position If TRUE remove real QTLs in breeding value estimation\n#' @param estimate.add.gen.var If TRUE estimate additive genetic variance and heritability based on parent model\n#' @param estimate.pheno.var If TRUE estimate total variance in breeding value estimation\n#' @param store.comp.times If TRUE store computation times in $info$comp_times (default: TRUE)\n#' @param store.comp.times.bve If TRUE store computation times of breeding value estimation in $info$comp_times_bve (default: TRUE)\n#' @param store.comp.times.generation If TRUE store computation times of mating simulations in $info$comp_times_generation (default: TRUE)\n#' @param special.comb If TRUE selected individuals based on their special combining ability\n#' @param predict.effects If TRUE use estimated effects instead of true values in special.comb\n#' @param SNP.density Use every _ SNP in predict.effects (default: 10)\n#' @param use.effect.markers If TRUE use QTL markers in special.comb\n#' @param use.effect.combination If TRUE use QTL combinations (epistatic/mult) in special.comb\n#' @param max.auswahl Maximum amount of times a individuals is considered in special.comb\n#' @param ogc If TRUE use optimal genetic contribution theory to perform selection (Needs rework!)\n#' @param gene.editing If TRUE perform gene editing on selected individual\n#' @param gene.editing.offspring If TRUE perform gene editing on newly generated individuals\n#' @param gene.editing.best If TRUE perform gene editing on selected individuals\n#' @param gene.editing.offspring.gender Which gender to perform editing on (Default c(TRUE,TRUE), mw)\n#' @param gene.editing.best.gender Which gender to perform editing on (Default c(TRUE,TRUE), mw)\n#' @param nr.edits Number of edits to perform per individual\n#' @param import.position.calculation Function to calculate recombination point into adjacent/following SNP\n#' @param special.comb.add If TRUE select matings based on additive combining ability\n#' @param emmreml.bve If TRUE use REML estimator from R-package EMMREML in breeding value estimation\n#' @param sequenceZ Split genomic matric into parts (relevent if high memory usage)\n#' @param maxZ Number of SNPs to consider in each part of sequenceZ\n#' @param maxZtotal Number of matrix entries to consider jointly (maxZ = maxZtotal/number of animals)\n#' @param delete.gender Remove all individuals from these gender from generation delete.individuals (default: 1:2 ; note:delete individuals=NULL)\n#' @param gen.architecture.m Genetic architecture for male animal (default: 0 - no transformation)\n#' @param gen.architecture.w Genetic architecture for female animal (default: 0 - no transformation)\n#' @param add.architecture List with two vectors containing (A: length of chromosomes, B: position in cM of SNPs)\n#' @param ncore Cores used for parallel computing in compute.snps\n#' @param Z.integer If TRUE save Z as a integer in parallel computing\n#' @param store.effect.freq If TRUE store the allele frequency of effect markers perss generation\n#' @param backend Chose the used backend (default: \"doParallel\", alt: \"doMPI\")\n#' @param Rprof Store computation times of each function\n#' @param miraculix If TRUE use miraculix to perform computations (ideally already generate population in creating.diploid with this; default: automatic detection from population list)\n#' @param miraculix.mult If TRUE use miraculix for matrix multiplications even if miraculix is not used for storage\n#' @param miraculix.chol If TRUE perform Cholesky-decomposition implemented in miraculix (also works for semi-definite matrices)\n#' @param miraculix.cores Number of cores used in miraculix applications (default: 1)\n#' @param store.bve.parameter If TRUE storeA Zm Zmt Z.code Rest in $info$A $info$sigma.e $info$sigma.s $info$multi\n#' @param best.selection.ratio.m Ratio of the frequency of the selection of the best best animal and the worst best animal (default=1)\n#' @param best.selection.ratio.w Ratio of the frequency of the selection of the best best animal and the worst best animal (default=1)\n#' @param best.selection.criteria.m Criteria to calculate this ratio (default: \"bv\", alt: \"bve\", \"pheno\")\n#' @param best.selection.criteria.w Criteria to calculate this ratio (default: \"bv\", alt: \"bve\", \"pheno\")\n#' @param best.selection.manual.ratio.m vector containing probability to draw from for every individual (e.g. c(0.1,0.2,0.7))\n#' @param best.selection.manual.ratio.w vector containing probability to draw from for every individual (e.g. c(0.1,0.2,0.7))\n#' @param bve.migration Consider only animals of those migration classes in breeding value estimation (default: NULL - use all)\n#' @param parallel.generation Set TRUE to active parallel computing in animal generation\n#' @param ncore.generation Number of cores to use in parallel generation\n#' @param randomSeed Set random seed of the process\n#' @param randomSeed.generation Set random seed for parallel generation process\n#' @param new.selection.calculation If TRUE recalculate breeding values obtained by selection.function.matrix\n#' @param fast.compiler Use a just-in-time compiler from the compiler package (Default: 0, alt: 1,2,3)\n#' @param print.error.sources If TRUE print head of kinship matrix and selected animals\n#' @param name.cohort Name of the newly added cohort\n#' @export\n\nbreeding.diploid <- function(population,\n                             mutation.rate=10^-5,\n                             remutation.rate=10^-5,\n            recombination.rate=1,\n            selection.m=c(\"random\"),\n            selection.w=NULL,\n            new.selection.calculation= TRUE,\n            selection.function.matrix= NULL,\n            selection.size=c(0,0),\n            breeding.size=0,\n            breeding.gender=0.5,\n            breeding.gender.random=FALSE,\n            used.generations.m=1,\n            used.generations.w=NULL,\n            relative.selection=FALSE,\n            migration.level.m = 0,\n            migration.level.w = 0,\n            add.gen=0,\n            recom.f.indicator=NULL,\n            recom.f.polynom=NULL,\n            duplication.rate=0,\n            duplication.length=0.01,\n            duplication.recombination=1,\n            new.migration.level=0L,\n            bve=FALSE,\n            bve.database= NULL,\n            sigma.e = 100,\n            sigma.s = 100,\n            new.bv.observation = NULL,\n            new.bv.child=\"mean\",\n            computation.A=\"vanRaden\",\n            delete.haplotypes=NULL,\n            delete.individuals=NULL,\n            fixed.breeding=NULL,\n            fixed.breeding.best=NULL,\n            max.offspring=c(Inf,Inf),\n            store.breeding.totals=FALSE,\n            forecast.sigma.s=TRUE,\n            multiple.bve=\"add\",\n            multiple.bve.weights=c(1),\n            store.bve.data=FALSE,\n            fixed.assignment=FALSE,\n            reduce.group=NULL,\n            reduce.group.selection=\"random\",\n            selection.critera=c(TRUE,TRUE),\n            same.sex.activ=FALSE,\n            same.sex.gender=0.5,\n            same.sex.selfing=TRUE,\n            selfing.mating=FALSE,\n            selfing.gender=0.5,\n            praeimplantation=NULL,\n            sigma.e.database=NULL,\n            heritability=NULL,\n            multiple.bve.scale=FALSE,\n            use.last.sigma.e=FALSE,\n            save.recombination.history=FALSE,\n            martini.selection=FALSE,\n            BGLR.bve=FALSE,\n            BGLR.burnin=500,\n            BGLR.iteration=5000,\n            copy.animal=FALSE,\n            dh.mating=FALSE,\n            dh.gender=0.5,\n            bve.childbase=FALSE,\n            bve.childbase.parents=NULL,\n            bve.childbase.children=NULL,\n            n.observation=1,\n            bve.0isNA=TRUE,\n            phenotype.bv=FALSE,\n            standardize.bv=FALSE,\n            standardize.bv.level=100,\n            standardize.bv.gen=1,\n            delete.same.ursprung=FALSE,\n            remove.effect.position=FALSE,\n            estimate.u=FALSE,\n            BGLR.print=FALSE,\n            new.phenotype.correlation=NULL,\n            new.breeding.correlation=NULL,\n            estimate.add.gen.var=FALSE,\n            estimate.pheno.var=FALSE,\n            best1.from.group=NULL,\n            best2.from.group=NULL,\n            store.comp.times=TRUE,\n            store.comp.times.bve=TRUE,\n            store.comp.times.generation=TRUE,\n            special.comb=FALSE,\n            max.auswahl=Inf,\n            predict.effects=FALSE,\n            SNP.density=10,\n            use.effect.markers=FALSE,\n            use.effect.combination=FALSE,\n            import.position.calculation=NULL,\n            special.comb.add=FALSE,\n            BGLR.save=\"RKHS\",\n            BGLR.save.random=FALSE,\n            ogc=FALSE,\n            emmreml.bve=FALSE,\n            nr.edits=0,\n            gene.editing.offspring=FALSE,\n            gene.editing.best=FALSE,\n            gene.editing.offspring.gender=c(TRUE,TRUE),\n            gene.editing.best.gender=c(TRUE,TRUE),\n            gwas.u=FALSE,\n            approx.residuals=TRUE,\n            sequenceZ=FALSE,\n            maxZ=5000,\n            maxZtotal=0,\n            gwas.database=NULL,\n            delete.gender=1:2,\n            gwas.group.standard=FALSE,\n            new.bv.observation.gender=c(1,2),\n            y.gwas.used=\"pheno\",\n            gen.architecture.m=0,\n            gen.architecture.w=NULL,\n            add.architecture=NULL,\n            ncore=1,\n            ncore.generation=1,\n            Z.integer=FALSE,\n            store.effect.freq=FALSE,\n            backend=\"doParallel\",\n            randomSeed=NULL,\n            randomSeed.generation=NULL,\n            Rprof=FALSE,\n            miraculix=FALSE,\n            miraculix.mult=NULL,\n            fast.compiler=0,\n            miraculix.cores=1,\n            store.bve.parameter=FALSE,\n            print.error.sources=FALSE,\n            miraculix.chol=FALSE,\n            bve.database.insert=1,\n            best.selection.ratio.m=1,\n            best.selection.ratio.w=NULL,\n            best.selection.criteria.m=\"bv\",\n            best.selection.criteria.w=NULL,\n            best.selection.manual.ratio.m=NULL,\n            best.selection.manual.ratio.w=NULL,\n            bve.migration=NULL,\n            parallel.generation=FALSE,\n            name.cohort=NULL\n            ){\n  #######################################################################\n  ############################### To-Dos ################################\n  #######################################################################\n  # Duplication re-work - account for true genetic structure of duplications - known?\n  # Duplikationen in Duplizierten Bereichen werden nicht doppelt dupliziert\n  # Keine feste matrix-struktur in 11/12? - testelement 13 entfernen\n  # Duplikation am Rand benötigt info ob am start oder Ende bei mehreren Chromosomen\n  #\n  # Matrixstrukur bei mehreren Zuchtwerten geht verloren wenn nur ein relevantes Tier enthalten\n  #\n  # STORE BREEDING.totals fur fixed.breeding implementieren\n  #######################################################################\n\n  #######################################################################\n  ## Pre-work to allow for flexiblity when inputing parameter values ####\n  # Initialisize parameters that were not initialized in early versions #\n  #######################################################################\n\n  if(length(randomSeed)>0){\n    set.seed(randomSeed)\n  }\n  if(length(population$info$cumsnp)==0){\n    population$info$cumsnp <- cumsum(population$info$snp)\n  }\n  if(length(gen.architecture.w)==0){\n    gen.architecture.w=gen.architecture.m\n  }\n  best.selection.ratio <- list()\n  best.selection.ratio[[1]] <- best.selection.ratio.m\n  if(length(best.selection.ratio.w)==0){\n    best.selection.ratio.w <- best.selection.ratio.m\n  }\n  best.selection.ratio[[2]] <- best.selection.ratio.w\n\n  best.selection.criteria <- list()\n  best.selection.criteria[[1]] <- best.selection.criteria.m\n  if(length(best.selection.criteria.w)==0){\n    best.selection.criteria.w <- best.selection.criteria.m\n  }\n  best.selection.criteria[[2]] <- best.selection.criteria.w\n\n  best.selection.manual.ratio <- list()\n  best.selection.manual.ratio[[1]] <- best.selection.manual.ratio.m\n  if(length(best.selection.manual.ratio.w)==0 && length(best.selection.manual.ratio.w)!=0 ){\n    best.selection.manual.ratio.w <- best.selection.manual.ratio.m\n  }\n  best.selection.manual.ratio[[2]] <- best.selection.manual.ratio.w\n  best.selection.manual.ratio[[3]] <- \"placeholder\"\n\n  if(length(population$info$origin_gen)>0){\n    population$info$origin_gen <- base::as.integer(population$info$origin_gen)\n  } else{\n    population$info$origin_gen <- 1:64L\n  }\n\n  if(Rprof){\n    Rprof()\n  }\n\n  if(length(population$info$origin)==0){\n    population$info$origin <- 1:64\n  }\n\n  if(length(miraculix.chol)==0){\n    miraculix.chol=FALSE\n  }\n  if(fast.compiler && requireNamespace(\"compiler\", quietly = TRUE)){\n    compiler::enableJIT(3)\n  }\n  if(sum(population$info$snp)<=maxZ){\n    sequenceZ <- FALSE\n  }\n  if(length(population$info$miraculix)>0 && population$info$miraculix){\n    miraculix <- TRUE\n  }\n  if(miraculix && length(miraculix.mult)==0){\n    miraculix.mult <- TRUE\n  } else if(length(miraculix.mult)==0){\n    miraculix.mult <- FALSE\n  }\n  if(store.comp.times){\n    comp_times <- numeric(7)\n    comp_times[1] <- as.numeric(Sys.time())\n  }\n\n  if(gene.editing.offspring || gene.editing.best){\n    gene.editing <- TRUE\n  } else{\n    gene.editing <- FALSE\n  }\n  if(length(population$info$bitstoring)>0){\n    bit.storing <- TRUE\n    nbits <- population$info$bitstoring\n    if(maxZ%%nbits!=0){\n      maxZ <- maxZ + nbits - maxZ%%nbits\n    }\n  } else{\n    nbits <- 30\n    bit.storing <- FALSE\n  }\n  # Increase maxZ to improve run-time based on bitwise computing.\n  if(miraculix && maxZ%%512!=0){\n    maxZ <- maxZ + 512 - maxZ%%512\n  }\n\n  if(length(add.architecture)>0){\n    population$info$gen_architecture[[length(population$info$gen_architecture)+1]] <- list()\n    population$info$gen_architecture[[length(population$info$gen_architecture)]]$length.total <- cumsum(c(0,add.architecture[[1]]))\n    population$info$gen_architecture[[length(population$info$gen_architecture)]]$snp.position <- add.architecture[[2]]\n\n  }\n  if (requireNamespace(\"miraculix\", quietly = TRUE)) {\n    if(miraculix.cores>1){\n      RandomFieldsUtils::RFoptions(cores = miraculix.cores)\n    }\n    codeOriginsU <- miraculix::codeOrigins\n    decodeOriginsU <- miraculix::decodeOrigins\n  } else{\n    codeOriginsU <- codeOriginsR\n    decodeOriginsU <- decodeOriginsR\n  }\n\n\n  if(length(best1.from.group)==0){\n    best1.from.group_B <- FALSE\n  } else{\n    best1.from.group_B <- TRUE\n  }\n\n  if(length(best2.from.group)==0){\n    best2.from.group_B <- FALSE\n  } else{\n    best2.from.group_B <- TRUE\n  }\n\n\n  if(length(new.phenotype.correlation)>0){\n    population$info$pheno.correlation <- t(chol(new.phenotype.correlation))\n  }\n  if(length(new.breeding.correlation)>0){\n    population$info$bv.correlation <- new.breeding.correlation\n  }\n\n\n  #standardize.bv nie betrachtete Werte nicht standardisieren.\n\n\n  migration.level <- list()\n  migration.level[[1]] <- migration.level.m\n  migration.level[[2]] <- migration.level.w\n\n  if(use.last.sigma.e){\n    if(length(population$info$last.sigma.e)){\n      sigma.e <- population$info$last.sigma.e\n    }\n  }\n  if(length(sigma.e)==1){\n    sigma.e <- rep(sigma.e, population$info$bve.nr)\n  }\n  if(length(sigma.s)==1){\n    sigma.s <- rep(sigma.s, population$info$bve.nr)\n  }\n  # Berechnung der tatsaechlichen Zuchtwerte\n\n  if(store.comp.times){\n    comp_times[2] <- as.numeric(Sys.time())\n  }\n\n\n\n\n  if(length(selection.function.matrix)!=0 && is.matrix(selection.function.matrix)==FALSE){\n    selection.function.matrix <- matrix(selection.function.matrix,nrow=1)\n  }\n  if(length(selection.w)==0){\n    selection.w <- selection.m\n  }\n  if(length(used.generations.w)==0){\n    used.generations.w <- used.generations.m\n  }\n\n  if(length(selection.size)==1){\n    selection.size <- rep(selection.size,2)\n  }\n  if(length(breeding.size)==1){\n    breeding.size.total <- breeding.size\n    breeding.size.m <- round(breeding.size*breeding.gender)\n    if(breeding.gender.random){\n      breeding.size.m <- sum(stats::rbinom(breeding.size,1,breeding.gender))\n    }\n    breeding.size <- c(breeding.size.m, breeding.size - breeding.size.m)\n  } else{\n    breeding.size.total <- sum(breeding.size)\n  }\n\n  gender.animal <- rep(2, breeding.size.total)\n  if(breeding.size[1] > 0){\n    gender.animalr <- sample(1:breeding.size.total, breeding.size[1])\n    gender.animal[gender.animalr] <- 1\n  }\n\n\n  if(add.gen==0){\n    current.gen <- length(population$breeding)\n  } else{\n    current.gen <- add.gen\n  }\n\n  if(length(fixed.breeding) >0 && ncol(fixed.breeding)==6){\n    fixed.breeding <- cbind(fixed.breeding,breeding.gender)\n  }\n  if(length(fixed.breeding.best) >0 && ncol(fixed.breeding.best)==4){\n    fixed.breeding.best <- cbind(fixed.breeding.best,breeding.gender)\n  }\n\n\n  if(length(selection.m)==1){\n    selection.m <- rep(selection.m,current.gen)\n  }\n  if(length(selection.w)==1){\n    selection.w <- rep(selection.w,current.gen)\n  }\n  if(length(used.generations.m)< current.gen){\n    if(length(used.generations.m) == 1) used.generations.m <-  c(rep(0,current.gen-1),1)\n    used.generations.m <- c(rep(0, current.gen - length(used.generations.m)), used.generations.m)\n  }\n  if(sum(used.generations.m)!=1 && sum(used.generations.m) !=0){\n    used.generations.m <- used.generations.m/sum(used.generations.m)\n  }\n\n  if(length(used.generations.w)< current.gen){\n    if(length(used.generations.w) == 1) used.generations.w <-  c(rep(0,current.gen-1),1)\n    used.generations.w <- c(rep(0, current.gen - length(used.generations.w)), used.generations.w)\n  }\n  if(sum(used.generations.w)!=1 && sum(used.generations.w)!=0){\n    used.generations.w <- used.generations.w/sum(used.generations.w)\n  }\n\n  #######################################################################\n  ############## Start of the actual Simulation #########################\n  #######################################################################\n\n  if(standardize.bv){\n    for(bven in 1:population$info$bve.nr){\n      bv_previous <- c(population$breeding[[standardize.bv.gen]][[7]][bven,],population$breeding[[standardize.bv.gen]][[8]][bven,])\n      needed_change <- standardize.bv.level - mean(bv_previous)\n      population$info$base.bve <- population$info$base.bve + needed_change\n      for(times in 1:length(population$breeding)){\n        for(to_change in c(3,4,7,8,9,10)){\n          population$breeding[[times]][[to_change]][bven,] <- population$breeding[[times]][[to_change]][bven,] + needed_change\n        }\n\n      }\n    }\n  }\n\n  # Only first TRUE/FALSE necessary for new datasets.\n  if(length(population$info$effect_p)==0 || (length(population$info$effect_p_add)==0 && length(population$info$effect_p_mult1)==0 && length(population$info$effect_p_dice)==0)){\n    excludes <- NULL\n    snp.before <- cumsum(c(0,population$info$snp))\n    if(population$info$real.bv.length[1]>0){\n      for(index in 1:population$info$real.bv.length[1]){\n        if(length(population$info$real.bv.add[[index]])>0 && nrow(population$info$real.bv.add[[index]])>0){\n          population$info$effect_p_add[[index]] <- population$info$real.bv.add[[index]][,1]+ snp.before[population$info$real.bv.add[[index]][,2]]\n          excludes <- unique(c(excludes, population$info$effect_p_add))\n\n        }\n      }\n    }\n\n    if(population$info$real.bv.length[2]>0){\n      for(index in 1:population$info$real.bv.length[2]){\n        if(length(population$info$real.bv.mult[[index]])>0 &&nrow(population$info$real.bv.mult[[index]])>0){\n          population$info$effect_p_mult1[[index]] <- population$info$real.bv.mult[[index]][,1]+ snp.before[population$info$real.bv.mult[[index]][,2]]\n          population$info$effect_p_mult2[[index]] <- population$info$real.bv.mult[[index]][,3]+ snp.before[population$info$real.bv.mult[[index]][,4]]\n          excludes <- unique(c(excludes, population$info$effect_p_mult1,population$info$effect_p_mult2))\n        }\n      }\n    }\n    if(population$info$real.bv.length[3]>0){\n      for(index in 1:population$info$real.bv.length[3]){\n        if(length(population$info$real.bv.dice[[index]])>0){\n          for(index2 in 1:length(population$info$real.bv.dice[[index]][[1]])){\n            population$info$effect_p_dice <- c(population$info$effect_p_dice, population$info$real.bv.dice[[index]][[1]][[index2]][,1]+ snp.before[population$info$real.bv.dice[[index]][[1]][[index2]][,2]])\n          }\n          excludes <- unique(c(excludes, population$info$effect_p_dice))\n        }\n      }\n    }\n    population$info$effect_p <- excludes\n\n  }\n\n  temp1 <- population$info$bve.calculated\n  if(population$info$bve && population$info$bve.calculated==FALSE){\n    for(index in 1:length(population$breeding)){\n      for(gender in 1:2){\n        nanimals <- length(population$breeding[[index]][[gender]])\n        if(nanimals >0){\n          for(nr.animal in 1:nanimals){\n            activ_bv <- which(population$info$bv.random[1:population$info$bve.calc]==FALSE)\n            if(length(activ_bv)>0){\n              temp_out <- calculate.bv(population, index, gender, nr.animal,\n                                       activ_bv, import.position.calculation=import.position.calculation, decodeOriginsU=decodeOriginsU,\n                                       store.effect.freq=store.effect.freq,\n                                       bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)\n              population$breeding[[index]][[6+gender]][activ_bv,nr.animal] <- temp_out[[1]]\n              if(store.effect.freq){\n                if(length(population$info$store.effect.freq) < index || length(population$info$store.effect.freq[[index]])==0){\n                  population$info$store.effect.freq[[index]] <- temp_out[[2]]\n                } else{\n                  population$info$store.effect.freq[[index]] <- population$info$store.effect.freq[[index]] + temp_out[[2]]\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    population$info$bve.calculated <- TRUE\n  }\n\n  # Reale Zuchtwerte fuer Nicht-SNP-Effekte\n  if(population$info$bve.calc>0 && population$info$bv.random[population$info$bve.calc]){\n    mu1 <- numeric((population$info$bve.calc-1))\n    # Schaetzung Sigma_s fuer SNP-Effekte-Effekte\n    if(population$info$bve.calc>1){\n      database_s <- rbind(if(sum(used.generations.m)>0){cbind(which(used.generations.m>0),1)},\n                          if(sum(used.generations.w)>0){cbind(which(used.generations.w>0),2)})\n      n.animals <- 0\n      for(index in 1:nrow(database_s)){\n        n.animals <- n.animals + population$info$size[database_s[index,1], database_s[index,2]]\n      }\n      y_real <- array(0, dim=c(n.animals,(population$info$bve.calc-1))) # schaetzung sigma.s\n      cindex <- 1\n      for(index in 1:nrow(database_s)){\n        k.database <- database_s[index,]\n        kn <- population$info$size[k.database[1], k.database[2]]\n        if(kn>0){\n          for(kindex in 1:kn){\n            for(bven in 1:(population$info$bve.calc-1)){\n              y_real[cindex,bven] <- population$breeding[[k.database[[1]]]][[6+k.database[[2]]]][bven,kindex]\n            }\n            cindex <- cindex +1\n          }\n        }\n      }\n      for(bven in 1:(population$info$bve.calc-1)){\n        population$info$bv.random.variance[bven] <- stats::var(y_real[,bven])\n        mu1[bven] <- mean(y_real[,bven])\n      }\n\n    }\n    population$info$current.bv.correlation <- population$info$bv.correlation\n    if(sum(is.na(population$info$bv.correlation))){\n      emp_cor <- which(is.na(population$info$bv.correlation), arr.ind=TRUE)\n      for(index in 1:nrow(emp_cor)){\n        population$info$current.bv.correlation[emp_cor[index,1], emp_cor[index,2]] <-\n          stats::cor(y_real[,emp_cor[index,1]], y_real[,emp_cor[index,2]])\n      }\n    }\n    if(temp1==FALSE){\n      population$info$current.bv.random.variance  <- population$info$bv.random.variance\n      if(population$info$bve.calc==1){\n        bv.var <- diag(sqrt(population$info$current.bv.random.variance)) %*%population$info$current.bv.correlation %*% diag(sqrt(population$info$current.bv.random.variance))\n      } else{\n        AA <- diag(sqrt(population$info$current.bv.random.variance)[1:(population$info$bve.calc-1)]) %*% population$info$current.bv.correlation[1:(population$info$bve.calc-1), 1:(population$info$bve.calc-1)]%*% diag(sqrt(population$info$current.bv.random.variance)[(1:(population$info$bve.calc-1))])\n        BB <- diag(sqrt(population$info$current.bv.random.variance)[1:(population$info$bve.calc-1)]) %*%population$info$current.bv.correlation[1:(population$info$bve.calc-1), -(1:(population$info$bve.calc-1))]%*% diag(sqrt(population$info$current.bv.random.variance)[-(1:(population$info$bve.calc-1))])\n        CC <- diag(sqrt(population$info$current.bv.random.variance)[-(1:(population$info$bve.calc-1))]) %*%population$info$current.bv.correlation[-(1:(population$info$bve.calc-1)), -(1:(population$info$bve.calc-1))] %*% diag(sqrt(population$info$current.bv.random.variance)[-(1:(population$info$bve.calc-1))])\n        if (requireNamespace(\"MASS\", quietly = TRUE)) {\n          bv.var <- CC - t(BB) %*% MASS::ginv(AA) %*% BB\n          mu_mult <- t(BB) %*% MASS::ginv(AA)\n        } else{\n          bv.var <- CC - t(BB) %*% solve(AA) %*% BB\n          mu_mult <- t(BB) %*% solve(AA)\n        }\n      }\n      bv.var_chol <- t(chol(bv.var))\n      population$info$bv.correlation_col <- bv.var_chol\n      for(index in 1:length(population$breeding)){\n        for(gender in 1:2){\n          nanimals <- length(population$breeding[[index]][[gender]])\n          if(nanimals >0){\n            for(nr.animal in 1:nanimals){\n              if(population$info$bve.calc==1){\n                bv.mean <- population$info$base.bve\n              } else{\n                bv.mean <- population$info$base.bve[-(1:(population$info$bve.calc-1))] +  mu_mult %*% (population$breeding[[index]][[gender+6]][1:(population$info$bve.calc-1), nr.animal] - mu1)\n              }\n              population$breeding[[index]][[6+gender]][population$info$bve.calc:population$info$bve.nr, nr.animal] <- bv.mean + bv.var_chol %*% stats::rnorm(population$info$bve.nr-population$info$bve.calc+1,0,1)\n            }\n          }\n        }\n      }\n    }\n\n  }\n  if(store.comp.times){\n    comp_times[3] <- as.numeric(Sys.time())\n  }\n\n\n  if(length(heritability)>0){\n    if(length(heritability)!=population$info$bve.nr){\n      heritability <- rep(heritability, population$info$bve.nr)\n    }\n    n.animals <- 0\n    for(index in 1:nrow(sigma.e.database)){\n      n.animals <- n.animals + population$info$size[sigma.e.database[index,1], sigma.e.database[index,2]]\n    }\n    y_real <- array(0, dim=c(n.animals,population$info$bve.nr)) # schaetzung sigma.s\n    cindex <- 1\n    for(index in 1:nrow(sigma.e.database)){\n      k.database <- sigma.e.database[index,]\n      kn <- length(population$breeding[[k.database[1]]][[k.database[[2]]]])\n      for(kindex in 1:kn){\n        for(bven in 1:population$info$bve.nr){\n          y_real[cindex,bven] <- population$breeding[[k.database[[1]]]][[6+k.database[[2]]]][bven,kindex]\n        }\n        cindex <- cindex +1\n      }\n    }\n\n    for(bven in 1:population$info$bve.nr){\n      if(forecast.sigma.s){\n        sigma.s <- stats::var(y_real[,bven])\n      }\n      sigma.e[bven] <- ((1- heritability[bven]) * sigma.s)/ heritability[bven]\n    }\n  }\n\n  if(length(new.bv.observation)>0 && population$info$bve){\n    temp1 <- FALSE\n    if(new.bv.observation==\"all\" || new.bv.observation==\"non_obs\"){\n      temp1 <- TRUE\n      new.bv.observation <- 1:length(population$breeding)\n    }\n    for(index in new.bv.observation){\n      for(gender in new.bv.observation.gender){\n        nanimals <- length(population$breeding[[index]][[gender]])\n        if(nanimals >0){\n          for(nr.animal in 1:nanimals){\n            temp_random <- matrix(stats::rnorm(population$info$bve.nr*n.observation,0,1), ncol=n.observation)\n            if(temp1 && (length(population$breeding[[index]][[gender]][[nr.animal]])<14 || population$breeding[[index]][[gender]][[nr.animal]][[15]]>=1)){\n            } else if(length(population$breeding[[index]][[gender]][[nr.animal]])>=15){\n              bobs <- population$breeding[[index]][[gender]][[nr.animal]][[15]]\n              fobs <- n.observation\n              for(bven in 1:population$info$bve.nr){\n                population$breeding[[index]][[8+gender]][bven,nr.animal] <-  bobs/(bobs+fobs) * population$breeding[[index]][[8+gender]][[bven,nr.animal]] + fobs/(bobs+fobs) * (rowMeans(population$info$pheno.correlation %*% temp_random)[bven] * sqrt(sigma.e[bven]/n.observation) + population$breeding[[index]][[6+gender]][bven, nr.animal])\n              }\n              population$breeding[[index]][[gender]][[nr.animal]][[15]] <- population$breeding[[index]][[gender]][[nr.animal]][[15]] + n.observation\n\n            }\n          }\n        }\n      }\n    }\n  }\n\n\n  # Ubernehme Zuchtwert der Kinder fuer die Eltern\n\n  if(bve.childbase){\n    for(index in 1:nrow(bve.childbase.parents)){\n      activ.parents <- bve.childbase.parents[index,]\n      new.bv <- matrix(0, nrow=nrow(population$breeding[[activ.parents[1]]][[activ.parents[2]+2]]), ncol=ncol(population$breeding[[activ.parents[1]]][[activ.parents[2]+2]]))\n      counter <- numeric(ncol(new.bv))\n      for(index2 in 1:nrow(bve.childbase.children)){\n        activ.children <- bve.childbase.children[index2,]\n        n.animals <- length(population$breeding[[activ.children[1]]][[activ.children[2]]])\n        for(index3 in 1:n.animals){\n          for(bven in 1:population$info$bve.nr){\n            parent1 <- population$breeding[[activ.children[1]]][[activ.children[2]]][[index3]][[7]]\n            parent2 <- population$breeding[[activ.children[1]]][[activ.children[2]]][[index3]][[8]]\n            if(parent1[1]==activ.parents[1] && parent1[2]==activ.parents[2]){\n              new.bv[bven,parent1[3]] <- new.bv[bven,parent1[3]] + population$breeding[[activ.children[1]]][[activ.children[2]+8]][bven,index3]\n              counter[parent1[3]] <- counter[parent1[3]] +1\n            }\n            if(parent2[1]==activ.parents[1] && parent2[2]==activ.parents[2]){\n              new.bv[bven,parent2[3]] <- new.bv[bven,parent2[3]] + population$breeding[[activ.children[1]]][[activ.children[2]+8]][bven,index3]\n              counter[parent2[3]] <- counter[parent2[3]] +1\n            }\n\n          }\n        }\n      }\n      population$breeding[[activ.parents[1]]][[activ.parents[2]+2]] <- t(t(new.bv)/counter)\n      population$breeding[[activ.parents[1]]][[activ.parents[2]+8]] <- t(t(new.bv)/counter)\n      if(sum(counter==0)>0){\n        population$breeding[[activ.parents[1]]][[activ.parents[2]+2]][,counter==0] <- 0\n      }\n    }\n\n  }\n  if(store.comp.times){\n    comp_times[4] <- as.numeric(Sys.time())\n  }\n  if(store.comp.times.bve){\n    comp_times_bve <- numeric(5)\n    z_chol <- 0\n    z_uhat <- 0\n    zcalc <- 0\n    comp_times_bve[1] <- as.numeric(Sys.time())\n  }\n\n  ## ZUCHTWERTSCHAETZUNG\n  ## Hier steht aktuell viel ungeordneter Mülle irgendwie kommen aber schaetzer raus.\n  ## Fuer berechnung A - kinship oder nach P.M.VanRaden\n  u_hat <- NULL\n  gwas_hat <- NULL\n  u_hat_possible <- FALSE\n  if(phenotype.bv || bve && sum(sigma.e)==0 && BGLR.bve==FALSE ){\n    if(store.bve.data){\n      y <- array(0,dim=c(n.animals,population$info$bve.nr))\n      y_parent <- array(0,dim=c(n.animals,population$info$bve.nr))\n      y_real <- array(0, dim=c(n.animals,population$info$bve.nr)) # schaetzung sigma.s\n      y_hat <- array(0, dim=c(n.animals,population$info$bve.nr))\n      cindex <- 1\n      size <- cumsum(c(0,as.vector(t(population$info$size))))\n      for(index in 1:nrow(bve.database)){\n        k.database <- bve.database[index,]\n        kn <- length(population$breeding[[k.database[1]]][[k.database[[2]]]])\n        for(kindex in 1:kn){\n          for(bven in 1:population$info$bve.nr){\n            # HIER EVENTUELL SNPs auslesen!\n            y[cindex,bven] <- y_hat[cindex,bven] <- population$breeding[[k.database[[1]]]][[8+k.database[[2]]]][bven,kindex]\n\n\n            y_real[cindex,bven] <- population$breeding[[k.database[[1]]]][[6+k.database[[2]]]][bven,kindex]\n          }\n          cindex <- cindex +1\n        }\n      }\n    }\n    for(index in 1:nrow(bve.database)){\n      activ.base <- bve.database[index,]\n      population$breeding[[activ.base[1]]][[activ.base[2]+2]] <- population$breeding[[activ.base[1]]][[activ.base[2]+8]]\n    }\n  } else if(bve){\n    n.animals <- 0\n    for(index in 1:nrow(bve.database)){\n      if(length(bve.migration)>0){\n        for(mig in bve.migration){\n          n.animals <- n.animals + sum(population$breeding[[bve.database[index,1]]][[bve.database[index,2]+4]]==mig)\n        }\n      } else{\n        n.animals <- n.animals + population$info$size[bve.database[index,1], bve.database[index,2]]\n      }\n    }\n    if(sequenceZ){\n      if(maxZtotal>0){\n        maxZ <- floor(maxZtotal / n.animals)\n      }\n      Zt <- array(0L,dim=c(maxZ,n.animals))\n    } else{\n      Zt <- array(0L,dim=c(sum(population$info$snp), n.animals))\n    }\n\n    y <- y_real <- y_hat <- array(0,dim=c(n.animals,population$info$bve.nr))\n    X <- matrix(1, nrow=n.animals,ncol=1)\n    R <- diag(1L, nrow=n.animals)\n    grid.position <- numeric(n.animals)\n    cindex <- 1\n\n    loop_elements <- matrix(nrow=n.animals, ncol=5)\n    start <- 1\n    loop_elements[,1] <- 1:n.animals\n    for(index in 1:nrow(bve.database)){\n      k.database <- bve.database[index,]\n      kn <- length(population$breeding[[k.database[1]]][[k.database[[2]]]])\n      if(length(bve.migration)>0){\n        for(mig in bve.migration){\n          plus <- 0\n          adding <- which(population$breeding[[k.database[1]]][[k.database[2]+4]]==mig)\n          if(length(adding) > 0){\n            loop_elements[(start+plus):(start+plus+length(adding)-1),2] <- adding\n            plus <- plus + length(adding)\n          }\n        }\n        kn <- plus\n      } else{\n        loop_elements[start:(start+kn-1),2] <- 1:kn\n      }\n\n      loop_elements[start:(start+kn-1),3] <- index\n      loop_elements[start:(start+kn-1),4] <- k.database[1]\n      loop_elements[start:(start+kn-1),5] <- k.database[2]\n      start <- start + kn\n    }\n\n    size <- cumsum(c(0,as.vector(t(population$info$size))))\n    for(index in 1:n.animals){\n      k.database <- bve.database[loop_elements[index,3],]\n      cindex <- loop_elements[index,1]\n      kindex <- loop_elements[index,2]\n      population$breeding[[k.database[[1]]]][[k.database[[2]]]][[kindex]][[16]] <- 1\n      y[cindex,] <- population$breeding[[k.database[[1]]]][[8+k.database[[2]]]][,kindex]\n      y_real[cindex,] <- population$breeding[[k.database[[1]]]][[6+k.database[[2]]]][,kindex]\n      grid.position[cindex] <- kindex + size[sum(k.database*c(2,1))-2]\n      if(estimate.add.gen.var){\n        father <- population$breeding[[k.database[1]]][[k.database[2]]][[kindex]][[7]]\n        mother <- population$breeding[[k.database[1]]][[k.database[2]]][[kindex]][[8]]\n        if(sum(father[1:3]==c(k.database[1:2], kindex))==3 ||sum(mother[1:3]==c(k.database[1:2], kindex))==3){\n          print(\"Schaetzung der additiv genetischen Varianz extrem problematisch. Kein Elterntier fuer jedes Tier vorhanden!\")\n        }\n        y_parent[cindex,] <- mean(population$breeding[[father[1]]][[8+father[2]]][[,father[3]]],population$breeding[[mother[1]]][[8+mother[2]]][[,mother[3]]])\n      }\n    }\n\n    batch <- ceiling(nrow(loop_elements)/ncore)\n    batche <- list()\n    for(index in 1:ncore){\n      batche[[index]] <- (batch*(index-1)+1):min(batch*index, nrow(loop_elements))\n    }\n\n\n    if(sequenceZ==FALSE){\n      if(miraculix){\n\n        if(store.comp.times.bve){\n          before <- as.numeric(Sys.time())\n        }\n\n        Z.code <- miraculix::computeSNPS(population, loop_elements[,4], loop_elements[,5], loop_elements[,2], what=\"geno\", output_compressed=TRUE)\n        if(computation.A!=\"vanRaden\"){\n          Zt <- miraculix::computeSNPS(population, loop_elements[,4], loop_elements[,5], loop_elements[,2], what=\"geno\", output_compressed=FALSE)\n\n        }\n        if(store.comp.times.bve){\n          after <- as.numeric(Sys.time())\n          zcalc <- zcalc + after - before\n        }\n\n      } else if(ncore>1){\n        if(store.comp.times.bve){\n          before <- as.numeric(Sys.time())\n        }\n\n        if(backend==\"doParallel\"){\n          doParallel::registerDoParallel(cores=ncore)\n        } else if(backend==\"doMPI\"){\n          if (requireNamespace(\"doMPI\", quietly = TRUE)) {\n            cl <- doMPI::startMPIcluster(count=ncore)\n            doMPI::registerDoMPI(cl)\n          } else{\n            stop(\"Usage of doMPI without being installed!\")\n          }\n        } else{\n          print(\"No valid backend specified\")\n        }\n\n\n        Zt <- foreach::foreach(indexb=1:ncore, .combine = \"cbind\", .multicombine = TRUE,.maxcombine = 1000,\n                     .packages=\"RekomBre\") %dopar% {\n          Ztpar <- array(0,dim=c(sum(population$info$snp), length(batche[[indexb]])))\n          sub <- min(batche[[indexb]]) -1\n          for(index in batche[[indexb]]){\n            k.database <- bve.database[loop_elements[index,3],]\n            cindex <- loop_elements[index,1] - sub\n            kindex <- loop_elements[index,2]\n            Ztpar[,cindex] <- base::as.integer(colSums(compute.snps(population, k.database[[1]],k.database[[2]],kindex, import.position.calculation=import.position.calculation,decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))\n          }\n          if(Z.integer){\n            storage.mode(Zpar) <- \"integer\"\n          }\n          Ztpar\n        }\n        if(backend==\"doParallel\"){\n          doParallel::stopImplicitCluster()\n        } else if(backend==\"doMPI\"){\n          if (requireNamespace(\"doMPI\", quietly = TRUE)) {\n            doMPI::closeCluster(cl)\n          } else{\n            stop(\"Usage of doMPI without being installed!\")\n          }\n\n\n        }\n        if(store.comp.times.bve){\n          after <- as.numeric(Sys.time())\n          zcalc <- zcalc + after - before\n        }\n      } else{\n        if(store.comp.times.bve){\n          before <- as.numeric(Sys.time())\n        }\n\n        for(index in 1:n.animals){\n          k.database <- bve.database[loop_elements[index,3],]\n          cindex <- loop_elements[index,1]\n          kindex <- loop_elements[index,2]\n          Zt[,cindex] <- base::as.integer(colSums(compute.snps(population, k.database[[1]],k.database[[2]],kindex, import.position.calculation=import.position.calculation,decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))\n        }\n        if(store.comp.times.bve){\n          after <- as.numeric(Sys.time())\n          zcalc <- zcalc + after - before\n        }\n      }\n\n    }\n\n\n    if(remove.effect.position==TRUE && sequenceZ==FALSE && miraculix==FALSE){\n      Zt <- Zt[-population$info$effect_p,]\n    }\n    if(remove.effect.position==\"only_effect\" && sequenceZ==FALSE && miraculix==FALSE){\n      Zt <- Zt[population$info$effect_p,]\n    }\n    if(bve.0isNA){\n      y[y==0] <- NA\n    }\n\n    if(store.comp.times.bve){\n      comp_times_bve[2] <- as.numeric(Sys.time())\n    }\n\n    if(computation.A==\"kinship\"){\n      A_full <- kinship.exp(population)\n      A <- diag(1, nrow=n.animals)\n      for(i in 2:n.animals){\n        for(j in 1:(i-1)){\n          A[i,j] <- A[j,i] <- A_full[grid.position[i], grid.position[j]]\n        }\n      }\n      Am <- A\n    } else if(computation.A==\"vanRaden\"){\n      if(sequenceZ){\n\n        total_n <- sum(population$info$snp)\n        p_i <- numeric(total_n)\n        first <- 1\n        last <- min(maxZ, total_n)\n        A <- matrix(0, n.animals, n.animals)\n        for(index3 in 1:ceiling(total_n/maxZ)){\n          if(miraculix){\n            if(store.comp.times.bve){\n              before <- as.numeric(Sys.time())\n            }\n\n            Z.code <- miraculix::computeSNPS(population, loop_elements[,4], loop_elements[,5], loop_elements[,2], from_p=first,\n                                  to_p=last, what=\"geno\", output_compressed=TRUE)\n            if(store.comp.times.bve){\n              after <- as.numeric(Sys.time())\n              zcalc <- zcalc + after - before\n            }\n\n\n\n          } else if(ncore>1){\n            if(store.comp.times.bve){\n              before <- as.numeric(Sys.time())\n            }\n\n            if(backend==\"doParallel\"){\n              doParallel::registerDoParallel(cores=ncore)\n            } else if(backend==\"doMPI\"){\n              if (requireNamespace(\"doMPI\", quietly = TRUE)) {\n                cl <- doMPI::startMPIcluster(count=ncore)\n                doMPI::registerDoMPI(cl)\n              } else{\n                stop(\"Usage of doMPI without being installed!\")\n              }\n            } else{\n              print(\"No valid backend specified\")\n            }\n            Zt <- foreach::foreach(indexb=1:ncore, .combine = \"rbind\", .multicombine = TRUE,.maxcombine = 1000,\n                         .packages=\"RekomBre\") %dopar% {\n              Ztpar <- array(0,dim=c(last-first+1, length(batche[[indexb]])))\n              sub <- min(batche[[indexb]]) -1\n              for(index in batche[[indexb]]){\n                k.database <- bve.database[loop_elements[index,3],]\n                cindex <- loop_elements[index,1] - sub\n                kindex <- loop_elements[index,2]\n                Zpar[,cindex] <- base::as.integer(colSums(compute.snps(population, k.database[[1]],k.database[[2]],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))\n              }\n              if(Z.integer){\n                storage.mode(Ztpar) <- \"integer\"\n              }\n              Ztpar\n            }\n            if(backend==\"doParallel\"){\n              doParallel::stopImplicitCluster()\n            } else if(backend==\"doMPI\"){\n              if (requireNamespace(\"doMPI\", quietly = TRUE)) {\n                doMPI::closeCluster(cl)\n              } else{\n                stop(\"Usage of doMPI without being installed!\")\n              }\n\n            }\n            if(store.comp.times.bve){\n              after <- as.numeric(Sys.time())\n              zcalc <- zcalc + after - before\n            }\n          } else{\n            if(store.comp.times.bve){\n              before <- as.numeric(Sys.time())\n            }\n\n            for(index in 1:n.animals){\n              k.database <- bve.database[loop_elements[index,3],]\n              cindex <- loop_elements[index,1]\n              kindex <- loop_elements[index,2]\n              Zt[1:(last-first+1), cindex] <- base::as.integer(colSums(compute.snps(population, k.database[[1]],k.database[[2]],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last,decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))\n            }\n            if(store.comp.times.bve){\n              after <- as.numeric(Sys.time())\n              zcalc <- zcalc + after - before\n            }\n          }\n\n          if(miraculix){\n            p_i[first:last] <- miraculix::allele_freq(Z.code)\n            A <- A + miraculix::relationshipMatrix(Z.code, centered=TRUE, normalized=FALSE)\n          } else if(miraculix.mult){\n            storage.mode(Zt) <- \"integer\"\n            p_i[first:last] <- rowSums(Zt[1:(last-first+1),])/ncol(Zt)/2\n            Zt_miraculix <- miraculix::createSNPmatrix(Zt[1:(last-first+1),])\n            A <- A + miraculix::relationshipMatrix(Zt_miraculix, centered=TRUE, normalized=FALSE)\n          } else{\n            p_i[first:last] <- rowSums(Zt[1:(last-first+1),])/ncol(Zt)/2\n            Ztm <- Zt[1:(last-first+1),] - p_i[first:last] * 2\n            A <- A + crossprod(Ztm[1:(last-first+1),])\n          }\n\n          first <- first + maxZ\n          last <- min(maxZ*(index3+1), total_n)\n        }\n        A <- A / (2 * sum(p_i*(1-p_i)))\n\n        if(print.error.sources){\n          print(A[1:5,1:5])\n        }\n\n      } else{\n        if(miraculix){\n          p_i <- miraculix::allele_freq(Z.code) # Noch nicht implementiert?\n          A <- miraculix::relationshipMatrix(Z.code, centered=TRUE, normalized=TRUE)\n\n        } else if(miraculix.mult){\n          p_i <- rowSums(Zt)/ncol(Zt)/2\n          Zt_miraculix <- miraculix::createSNPmatrix(Zt)\n          A <- miraculix::relationshipMatrix(Zt_miraculix, centered=TRUE, normalized=TRUE)\n        } else{\n          p_i <- rowSums(Zt)/ncol(Zt)/2\n          Ztm <- Zt - p_i * 2\n          A <- crossprod(Ztm)/ (2 * sum(p_i*(1-p_i)))\n        }\n\n      }\n\n      if(store.comp.times.bve){\n        comp_times_bve[3] <- as.numeric(Sys.time())\n      }\n\n    } else if(computation.A==\"CM\"){\n      #CM SCHAETZER\n      Ztm <- rbind(Zt==0, Zt==1, Zt==2)\n      A <- crossprod(Ztm) / nrow(Zt)\n    } else if(computation.A==\"CE\"){\n\n      Ztm <- rbind(Zt==0, Zt==1, Zt==2)\n      A <- crossprod(Ztm)\n      A <- (A^2 - 0.5*A)/(nrow(Zt)^2)\n    } else if(computation.A==\"CE2\"){\n      A2 <- crossprod(Zt)\n      A <- 0.5 * A2 * A2 + 0.5 * crossprod(Zt*Zt)\n      A <- A/mean(diag(A))\n    } else if(computation.A==\"CE3\"){\n      A2 <- crossprod(Zt)\n      A <- 0.5 * A2 * A2 - 0.5 * crossprod(Zt*Zt)\n      A <- A/mean(diag(A))\n    } else if(computation.A==\"non_stand\"){\n      A <- crossprod(Zt) / nrow(Zt)\n    } else if(computation.A==\"vanRaden2\"){\n      p_i <- rowSums(Zt)/ncol(Zt)/2\n      Ztm <- Zt - p_i * 2\n      A <- crossprod(Ztm)/ (2 * sum(p_i*(1-p_i)))\n    }\n\n    sigma.a.hat <- numeric(length(sigma.s))\n    sigma.e.hat <- sigma.e\n\n    beta_hat <-  colMeans(y, na.rm=TRUE) # Rest faellt weg! (X' R^-1 X)^-1 X' R^-1 y\n\n\n    for(bven in 1:population$info$bve.nr){\n      if(forecast.sigma.s){\n        sigma.s[bven] <- stats::var(y_real[,bven])\n      }\n      if(estimate.pheno.var){\n        sigma.e.hat[bven] <- max(0, stats::var(y[,bven]) - sigma.s[bven])\n      }\n      sigma.a.hat[bven] <- sigma.s[bven]\n      if(estimate.add.gen.var){\n        sigma.a.hat[bven] <- max(min(stats::lm(y[,bven]~y_parent[,bven])$coefficients[2],1),0.001) * sigma.e.hat[bven]\n      }\n\n      if(computation.A==\"kinship\"){\n        A <- Am + sigma.e.hat[bven]\n      }\n      if(BGLR.bve){\n\n        Zt <- t(scale(t(Zt), center=TRUE, scale=FALSE))\n        fixed <- which(is.na(Z[,1]))\n        if(length(fixed)>0){\n          Zt <- Zt[-fixed,]\n        }\n\n        ETA <- list(list(K=A, model='RKHS'))\n        if(min(y[!is.na(y[,bven]),bven])==max(y[!is.na(y[,bven]),bven])){\n          y_hat[,bven] <- rep(max(y[!is.na(y[,bven]),bven]), length(y[,bven]))\n        } else{\n          if(BGLR.save.random){\n            BGLR.save <- paste0(BGLR.save, sample(1:10000,1))\n          }\n          if(requireNamespace(\"BGLR\", quietly = TRUE)){\n            fm <- BGLR::BGLR(y=y[,bven], ETA=ETA, nIter=BGLR.iteration, burnIn=BGLR.burnin, saveAt=BGLR.save, verbose=BGLR.print)\n          } else{\n            stop(\"Use of BGLR without being installed!\")\n          }\n          y_hat[,bven] <- fm$yHat\n        }\n      } else if(emmreml.bve){\n\n        n <- length(y[,bven])\n        p <- nrow(Zt)\n        stopifnot(n == ncol(Zt))\n\n        if(requireNamespace(\"EMMREML\", quietly = TRUE)){\n          fm <- EMMREML::emmreml(\n            y[,bven],\n            matrix(1,nrow=n),\n            diag(n),\n            A)\n        } else{\n          stop(\"Usage of EMMREML without being installed!\")\n        }\n\n\n        y_hat[,bven] <- as.numeric(fm$uhat) + as.numeric(fm$betahat)\n        if(estimate.u){\n          u_hat <- cbind(u_hat, alpha_to_beta(drop(fm$uhat),A,t(Zt)))\n        }\n\n      } else if(sigma.e[bven]>0){\n        u_hat_possible <- TRUE\n        multi <- y[,bven] - X %*% beta_hat[bven]\n        if(bve.0isNA && sum(is.na(multi))>0){\n          multi[is.na(multi)] <- 0\n        }\n\n        if(store.comp.times.bve){\n          before <- as.numeric(Sys.time())\n        }\n        # Zuchtwertschaetzung an sich\n        if(estimate.u){\n          if(miraculix && miraculix.chol){\n            temp1 <- miraculix::solveRelMat(A, sigma.e.hat[bven] / sigma.a.hat[bven], multi,beta_hat[bven])\n            Rest_term <- temp1[[1]]\n            y_hat[,bven] <- temp1[[2]]\n          } else{\n\n            Rest_term <- (chol2inv(chol(A + R *sigma.e.hat[bven] / sigma.a.hat[bven])) %*% multi)\n            y_hat[,bven] <- A %*% Rest_term + beta_hat[bven]\n          }\n\n\n        } else{\n          if(miraculix && miraculix.chol){\n            y_hat[,bven] <- miraculix::solveRelMat(A, sigma.e.hat[bven] / sigma.a.hat[bven], multi,beta_hat[bven])[[2]]\n          } else{\n            y_hat[,bven] <- A %*% (chol2inv(chol(A + R *sigma.e.hat[bven] / sigma.a.hat[bven])) %*% multi) + beta_hat[bven]\n          }\n        }\n        if(store.comp.times.bve){\n          after <- as.numeric(Sys.time())\n          z_chol <- after - before\n        }\n\n        ## LOESCHEN WENN FEHLER GEFUNDEN\n        if(store.bve.parameter){\n          population$info$A <- A\n          population$info$sigma.e <- sigma.e.hat[bven]\n          population$info$sigma.a <- sigma.a.hat[bven]\n          population$info$multi <- multi\n        }\n\n        # Schaetzung von Marker_effekten\n\n        if(estimate.u){\n          if(sequenceZ){\n            total_n <- sum(population$info$snp)\n            u_hat_new <- numeric(total_n)\n            first <- 1\n            last <- min(maxZ, total_n)\n            for(index3 in 1:ceiling(total_n/maxZ)){\n              if(miraculix){\n                if(store.comp.times.bve){\n                  before <- as.numeric(Sys.time())\n                }\n                Z.code <- miraculix::computeSNPS(population, loop_elements[,4], loop_elements[,5], loop_elements[,2],\n                                      from_p=first, to_p=last, what=\"geno\", output_compressed=TRUE\n                                      )\n\n                if(store.comp.times.bve){\n                  after <- as.numeric(Sys.time())\n                  zcalc <- zcalc + after - before\n                }\n              } else if(ncore>1){\n                if(store.comp.times.bve){\n                  before <- as.numeric(Sys.time())\n                }\n\n                if(backend==\"doParallel\"){\n                  doParallel::registerDoParallel(cores=ncore)\n                } else if(backend==\"doMPI\"){\n                  if (requireNamespace(\"doMPI\", quietly = TRUE)) {\n                    cl <- doMPI::startMPIcluster(count=ncore)\n                    doMPI::registerDoMPI(cl)\n                  } else{\n                    stop(\"Usage of doMPI without being installed!\")\n                  }\n                } else{\n                  print(\"No valid backend specified\")\n                }\n                Zt <- foreach::foreach(indexb=1:ncore, .combine = \"cbind\", .multicombine = TRUE,.maxcombine = 1000,\n                           .packages=\"RekomBre\") %dopar% {\n                  Ztpar <- array(0,dim=c(sum(population$info$snp), length(batche[[indexb]])))\n                  sub <- min(batche[[indexb]]) -1\n                  for(index in batche[[indexb]]){\n                    k.database <- bve.database[loop_elements[index,3],]\n                    cindex <- loop_elements[index,1] - sub\n                    kindex <- loop_elements[index,2]\n                    Ztpar[,cindex] <- base::as.integer(colSums(compute.snps(population, k.database[[1]],k.database[[2]],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))\n                  }\n                  if(Z.integer){\n                    storage.mode(Ztpar) <- \"integer\"\n                  }\n                  Ztpar\n                }\n                if(backend==\"doParallel\"){\n                  doParallel::stopImplicitCluster()\n                } else if(backend==\"doMPI\"){\n                  if (requireNamespace(\"doMPI\", quietly = TRUE)) {\n                    doMPI::closeCluster(cl)\n                  } else{\n                    stop(\"Usage of doMPI without being installed!\")\n                  }\n\n                }\n                if(store.comp.times.bve){\n                  after <- as.numeric(Sys.time())\n                  zcalc <- zcalc + after - before\n                }\n              } else{\n                if(store.comp.times.bve){\n                  before <- as.numeric(Sys.time())\n                }\n                for(index in 1:n.animals){\n                  k.database <- bve.database[loop_elements[index,3],]\n                  cindex <- loop_elements[index,1]\n                  kindex <- loop_elements[index,2]\n                  Zt[1:(last-first+1), cindex] <- base::as.integer(colSums(compute.snps(population, k.database[[1]],k.database[[2]],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last,decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))\n                }\n                if(store.comp.times.bve){\n                  after <- as.numeric(Sys.time())\n                  zcalc <- zcalc + after - before\n                }\n              }\n\n              if(store.comp.times.bve){\n                before <- as.numeric(Sys.time())\n              }\n\n              if(miraculix){\n                u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code, Rest_term)\n#                u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))*(miraculix::decodeGeno(Z.code) %*% Rest_term)\n              } else if(miraculix.mult){\n                u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::createSNPmatrix(Zt), Rest_term)\n                #u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))*(Zt %*% Rest_term)\n              } else{\n                #u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))*(Ztm %*% (chol2inv(chol(A + R *sigma.e.hat[bven] / sigma.a.hat[bven])) %*% (multi))))\n                u_hat_new[first:last] <- 1/ 2 / sum(p_i*(1-p_i))*(Ztm %*% Rest_term)\n              }\n\n              if(store.comp.times.bve){\n                after <- as.numeric(Sys.time())\n                z_uhat <- z_uhat + after - before\n              }\n\n              ### LOESCHEN WENN FEHLER GEFUNDEN\n              if(store.bve.parameter){\n                population$info$p_i[[length(population$info$p_i)+1]] <- p_i\n\n\n\n                if(miraculix){\n                  population$info$Z.code[[length(population$info$Z.code)+1]] <- miraculix::decodeGeno(Z.code)\n                } else if(miraculix.mult){\n                  population$info$Zt[[length(population$info$Zt)+1]] <- Zt\n                } else{\n                  population$info$Ztm[[length(population$info$Ztm)+1]] <- Ztm\n                }\n                print(\"test\")\n                population$info$rest[[length(population$info$rest)+1]] <- Rest_term\n              }\n              ##########\n\n\n              first <- first + maxZ\n              last <- min(maxZ*(index3+1), total_n)\n            }\n            u_hat_new <- scale(u_hat_new, scale=FALSE)\n            u_hat <- cbind(u_hat, u_hat_new)\n\n          } else{\n\n            if(store.comp.times.bve){\n              before <- as.numeric(Sys.time())\n            }\n\n            if(miraculix){\n              #u_hat <- cbind(u_hat, scale(1/ 2 / sum(p_i*(1-p_i))* vectorGeno(Rest_term, Z.code), scale=FALSE))\n              u_hat <- cbind(u_hat, scale(1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(Z.code, Rest_term), scale=FALSE))\n            } else if(miraculix.mult){\n\n              # u_hat <- cbind(u_hat, scale(1/ 2 / sum(p_i*(1-p_i))* vectorGeno(Rest_term, miraculix::createSNPmatrix(Zt)), scale=FALSE))\n              u_hat <- cbind(u_hat, scale(1/ 2 / sum(p_i*(1-p_i))* miraculix::genoVector(miraculix::createSNPmatrix(Zt), Rest_term), scale=FALSE))\n            } else{\n              #u_hat <- cbind(u_hat, 1/ 2 / sum(p_i*(1-p_i))*(Ztm %*% (chol2inv(chol(A + R *sigma.e.hat[bven] / sigma.a.hat[bven])) %*% (multi))))\n              u_hat <- cbind(u_hat, scale(1/ 2 / sum(p_i*(1-p_i))*(Ztm %*% Rest_term), scale=FALSE))\n            }\n\n            if(store.comp.times.bve){\n              after <- as.numeric(Sys.time())\n              z_uhat <- z_uhat + after - before\n            }\n\n          }\n         }\n      } else{\n        y_hat[,bven] <- y[,bven]\n      }\n\n      if(store.comp.times.bve==TRUE){\n        comp_times_bve[4] <- as.numeric(Sys.time())\n      }\n      cindex <- 1\n      if(nrow(bve.database)!=length(bve.database.insert)){\n        bve.database.insert <- rep(bve.database.insert, length.out = nrow(bve.database))\n      }\n\n      if(length(bve.migration)==0){\n        for(index in 1:nrow(bve.database)){\n          k.database <- bve.database[index,]\n          kn <- length(population$breeding[[k.database[1]]][[k.database[[2]]]])\n          if(bve.database.insert[index]==1){\n            population$breeding[[k.database[[1]]]][[2+k.database[[2]]]][bven,] <- y_hat[cindex:(cindex+kn-1),bven]\n          }\n          cindex <- cindex + kn\n        }\n      } else{\n        for(index in 1:nrow(loop_elements)){\n          population$breeding[[loop_elements[index,4]]][[loop_elements[index,5]+2]][, loop_elements[index,2]] <- y_hat[index,]\n        }\n      }\n\n\n      #  GWAS CODE NOT WRITEN FOR PARALLEL COMPUTING OR MIRACULIX\n      if(gwas.u){\n\n        if(y.gwas.used==\"pheno\"){\n          y_gwas <- y\n        } else if(y.gwas.used==\"bv\"){\n          y_gwas <- y_real\n        } else if(y.gwas.used==\"bve\"){\n          y_gwas <- y_hat\n        }\n\n        if(length(gwas.database)==0){\n          gwas.database <- bve.database\n        }\n        if(nrow(gwas.database)!=nrow(bve.database) || prod(gwas.database==bve.database)==0){\n          n.animals <- 0\n          for(index in 1:nrow(gwas.database)){\n            n.animals <- n.animals + population$info$size[gwas.database[index,1], gwas.database[index,2]]\n          }\n        }\n        if(gwas.group.standard){\n          gwas_start <- 1\n          for(index in 1:nrow(gwas.database)){\n            gwas_start <- c(gwas_start, max(gwas_start)+population$info$size[gwas.database[index,1], gwas.database[index,2]])\n          }\n        }\n        if(sequenceZ){\n          if(nrow(gwas.database)!=nrow(bve.database) || prod(gwas.database==bve.database)==0){\n            if(maxZtotal>0){\n              maxZ <- floor(maxZtotal / n.animals)\n            }\n            if(ncore<=1 && miraculix==FALSE){\n              Zt <- array(0,dim=c(maxZ,n.animals))\n            }\n            y_gwas <- array(0, dim=c(n.animals, population$info$bve.nr))\n\n          }\n          total_n <- sum(population$info$snp)\n          x_mean <- x2_mean <- xy_mean <- numeric(total_n)\n          first <- 1\n          last <- min(maxZ, total_n)\n          for(index3 in 1:ceiling(total_n/maxZ)){\n\n            cindex <- 1\n            for(index in 1:nrow(gwas.database)){\n              k.database <- gwas.database[index,]\n              kn <- length(population$breeding[[k.database[1]]][[k.database[[2]]]])\n              for(kindex in 1:kn){\n                Zt[1:(last-first+1), cindex] <- base::as.integer(colSums(compute.snps(population, k.database[[1]],k.database[[2]],kindex, import.position.calculation=import.position.calculation, from_p=first, to_p=last, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))\n                population$breeding[[k.database[[1]]]][[k.database[[2]]]][[kindex]][[16]] <- 1\n                for(bven in 1:population$info$bve.nr){\n                  # HIER EVENTUELL SNPs auslesen!\n                  if(y.gwas.used==\"pheno\"){\n                    y_gwas[cindex,bven] <- population$breeding[[k.database[[1]]]][[8+k.database[[2]]]][bven,kindex]\n                  } else if(y.gwas.used==\"bv\"){\n                    y_gwas[cindex,bven] <- population$breeding[[k.database[[1]]]][[6+k.database[[2]]]][bven,kindex]\n                  } else if(y.gwas.used==\"bve\"){\n                    y_gwas[cindex,bven] <- population$breeding[[k.database[[1]]]][[2+k.database[[2]]]][bven,kindex]\n                  }\n\n                }\n                cindex <- cindex +1\n              }\n            }\n            if(gwas.group.standard){\n              for(indexg in 1:(length(gwas_start)-1)){\n                y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven] <- y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven] - mean(y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven])\n              }\n            }\n\n            x_mean[first:last] <- rowMeans(Zt[1:(last-first+1),])\n            x2_mean[first:last] <- rowMeans(Zt[1:(last-first+1),]^2)\n            xy_mean[first:last] <- rowMeans(Zt[1:(last-first+1),]*y_gwas[,bven])\n            first <- first + maxZ\n            last <- min(maxZ*(index3+1), total_n)\n          }\n        } else{\n          if(nrow(gwas.database)!=nrow(bve.database) || prod(gwas.database==bve.database)==0){\n            Zt <- array(0,dim=c(sum(population$info$snp), n.animals))\n            y_gwas <- array(0, dim=c(n.animals, population$info$bve.nr))\n            cindex <- 1\n            for(index in 1:nrow(bve.database)){\n              k.database <- bve.database[index,]\n              kn <- length(population$breeding[[k.database[1]]][[k.database[[2]]]])\n              for(kindex in 1:kn){\n                if(sequenceZ==FALSE){\n                  Zt[,cindex] <- base::as.integer(colSums(compute.snps(population, k.database[[1]],k.database[[2]],kindex, import.position.calculation=import.position.calculation, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)))\n                }\n                population$breeding[[k.database[[1]]]][[k.database[[2]]]][[kindex]][[16]] <- 1\n                for(bven in 1:population$info$bve.nr){\n                  # HIER EVENTUELL SNPs auslesen!\n                  if(y.gwas.used==\"pheno\"){\n                    y_gwas[cindex,bven] <- population$breeding[[k.database[[1]]]][[8+k.database[[2]]]][bven,kindex]\n                  } else if(y.gwas.used==\"bv\"){\n                    y_gwas[cindex,bven] <- population$breeding[[k.database[[1]]]][[6+k.database[[2]]]][bven,kindex]\n                  } else if(y.gwas.used==\"bve\"){\n                    y_gwas[cindex,bven] <- population$breeding[[k.database[[1]]]][[2+k.database[[2]]]][bven,kindex]\n                  }\n                }\n                cindex <- cindex +1\n              }\n            }\n          }\n\n          if(gwas.group.standard){\n            gwas_start <- 1\n            for(index in 1:nrow(gwas.database)){\n              gwas_start <- c(gwas_start, max(gwas_start)+population$info$size[gwas.database[index,1], gwas.database[index,2]])\n            }\n            for(indexg in 1:(length(gwas_start)-1)){\n              y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven] <- y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven] - mean(y_gwas[gwas_start[indexg]:(gwas_start[indexg+1]-1), bven])\n            }\n          }\n          x_mean <- rowMeans(Zt)\n          x2_mean <- rowMeans(Zt^2)\n#          xy_mean <- colMeans(Z*y_gwas[,bven])\n          xy_mean <- colMeans(t(Zt)*y_gwas[,bven])\n        }\n\n        n <- length(y_gwas[,bven])\n        y_mean <- mean(y_gwas[,bven])\n\n        b1 <- (n *xy_mean - n *x_mean * y_mean) / (x2_mean*n - n *x_mean^2)\n\n\n        if(approx.residuals==FALSE){\n          sigma1 <- 1/(n * (x2_mean-(x_mean)^2))\n          b0 <- y_mean - b1 * x_mean\n          var1 <- numeric(length(sigma1))\n          for(index in 1:length(sigma1)){\n            var1[index] <- sigma1[index] * stats::var(y_gwas[,bven] - b1[index] * Zt[index,] - b0[index]) * (n-1)/(n-2)\n          }\n\n        } else{\n          var1 <- 1/(n * (x2_mean-(x_mean)^2)) * stats::var(y_gwas[,bven])\n        }\n        test <- b1/sqrt(var1)\n        gwas_hat <- cbind(gwas_hat, test)\n        #sorted <- sort(abs(test), index.return=TRUE)\n      }\n\n    }\n\n    # Zuchtwertschaetzung eintragen:\n\n  }\n  if(u_hat_possible && bve && estimate.u && computation.A==\"vanRaden\"){\n    population$info$u_hat[[length(population$info$u_hat)+1]] <- u_hat\n    population$info$u_hat_single[[length(population$info$u_hat)]] <- list()\n    for(bven in 1:ncol(u_hat)){\n      population$info$u_hat_single[[length(population$info$u_hat)]][[bven]] <- cbind((-2*p_i) *u_hat[,bven],(-2*p_i+1) *u_hat[,bven],(-2*p_i+2) *u_hat[,bven])\n    }\n  } else if(u_hat_possible && bve && estimate.u && computation.A==\"CM\"){\n    population$info$u_hat[[length(population$info$u_hat)+1]] <- u_hat\n    population$info$u_hat_single[[length(population$info$u_hat)]] <- list()\n    for(bven in 1:ncol(u_hat)){\n      population$info$u_hat_single[[length(population$info$u_hat)]][[bven]] <- cbind(u_hat[1:nrow(Zt),bven],u_hat[1:nrow(Zt)+ nrow(Zt),bven],u_hat[1:nrow(Zt)+2*nrow(Zt),bven])\n    }\n  }\n  if(gwas.u){\n    if(sum(is.na(gwas_hat)>0)){\n      gwas_hat[is.na(gwas_hat)] <- 0\n    }\n    population$info$gwas_hat[[length(population$info$gwas_hat)+1]] <- gwas_hat\n  }\n\n  if(store.comp.times.bve){\n    comp_times_bve[5] <- as.numeric(Sys.time())\n  }\n\n  # Bestimmung des Zuchtwertes anhand des Mittleren ZW der Kinder\n\n  #############################################################################################################\n  #############################################################################################################\n  ########################## TEST MARTINI###########################\n  if(special.comb==TRUE){\n    pos_grp <- matrix(c(length(population$breeding),1), nrow=1)\n\n    n <- sum(population$info$size[pos_grp])\n    combination <- matrix(NA, n, n)\n\n    haplo_data <- get.haplo(population, database = pos_grp, chromosomen = 1:10)\n    geno_data <- get.geno(population, database = pos_grp, chromosomen = 1:10)\n\n    if(predict.effects==TRUE){\n      if(use.effect.combination==TRUE){\n        markers_used <- c(population$info$real.bv.mult[[1]][,1] + 500 * population$info$real.bv.mult[[1]][,2] - 500, population$info$real.bv.mult[[1]][,3] + 500 * population$info$real.bv.mult[[1]][,4] - 500)\n        X_sub <- geno_data[markers_used, -(1:2)]\n        p <- (nrow(population$info$real.bv.mult[[1]]))\n        temp1 <- 0\n        Z <- matrix(NA, ncol=n, nrow=p*9)\n        for(index in 1:(nrow(population$info$real.bv.mult[[1]]))){\n          Z1 <- rbind((X_sub[index,]==0)*(X_sub[index+p,]==0), (X_sub[index,]==0)*(X_sub[index+p,]==1),(X_sub[index,]==0)*(X_sub[index+p,]==2),\n                      (X_sub[index,]==1)*(X_sub[index+p,]==0), (X_sub[index,]==1)*(X_sub[index+p,]==1),(X_sub[index,]==1)*(X_sub[index+p,]==2),\n                      (X_sub[index,]==2)*(X_sub[index+p,]==0), (X_sub[index,]==2)*(X_sub[index+p,]==1),(X_sub[index,]==2)*(X_sub[index+p,]==2))\n          Z[1:9+9*temp1,] <- Z1\n          temp1 <- temp1+1\n\n        }\n        if(mean(population$breeding[[length(population$breeding)]][[9]][1,])!=0){\n          y <- population$breeding[[length(population$breeding)]][[9]][1,]\n        } else{\n          y <- population$breeding[[length(population$breeding)]][[7]][1,]\n        }\n\n\n#        A_BGLR <- tcrossprod(Z) / ncol(Z)\n#        ETA <- list(list(K=A_BGLR, model='RKHS'))\n#        fm_BGLR <- BGLR(y=y, ETA=ETA, verbose=BGLR.print)\n#        u_hat <-  fm_BGLR$yHat - y\n#        effects <- crossprod(Z,solve(A_BGLR,u_hat))\n\n        effects <- epi(y, t(Z))\n#        model <- rq.fit.lasso(Z,y, lambda = 10)\n#        effects <- model$coefficients\n        real.effect.mult  <- cbind(population$info$real.bv.mult[[1]][,1:4] , matrix(effects, ncol=9, byrow=TRUE))\n#        cor(as.numeric(real.effect.mult[,5:13]), as.numeric(population$info$real.bv.mult[[1]][,5:13]))\n        real.effect.add <- NULL\n      } else{\n        if(use.effect.markers==TRUE){\n          markers_used <- c(population$info$real.bv.mult[[1]][,1] + 500 * population$info$real.bv.mult[[1]][,2] - 500, population$info$real.bv.mult[[1]][,3] + 500 * population$info$real.bv.mult[[1]][,4] - 500)\n        } else{\n          markers_used <- 1:(nrow(geno_data)/SNP.density) * SNP.density\n        }\n\n        X_sub <- geno_data[markers_used, -(1:2)]\n        Z <- matrix(NA, ncol=ncol(X_sub), nrow=9*(nrow(X_sub))*(nrow(X_sub)+1)/2)\n        temp1 <- 0\n        for(index in 1:nrow(X_sub)){\n          for(index2 in index:nrow(X_sub)){\n            Z1 <- rbind((X_sub[index,]==0)*(X_sub[index2,]==0), (X_sub[index,]==0)*(X_sub[index2,]==1),(X_sub[index,]==0)*(X_sub[index2,]==2),\n                        (X_sub[index,]==1)*(X_sub[index2,]==0), (X_sub[index,]==1)*(X_sub[index2,]==1),(X_sub[index,]==1)*(X_sub[index2,]==2),\n                        (X_sub[index,]==2)*(X_sub[index2,]==0), (X_sub[index,]==2)*(X_sub[index2,]==1),(X_sub[index,]==2)*(X_sub[index2,]==2))\n            Z[1:9+9*temp1,] <- Z1\n            temp1 <- temp1+1\n          }\n        }\n        #\n\n        Z <- t(Z)\n        if(mean(population$breeding[[length(population$breeding)]][[9]][1,])!=0){\n          y <- population$breeding[[length(population$breeding)]][[9]][1,]\n        } else{\n          y <- population$breeding[[length(population$breeding)]][[7]][1,]\n        }\n        effects <- epi(y, Z)\n\n\n        pos <- cbind((markers_used-1)%%500+1, (markers_used - (markers_used-1)%%500 -1)/500 +1)\n        tz <- which(matrix(0, ncol=nrow(pos), nrow=nrow(pos))==0, arr.ind = TRUE)\n        tz <- tz[tz[,1]<=tz[,2],]\n\n        real.effect.mult  <- cbind(pos[tz[,1],1:2], pos[tz[,2],1:2], matrix(effects, ncol=9, byrow=TRUE))\n        real.effect.add <- NULL\n      }\n    } else{\n      real.effect.add <- population$info$real.bv.add[[1]]\n      real.effect.mult <- population$info$real.bv.mult[[1]]\n    }\n\n    p <- nrow(real.effect.mult)\n\n\n    position0 <- real.effect.add[,1]+ cumsum(c(0,population$info$snp))[real.effect.add[,2]]\n    position1 <- real.effect.mult[,1]+ cumsum(c(0,population$info$snp))[real.effect.mult[,2]]\n    position2 <- real.effect.mult[,3]+ cumsum(c(0,population$info$snp))[real.effect.mult[,4]]\n\n    positions <- numeric(length(position1)*2)\n    positions[1:length(position1)*2-1] <- position1\n    positions[1:length(position2)*2] <- position2\n\n    geno_data0 <- geno_data[position0, -(1:2)]\n    haplo_data <- haplo_data[positions,-(1:2)]\n    geno_data <- geno_data[positions,-(1:2)]\n#    haplo_data <- haplo_data[c(position1, position2),-(1:2)]\n#    geno_data <- geno_data[c(position1, position2),-(1:2)]\n\n    storage.mode(haplo_data) <- \"numeric\"\n    storage.mode(geno_data) <- \"numeric\"\n    storage.mode(geno_data0) <- \"numeric\"\n\n    same_chromo_effects <- which(real.effect.mult[,2]==real.effect.mult[,4])\n    non_same_chromo_effects <- which(real.effect.mult[,2]!= real.effect.mult[,4])\n\n    if(length(p)==0){\n      p <- 0\n    }\n    effect_prob <- matrix(0, nrow= 4 * n, ncol= p)\n\n    for(index in non_same_chromo_effects){\n#      p1 <- geno_data[index*2-1,]/2\n#      p2 <- geno_data[index*2,]/2\n#      effect_prob[,index] <- c((1-p1)*(1-p2), (1-p1)*(p2), p1 * (1-p2), p1*p2)\n      p1 <- geno_data[index*2-1,]\n      p2 <- geno_data[index*2,]\n      effect_prob[,index] <- c((p1==0)*(p2==0) + 0.5*(p1==1)*(p2==0)+ 0.5*(p1==0)*(p2==1)+ 0.25*(p1==1)*(p2==1),\n                               (p1==0)*(p2==2) + 0.5*(p1==0)*(p2==1)+ 0.5*(p1==1)*(p2==2)+ 0.25*(p1==1)*(p2==1),\n                               (p1==2)*(p2==0) + 0.5*(p1==1)*(p2==0)+ 0.5*(p1==2)*(p2==1)+ 0.25*(p1==1)*(p2==1),\n                               (p1==2)*(p2==2) + 0.5*(p1==1)*(p2==2)+ 0.5*(p1==2)*(p2==1)+ 0.25*(p1==1)*(p2==1))\n    }\n\n\n    switch <- 1:(2*n)\n    switch[1:n*2] <- switch[1:n*2]-1\n    switch[1:n*2-1] <- switch[1:n*2-1]+1\n    for(index in same_chromo_effects){\n      distanz <- abs(population$info$snp.position[position1[index]] - population$info$snp.position[position2[index]])\n      ab <- sinh(distanz) * exp(-distanz) * 0.5\n      aa <- 0.5 - ab\n\n      aa_real <- paste(haplo_data[index*2-1,], haplo_data[index*2,], sep=\"\")\n      r00 <- round(which(aa_real==\"00\")/2+0.01)\n      r01 <- round(which(aa_real==\"01\")/2+0.01)\n      r10 <- round(which(aa_real==\"10\")/2+0.01)\n      r11 <- round(which(aa_real==\"11\")/2+0.01)\n      if(length(r00)>0){\n        dubs00 <- r00[duplicated(r00)]\n        effect_prob[r00,index] <- effect_prob[r00,index] + aa\n        effect_prob[dubs00,index] <- effect_prob[dubs00,index] + aa\n      }\n      if(length(r01)>0){\n        dubs01 <- r01[duplicated(r01)]\n        effect_prob[r01+n,index] <- effect_prob[r01+n,index] + aa\n        effect_prob[dubs01+n,index] <- effect_prob[dubs01+n,index] + aa\n      }\n      if(length(r10)>0){\n        dubs10 <- r10[duplicated(r10)]\n        effect_prob[r10+2*n,index] <- effect_prob[r10+2*n,index] + aa\n        effect_prob[dubs10+2*n,index] <- effect_prob[dubs10+2*n,index] + aa\n      }\n      if(length(r11)>0){\n        dubs11 <- r11[duplicated(r11)]\n        effect_prob[r11+3*n,index] <- effect_prob[r11+3*n,index] + aa\n        effect_prob[dubs11+3*n,index] <- effect_prob[dubs11+3*n,index] + aa\n      }\n\n\n      ab_real <- paste(haplo_data[index*2-1,], haplo_data[index*2,switch], sep=\"\")\n\n\n      r00 <- round(which(ab_real==\"00\")/2+0.01)\n      r01 <- round(which(ab_real==\"01\")/2+0.01)\n      r10 <- round(which(ab_real==\"10\")/2+0.01)\n      r11 <- round(which(ab_real==\"11\")/2+0.01)\n      if(length(r00)>0){\n        dubs00 <- r00[duplicated(r00)]\n        effect_prob[r00,index] <- effect_prob[r00,index] + ab\n        effect_prob[dubs00,index] <- effect_prob[dubs00,index] + ab\n      }\n      if(length(r01)>0){\n        dubs01 <- r01[duplicated(r01)]\n        effect_prob[r01 +n,index] <- effect_prob[r01+n,index] + ab\n        effect_prob[dubs01+n,index] <- effect_prob[dubs01+n,index] + ab\n      }\n      if(length(r10)>0){\n        dubs10 <- r10[duplicated(r10)]\n        effect_prob[r10+2*n,index] <- effect_prob[r10+2*n,index] + ab\n        effect_prob[dubs10+2*n,index] <- effect_prob[dubs10+2*n,index] + ab\n      }\n      if(length(r11)>0){\n        dubs11 <- r11[duplicated(r11)]\n        effect_prob[r11+3*n,index] <- effect_prob[r11+3*n,index] + ab\n        effect_prob[dubs11+3*n,index] <- effect_prob[dubs11+3*n,index] + ab\n      }\n\n    }\n\n\n\n    teffect_prob <- t(effect_prob)\n    for(index2 in 1:n){\n      if(index2%%25==0) print(index2)\n      if(index2==1){\n        combination[1:index2, index2] <- combination[index2, 1:index2] <-sum(real.effect.mult[,5]* teffect_prob[,1:index2] * teffect_prob[,index2] + # 00 Effekt\n                                                                                   real.effect.mult[,6]* (teffect_prob[,1:index2+n] * teffect_prob[,index2]+teffect_prob[,1:index2] * teffect_prob[,index2+n]) + # 01 Effekt\n                                                                                   real.effect.mult[,7]* (teffect_prob[,1:index2+n] * teffect_prob[,index2+n]) + # 02 Effekt\n                                                                                   real.effect.mult[,8]* (teffect_prob[,1:index2+2*n] * teffect_prob[,index2]+teffect_prob[,1:index2] * teffect_prob[,index2+2*n]) + # 10 Effekt\n                                                                                   real.effect.mult[,9]* (teffect_prob[,1:index2+3*n] * teffect_prob[,index2]+teffect_prob[,1:index2] * teffect_prob[,index2+3*n]+teffect_prob[,1:index2+n] * teffect_prob[,index2+2*n]+teffect_prob[,1:index2+2*n] * teffect_prob[,index2+n]) + # 11 Effekt\n                                                                                   real.effect.mult[,10]* (teffect_prob[,1:index2+3*n] * teffect_prob[,index2+n]+teffect_prob[,1:index2+n] * teffect_prob[,index2+3*n]) + # 12 Effekt\n                                                                                   real.effect.mult[,11]* (teffect_prob[,1:index2+2*n] * teffect_prob[,index2+2*n]) + # 20 Effekt\n                                                                                   real.effect.mult[,12]* (teffect_prob[,1:index2+3*n] * teffect_prob[,index2+2*n]+teffect_prob[,1:index2+2*n] * teffect_prob[,index2+3*n]) + # 21 Effekt\n                                                                                   real.effect.mult[,13]* (teffect_prob[,1:index2+3*n] * teffect_prob[,index2+3*n]))  # 22 Effekt\n\n      } else{\n        combination[1:index2, index2] <- combination[index2, 1:index2] <-colSums(real.effect.mult[,5]* teffect_prob[,1:index2] * teffect_prob[,index2] + # 00 Effekt\n                                                                                   real.effect.mult[,6]* (teffect_prob[,1:index2+n] * teffect_prob[,index2]+teffect_prob[,1:index2] * teffect_prob[,index2+n]) + # 01 Effekt\n                                                                                   real.effect.mult[,7]* (teffect_prob[,1:index2+n] * teffect_prob[,index2+n]) + # 02 Effekt\n                                                                                   real.effect.mult[,8]* (teffect_prob[,1:index2+2*n] * teffect_prob[,index2]+teffect_prob[,1:index2] * teffect_prob[,index2+2*n]) + # 10 Effekt\n                                                                                   real.effect.mult[,9]* (teffect_prob[,1:index2+3*n] * teffect_prob[,index2]+teffect_prob[,1:index2] * teffect_prob[,index2+3*n]+teffect_prob[,1:index2+n] * teffect_prob[,index2+2*n]+teffect_prob[,1:index2+2*n] * teffect_prob[,index2+n]) + # 11 Effekt\n                                                                                   real.effect.mult[,10]* (teffect_prob[,1:index2+3*n] * teffect_prob[,index2+n]+teffect_prob[,1:index2+n] * teffect_prob[,index2+3*n]) + # 12 Effekt\n                                                                                   real.effect.mult[,11]* (teffect_prob[,1:index2+2*n] * teffect_prob[,index2+2*n]) + # 20 Effekt\n                                                                                   real.effect.mult[,12]* (teffect_prob[,1:index2+3*n] * teffect_prob[,index2+2*n]+teffect_prob[,1:index2+2*n] * teffect_prob[,index2+3*n]) + # 21 Effekt\n                                                                                   real.effect.mult[,13]* (teffect_prob[,1:index2+3*n] * teffect_prob[,index2+3*n]))  # 22 Effekt\n\n      }\n    }\n\n\n    #removes <- 1:500*500-499:0\n    #plot(combination0[-removes], combination1[-removes])\n    #cor(combination[-removes], combination2[-removes])\n\n    if(max.auswahl<1000){\n      auswahl <- which(combination>=(-999), arr.ind=TRUE)\n      values <- combination[auswahl]\n      removes <- (auswahl[,1]<auswahl[,2])*1:length(values)\n      values <- values[removes]\n      auswahl <- auswahl[removes,]\n      ordering <- sort(values, index.return=TRUE, decreasing = TRUE)\n      auswahl <- auswahl[ordering$ix,]\n      counts <- numeric(n)\n      choosen <- numeric(n)\n      row <- 1\n      activ <- 1\n      while(sum(counts)<(2*n)){\n        if(counts[auswahl[row,1]]<max.auswahl && counts[auswahl[row,2]]<max.auswahl){\n          counts[auswahl[row,1]] <- counts[auswahl[row,1]] +1\n          counts[auswahl[row,2]] <- counts[auswahl[row,2]] +1\n          choosen[activ] <- row\n          activ <- activ +1\n        }\n        row <- row +1\n      }\n      auswahl <- auswahl[choosen,]\n    } else{\n      cutoff <- sort(combination, decreasing = TRUE)[n*4+1]\n      auswahl <- which(combination>=cutoff, arr.ind = TRUE)\n      auswahl <- auswahl[auswahl[,1]<auswahl[,2],]\n      values <- combination[auswahl]\n\n      ordering <- sort(values, index.return=TRUE, decreasing = TRUE)\n      auswahl <- auswahl[ordering$ix[1:n],]\n    }\n\n    animals <- c(auswahl[,1], auswahl[,2])\n\n    animals1 <- unique(animals)\n    count <- numeric(length(animals1))\n    for(index in 1:length(animals1)){\n      count[index] <- sum(animals==animals1[index])\n    }\n    fixed.breeding <- cbind(length(population$breeding), 1, auswahl[,1], length(population$breeding), 1, auswahl[,2], 0)\n    population$breeding[[length(population$breeding)]][[11]] <- rbind(animals1, count)\n    population$breeding[[length(population$breeding)]][[12]] <- ordering$x[1:n]\n  }\n\n  if(special.comb.add==TRUE){\n    add_bv <- population$breeding[[length(population$breeding)]][[3]][1,]\n    n <- length(add_bv)\n    combination <- matrix(NA, n, n)\n    for(index in 1:n){\n      for(index2 in index:n){\n        combination[index, index2]  <- add_bv[index] + add_bv[index2]\n      }\n    }\n    if(max.auswahl<500){\n      auswahl <- which(combination>=(-999), arr.ind=TRUE)\n      values <- combination[auswahl]\n      removes <- (auswahl[,1]<auswahl[,2])*1:length(values)\n      values <- values[removes]\n      auswahl <- auswahl[removes,]\n      ordering <- sort(values, index.return=TRUE, decreasing = TRUE)\n      auswahl <- auswahl[ordering$ix,]\n      counts <- numeric(n)\n      choosen <- numeric(n)\n      row <- 1\n      activ <- 1\n      while(sum(counts)<(2*n)){\n        if(counts[auswahl[row,1]]<max.auswahl && counts[auswahl[row,2]]<max.auswahl){\n          counts[auswahl[row,1]] <- counts[auswahl[row,1]] +1\n          counts[auswahl[row,2]] <- counts[auswahl[row,2]] +1\n          choosen[activ] <- row\n          activ <- activ +1\n        }\n        row <- row +1\n      }\n      auswahl <- auswahl[choosen,]\n    } else{\n      cutoff <- sort(combination, decreasing = TRUE)[n*4+1]\n      auswahl <- which(combination>=cutoff, arr.ind = TRUE)\n      auswahl <- auswahl[auswahl[,1]<auswahl[,2],]\n      values <- combination[auswahl]\n\n      ordering <- sort(values, index.return=TRUE, decreasing = TRUE)\n      auswahl <- auswahl[ordering$ix[1:n],]\n    }\n\n    animals <- c(auswahl[,1], auswahl[,2])\n\n    animals1 <- unique(animals)\n    count <- numeric(length(animals1))\n    for(index in 1:length(animals1)){\n      count[index] <- sum(animals==animals1[index])\n    }\n    fixed.breeding <- cbind(length(population$breeding), 1, auswahl[,1], length(population$breeding), 1, auswahl[,2], 0)\n    population$breeding[[length(population$breeding)]][[11]] <- rbind(animals1, count)\n    population$breeding[[length(population$breeding)]][[12]] <- ordering$x[1:n]\n\n  }\n  ######################### ENDE TEST MARTINI ######################\n  #############################################################################################################\n  #############################################################################################################\n  #############################################################################################################\n\n  if(gene.editing){\n    if(estimate.u){\n      effect_order<- sort(abs(population$info$u_hat[[length(population$info$u_hat)]]), index.return=TRUE, decreasing=TRUE)$ix\n      direction <- (population$info$u_hat[[length(population$info$u_hat)]] < 0)\n      distance_actual <- integer(length(effect_order))\n      for(index in 1:length(effect_order)){\n        distance_actual[index] <- min(abs(effect_order[index]-population$info$effect_p))\n      }\n      if(length(population$info$editing_info)==0){\n        population$info$editing_info <- list()\n      }\n      population$info$editing_info[[length(population$info$editing_info)+1]] <- cbind(effect_order, direction[effect_order], distance_actual, deparse.level = 0)\n    }\n    if(gwas.u){\n      effect_order <- sort(abs(population$info$gwas_hat[[length(population$info$gwas_hat)]]), index.return=TRUE, decreasing=TRUE)$ix\n      direction <- (population$info$gwas_hat[[length(population$info$gwas_hat)]] <0 )\n      distance_actual <- integer(length(effect_order))\n      for(index in 1:length(effect_order)){\n        distance_actual[index] <- min(abs(effect_order[index]-population$info$effect_p))\n      }\n      if(length(population$info$editing_info)==0){\n        population$info$editing_info <- list()\n      }\n      population$info$editing_info[[length(population$info$editing_info)+1]] <- cbind(effect_order, direction[effect_order], distance_actual, deparse.level = 0)\n    }\n  }\n\n\n\n  if(store.comp.times){\n    comp_times[5] <- as.numeric(Sys.time())\n  }\n\n  # Bestimmung der fuer die Zucht verwendeten Tiere - Selektion\n  selection.size.m <- round(used.generations.m * selection.size[1])\n  selection.size.w <- round(used.generations.w * selection.size[2])\n  if(sum(selection.size.m)!=selection.size[1]) selection.size.m[length(selection.size.m)] <- selection.size[1] - sum(selection.size.m[-length(selection.size.m)])\n  if(sum(selection.size.w)!=selection.size[2]) selection.size.w[length(selection.size.w)] <- selection.size[2] - sum(selection.size.w[-length(selection.size.w)])\n\n  best.m <- matrix(0, nrow=selection.size[1],ncol=5)\n  best.w <- matrix(0, nrow=selection.size[2],ncol=5)\n  best_from_group_B <- c(best1.from.group_B, best2.from.group_B)\n  best_from_group <- list(best1.from.group, best2.from.group)\n  best <- list(best.m,best.w)\n\n\n\n\n  if(length(fixed.breeding)==0){\n    selection.size.gender <- list(selection.size.m, selection.size.w)\n    selection.gender <- list(selection.m, selection.w)\n    for(gender in 1:2){\n      if(best_from_group_B[gender]==FALSE){\n        n.curr <- 1\n        for(index in (1:current.gen)[selection.size.gender[[gender]]>0]){\n\n          n.add <- selection.size.gender[[gender]][index]\n          n.animals <- sum(rep(population$breeding[[index]][[4+gender]],length(migration.level[[gender]]))==rep(migration.level[[gender]],each=length(population$breeding[[index]][[4+gender]])))\n          relevant.animals<- (rep(1:length(population$breeding[[index]][[4+gender]]),length(migration.level[[gender]])))[rep(population$breeding[[index]][[gender+4]],length(migration.level[[gender]]))==rep(migration.level[[gender]],each=length(population$breeding[[index]][[gender+4]]))] #Diese 1-2 5-6 in Weiblich\n          if(selection.gender[[gender]][index]==\"random\"){\n\n            chosen.animals <- relevant.animals[sample(1:n.animals, selection.size.gender[[gender]][index])]\n            best[[gender]][n.curr:(n.add +n.curr-1),1] <- index\n            best[[gender]][n.curr:(n.add +n.curr-1),2] <- gender\n            best[[gender]][n.curr:(n.add +n.curr-1),3] <- chosen.animals\n\n            if(population$info$bve.nr==1){\n              if(best.selection.criteria[[gender]]==\"bv\"){\n                breeding.values <- population$breeding[[index]][[gender+6]][1,chosen.animals]\n              } else if(best.selection.criteria[[gender]]==\"pheno\"){\n                breeding.values <- population$breeding[[index]][[gender+8]][1,chosen.animals]\n              } else{\n                breeding.values <- population$breeding[[index]][[gender+2]][1,chosen.animals]\n              }\n              best[[gender]][n.curr:(n.add +n.curr-1),5] <- breeding.values\n            } else if(population$info$bve.nr>1){\n\n              if(multiple.bve==\"add\"){\n                if(best.selection.criteria[[gender]]==\"bv\"){\n                  breeding.values <- population$breeding[[index]][[gender+6]][,chosen.animals]\n                } else if(best.selection.criteria[[gender]]==\"pheno\"){\n                  breeding.values <- population$breeding[[index]][[gender+8]][,chosen.animals]\n                } else{\n                  breeding.values <- population$breeding[[index]][[gender+2]][,chosen.animals]\n                }\n\n                if(multiple.bve.scale){\n                  for(bven in 1:nrow(breeding.values)){\n                    breeding.values[bven,] <- breeding.values[bven,] - mean(breeding.values[bven,])\n                    sd <- sd(breeding.values[bven,])\n                    if(sd>0){\n                      breeding.values[bven,] <- breeding.values[bven,] / sd\n                    }\n                  }\n                }\n                bve.sum <- colSums(breeding.values * multiple.bve.weights)\n              } else if(multiple.bve==\"ranking\"){\n                if(best.selection.criteria[[gender]]==\"bv\"){\n                  ranking <- population$breeding[[index]][[gender+6]][,chosen.animals]\n                } else if(best.selection.criteria[[gender]]==\"pheno\"){\n                  ranking <- population$breeding[[index]][[gender+8]][,chosen.animals]\n                } else{\n                  ranking <- population$breeding[[index]][[gender+2]][,chosen.animals]\n                }\n                for(bven in 1:population$info$bve.nr){\n                  order <- sort(ranking[bven,], index.return=TRUE, decreasing=selection.critera[gender])$ix\n                  ranking[bven,order] <- length(order):1\n                }\n                bve.sum <- colSums(ranking*multiple.bve.weights)\n              }\n\n\n              best[[gender]][n.curr:(n.add +n.curr-1),5] <- bve.sum\n            }\n            n.curr <- n.curr + n.add\n          }\n          if(selection.gender[[gender]][index]==\"function\"){\n            if(new.selection.calculation || sum((population$breeding[[index]][[gender+2]]))==0){\n\n\n              n.functions <- nrow(selection.function.matrix)\n              if(length(n.functions)>0){\n                if(new.selection.calculation){\n                  population$breeding[[index]][[gender+2]] <- matrix(0, ncol=length(population$breeding[[index]][[gender+2]]))\n                }\n                for(index3 in 1:n.functions){\n                  selection.function <- selection.function.matrix[index3,]\n\n                  for(index2 in 1:n.animals){\n                    current.animal <- population$breeding[[index]][[gender]][[relevant.animals[index2]]] # Diese Eins zu 2 in Weiblich\n                    chromosom.position <- sum(population$info$length[0:(selection.function[1]-1)]) +\n                      population$info$position[[selection.function[1]]][selection.function[2]]\n                    snp.number <- sum(population$info$snp[0:(selection.function[1]-1)]) +selection.function[2]\n                    position1 <- which(current.animal[[1]]>chromosom.position)[1]-1\n                    position2 <- which(current.animal[[2]]>chromosom.position)[1]-1\n\n                    ursprung1 <- decodeOriginsU(current.animal[[5]],position1)\n                    ursprung1[1] <- population$info$origin_gen[ursprung1[1]]\n                    ursprung2 <- decodeOriginsU(current.animal[[6]],position2)\n                    ursprung2[1] <- population$info$origin_gen[ursprung2[1]]\n\n                    gen1 <- population$breeding[[ursprung1[1]]][[ursprung1[2]]][[ursprung1[3]]][[8+ursprung1[4]]][snp.number]\n                    gen2 <- population$breeding[[ursprung2[1]]][[ursprung2[2]]][[ursprung2[3]]][[8+ursprung2[4]]][snp.number]\n\n                    #mutationen\n                    gen1 <- gen1 + sum(current.animal[[3]]==chromosom.position)\n                    gen2 <- gen2 + sum(current.animal[[4]]==chromosom.position)\n                    gen1 <- gen1 - (gen1==2)*2\n                    gen2 <- gen2 - (gen2==2)*2\n\n\n                    population$breeding[[index]][[gender+2]][1,relevant.animals[index2]] <- population$breeding[[index]][[gender+2]][1,relevant.animals[index2]]+ # Diese 3er werden zu 4 in Weiblich\n                      stats::rnorm(1,selection.function[3+gen1+gen2], selection.function[6])\n                  }\n                }\n              }\n\n            }\n            if(population$info$bve.nr==1){\n              chosen.animals <- sort(population$breeding[[index]][[gender+2]][relevant.animals], index.return=TRUE, decreasing=selection.critera[gender])$ix # Diese 3er werden zu 4 in Weiblich\n              best[[gender]][n.curr:(n.add +n.curr-1),1] <- index\n              best[[gender]][n.curr:(n.add +n.curr-1),2] <- gender\n              best[[gender]][n.curr:(n.add +n.curr-1),3] <- relevant.animals[chosen.animals[1:selection.size.gender[[gender]][index]]]\n              chosen.animals.value <- sort(population$breeding[[index]][[gender+2]][1,relevant.animals], index.return=TRUE, decreasing=selection.critera[gender])$x[1:selection.size.gender[[gender]][index]] # Diese 3er werden zu 4 in Weiblich\n              best[[gender]][n.curr:(n.add +n.curr-1),4] <- chosen.animals.value\n              chosen.animals.value_true <- sort(population$breeding[[index]][[gender+6]][1,relevant.animals], index.return=TRUE, decreasing=selection.critera[gender])$x[1:selection.size.gender[[gender]][index]] # Diese 3er werden zu 4 in Weiblich\n              best[[gender]][n.curr:(n.add +n.curr-1),5] <- chosen.animals.value_true\n\n            } else if(population$info$bve.nr>1){\n              if(multiple.bve==\"add\"){\n                breeding.values <- population$breeding[[index]][[gender+2]][,relevant.animals]\n                if(multiple.bve.scale){\n                  for(bven in 1:nrow(breeding.values)){\n                    breeding.values[bven,] <- breeding.values[bven,] - mean(breeding.values[bven,])\n                    sd <- sd(breeding.values[bven,])\n                    if(sd>0){\n                      breeding.values[bven,] <- breeding.values[bven,] / sd\n                    }\n                  }\n                }\n\n\n                bve.sum <- colSums(breeding.values * multiple.bve.weights)\n              } else if(multiple.bve==\"ranking\"){\n                ranking <- population$breeding[[index]][[gender+2]][,relevant.animals]\n                for(bven in 1:population$info$bve.nr){\n                  order <- sort(ranking[bven,], index.return=TRUE, decreasing=selection.critera[gender])$ix\n                  ranking[bven,order] <- length(order):1\n                }\n                bve.sum <- colSums(ranking*multiple.bve.weights)\n              }\n\n              if(multiple.bve==\"add\"){\n                if(best.selection.criteria[[gender]]==\"bv\"){\n                  breeding.values <- population$breeding[[index]][[gender+6]][,relevant.animals]\n                } else if(best.selection.criteria[[gender]]==\"pheno\"){\n                  breeding.values <- population$breeding[[index]][[gender+8]][,relevant.animals]\n                } else{\n                  breeding.values <- population$breeding[[index]][[gender+2]][,relevant.animals]\n                }\n                if(multiple.bve.scale){\n                  for(bven in 1:nrow(breeding.values)){\n                    breeding.values[bven,] <- breeding.values[bven,] - mean(breeding.values[bven,])\n                    sd <- sd(breeding.values[bven,])\n                    if(sd>0){\n                      breeding.values[bven,] <- breeding.values[bven,] / sd\n                    }\n                  }\n                }\n\n\n                bve.sum_true <- colSums(breeding.values * multiple.bve.weights)\n              } else if(multiple.bve==\"ranking\"){\n                if(best.selection.criteria[[gender]]==\"bv\"){\n                  ranking <- population$breeding[[index]][[gender+6]][,relevant.animals]\n                } else if(best.selection.criteria[[gender]]==\"pheno\"){\n                  ranking <- population$breeding[[index]][[gender+8]][,relevant.animals]\n                } else{\n                  ranking <- population$breeding[[index]][[gender+2]][,relevant.animals]\n                }\n                for(bven in 1:population$info$bve.nr){\n                  order <- sort(ranking[bven,], index.return=TRUE, decreasing=selection.critera[gender])$ix\n                  ranking[bven,order] <- length(order):1\n                }\n                bve.sum_true <- colSums(ranking*multiple.bve.weights)\n              }\n\n              chosen.animals <- sort(bve.sum, index.return=TRUE, decreasing=selection.critera[gender])$ix # Diese 3er werden zu 4 in Weiblich\n              best[[gender]][n.curr:(n.add +n.curr-1),1] <- index\n              best[[gender]][n.curr:(n.add +n.curr-1),2] <- gender\n              best[[gender]][n.curr:(n.add +n.curr-1),3] <- relevant.animals[chosen.animals[1:selection.size.gender[[gender]][index]]]\n              chosen.animals.value <- sort(bve.sum, index.return=TRUE, decreasing=selection.critera[gender])$x[1:selection.size.gender[[gender]][index]] # Diese 3er werden zu 4 in Weiblich\n              best[[gender]][n.curr:(n.add +n.curr-1),4] <- chosen.animals.value\n              chosen.animals.value_true <- sort(bve.sum_true, index.return=TRUE, decreasing=selection.critera[gender])$x[1:selection.size.gender[[gender]][index]] # Diese 3er werden zu 4 in Weiblich\n              best[[gender]][n.curr:(n.add +n.curr-1),5] <- chosen.animals.value_true\n\n\n            }\n\n            n.curr <- n.curr + n.add\n          }\n        }\n      } else{\n        ### CODE ZUR AUSWAHL DER BESTEN INDIVIDUEN AUS GRUPPEN\n\n        #\n        print(\"This code currently doesn't support relative selection along TRUE breeding value\")\n        activ_groups <- best_from_group[[gender]]\n        possible_animals <- NULL\n        for(index in 1:nrow(activ_groups)){\n          possible_animals <- rbind(possible_animals, cbind(activ_groups[index,1], activ_groups[index,2], 1:population$info$size[activ_groups[index,1], activ_groups[index,2]], population$breeding[[activ_groups[index,1]]][[4+activ_groups[index,2]]]))\n        }\n        # entferne falsche migration _ level\n        relevant.animals <- rep(possible_animals[,4], length(migration.level[[gender]])) == rep(migration.level[[gender]],each=nrow(possible_animals))\n        relevant.animals <- relevant.animals * 1:nrow(possible_animals)\n        possible_animals <- rbind(NULL, possible_animals[unique(relevant.animals),])\n        n.animals <- nrow(possible_animals)\n\n        if(selection.gender[[gender]][index]==\"random\"){\n            chosen.animals <- relevant.animals[sample(1:n.animals, selection.size[gender])]\n            best[[gender]][,1:3] <- possible_animals[chosen.animals,1:3]\n        }\n        if(selection.gender[[gender]][index]==\"function\"){\n          if(population$info$bve.nr==1){\n            import.bv <- numeric(nrow(possible_animals))\n            for(index in 1:nrow(possible_animals)){\n              import.bv[index] <- population$breeding[[possible_animals[index,1]]][[possible_animals[index,2]+2]][,possible_animals[index,3]]\n            }\n\n            chosen.animals <- sort(import.bv, index.return=TRUE, decreasing=selection.critera[gender])$ix[1:selection.size[gender]] # Diese 3er werden zu 4 in Weiblich\n            best[[gender]][,1:4] <- cbind(possible_animals[chosen.animals, 1], possible_animals[chosen.animals, 2], possible_animals[chosen.animals, 3], import.bv[chosen.animals])\n\n          } else{\n            if(multiple.bve==\"add\"){\n              breeding.values <- matrix(0, ncol=nrow(possible_animals), nrow= population$info$bve.nr)\n              for(index in 1:nrow(possible_animals)){\n                breeding.values[,index] <- population$breeding[[possible_animals[index,1]]][[possible_animals[index,2]+2]][,possible_animals[index,3]]\n              }\n              if(multiple.bve.scale){\n                for(bven in 1:nrow(breeding.values)){\n                  breeding.values[bven,] <- breeding.values[bven,] - mean(breeding.values[bven,])\n                  sd <- sd(breeding.values[bven,])\n                  if(sd>0){\n                    breeding.values[bven,] <- breeding.values[bven,] / sd\n                  }\n                }\n              }\n\n\n              bve.sum <- colSums(breeding.values * multiple.bve.weights)\n            } else if(multiple.bve==\"ranking\"){\n              breeding.values <- matrix(0, ncol=nrow(possible_animals), nrow= population$info$bve.nr)\n              for(index in 1:nrow(possible_animals)){\n                breeding.values[,index] <- population$breeding[[possible_animals[index,1]]][[possible_animals[index,2]+2]][,possible_animals[index,3]]\n              }\n              ranking <- matrix(0, ncol=nrow(possible_animals), nrow= population$info$bve.nr)\n              for(bven in 1:population$info$bve.nr){\n                order <- sort(breeding.values[bven,], index.return=TRUE, decreasing=selection.critera[gender])$ix\n                ranking[bven,order] <- length(order):1\n              }\n              bve.sum <- colSums(ranking*multiple.bve.weights)\n            }\n\n            chosen.animals <- sort(bve.sum, index.return=TRUE, decreasing=selection.critera[gender])$ix[1:selection.size.gender] # Diese 3er werden zu 4 in Weiblich\n            best[[gender]][,1:4] <- cbind(possible_animals[chosen.animals,1:3], chosen.animals.value[chosen.animals])\n\n          }\n        }\n      }\n\n    }\n    for(gender in 1:2){\n      if(nrow(best[[gender]])>1){\n        best[[gender]] <- best[[gender]][sort(best[[gender]][,4], index.return=TRUE, decreasing = selection.critera[gender])$ix,]\n      }\n    }\n\n  '#\n  Dont see the reason for this part of the code!\n    if(population$info$bve.calc>1 && population$info$bv.random[population$info$bve.calc] ){\n      #mu1 <- numeric(population$info$bve.calc-1)\n      saves_bv <- matrix(0, ncol=sum(selection.size), nrow=(population$info$bve.calc-1))\n      if(selection.size[1]>0){\n        for(index in 1:selection.size[1]){\n          saves_bv[,index] <- population$breeding[[best[[1]][index,1]]][[best[[1]][index,2]+6]][1:(population$info$bve.calc-1), best[[1]][index,3]]\n        }\n      }\n      if(selection.size[2]>0){\n        for(index in 1:selection.size[2]){\n          saves_bv[,index+selection.size[1]] <- population$breeding[[best[[2]][index,1]]][[best[[2]][index,2]+6]][1:(population$info$bve.calc-1), best[[2]][index,3]]\n        }\n      }\n\n    }\n  '#\n    if(fixed.assignment!=FALSE){\n      nm <- nrow(best[[1]])\n      nw <- nrow(best[[2]])\n      male.rounds <- breeding.size.total / nm\n      female.rounds <- breeding.size.total / nw\n      full.m <- nm*(male.rounds - round(male.rounds - 0.5))\n      full.w <- nw*(female.rounds - round(female.rounds -0.5))\n      fixed.assignment.m <- c(rep(1:full.m,each=male.rounds-full.m/nm+1), rep((full.m+1):nm, each =male.rounds-full.m/nm))\n      fixed.assignment.w <- c(rep(1:full.w,each=female.rounds - full.w/nw +1), rep((full.w+1):nw, each =female.rounds-full.w/nw))\n      fixed.assignment.m <- fixed.assignment.m[1:breeding.size.total]\n      fixed.assignment.w <- fixed.assignment.w[1:breeding.size.total]\n      if(fixed.assignment==\"bestworst\" || fixed.assignment==\"worstbest\"){\n        fixed.assignment.w <- fixed.assignment.w[breeding.size.total:1]\n      }\n      fixed.breeding <- cbind(best[[1]][fixed.assignment.m,1:3], best[[2]][fixed.assignment.w,1:3], gender.animal)\n    }\n    if(ogc){\n      print(\"OGC NEEDS REWORK, U is set to ZERO?!\")\n      u <- 0\n      animallist <- rbind(cbind(best[[1]],1), cbind(best[[2]],2))\n      n.animals <- nrow(animallist)\n\n      Z_ogc <- array(0,dim=c(sum(population$info$snp), n.animals))\n      y_ogc <- animallist[,4]\n      Q <- cbind((animallist[,5]==1), animallist[,5]==2)\n\n      for(index in 1:n.animals){\n        Z_ogc[,index] <- colSums(compute.snps(population, animallist[index,1], animallist[index,2], animallist[index,3], import.position.calculation=import.position.calculation, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE))\n      }\n      # Verwandtschaftsmatrix:\n      if(computation.A==\"kinship\"){\n        print(\"Verwandtschaftsmatrix mit kinship bisher nicht in ogc implementiert!\")\n        #A_full <- kinship.exp(population)\n        #A <- diag(1, nrow=n.animals)\n        #for(i in 2:n.animals){\n        #  for(j in 1:(i-1)){\n        #    A[i,j] <- A[j,i] <- A_full[grid.position[i], grid.position[j]]\n        #  }\n        #}\n        #Am <- A\n      } else if(computation.A==\"vanRaden\"){\n        if(miraculix){\n          p_i <- miraculix::allele_freq(Z.code) # Noch nicht implementiert?\n          A <- miraculix::relationshipMatrix(Z.code, centered=TRUE, normalized=TRUE)\n\n        } else if(miraculix.mult){\n          p_i <- rowSums(Zt)/ncol(Zt)/2\n          Zt_miraculix <- miraculix::createSNPmatrix(Zt)\n          A <- miraculix::relationshipMatrix(Zt_miraculix, centered=TRUE, normalized=TRUE)\n        } else{\n          p_i <- rowSums(Zt)/ncol(Zt)/2\n          Ztm <- Zt - p_i * 2\n          A <- crossprod(Ztm)/ (2 * sum(p_i*(1-p_i)))\n        }\n\n      } else if(computation.A==\"CM\"){\n        #CM SCHAETZER\n        Ztm <- rbind(Zt==0, Zt==1, Zt==2)\n        A <- crossprod(Ztm) / ncol(Zt)\n      } else if(computation.A==\"CE\"){\n        Ztm <- rbind(Zt==0, Zt==1, Zt==2)\n        A <- crossprod(Ztm)\n        A <- (A^2 - 0.5*A)/(nrow(Zt)^2)\n\n      } else if(computation.A==\"non_stand\"){\n        A <- crossprod(Zt) / nrow(Zt)\n      }\n      contribution <- OGC(A, u, Q)\n\n\n\n    }\n  } else{\n    breeding.size.total <- nrow(fixed.breeding)\n    gender.animal <- fixed.breeding[,7] <- stats::rbinom(breeding.size.total, 1, fixed.breeding[,7]) +1\n    breeding.size <- c(sum(fixed.breeding[,7]==1), sum(fixed.breeding[,7]==2))\n  }\n\n  if(print.error.sources){\n    print(best)\n  }\n\n  if(gene.editing.best){\n    for(gender in (1:2)[gene.editing.best.gender]){\n      if(length(best[[gender]])>0){\n        for(index in 1:nrow(best[[gender]])){\n          activ <- best[[gender]][index,]\n          population$breeding[[activ[1]]][[activ[2]]][[activ[3]]] <- edit_animal(population, activ[1], activ[2], activ[3], nr.edits, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits)\n        }\n        for(index in 1:nrow(best[[gender]])){\n          activ <- best[[gender]][index,]\n          if(length(population$breeding[[activ[1]]][[activ[2]]][[activ[3]]])>=17){\n            population$breeding[[activ[1]]][[activ[2]]][[activ[3]]][[17]] <- c(population$breeding[[activ[1]]][[activ[2]]][[activ[3]]][[17]],population$breeding[[activ[1]]][[6+activ[2]]][,activ[3]])\n          } else{\n            population$breeding[[activ[1]]][[activ[2]]][[activ[3]]][[17]] <- population$breeding[[activ[1]]][[6+activ[2]]][,activ[3]]\n          }\n          population$breeding[[activ[1]]][[activ[2]]][[activ[3]]][[15]] <- 0\n          activ_bv <- which(population$info$bv.random[1:population$info$bve.calc]==FALSE)\n          if(length(activ_bv)>0){\n            temp_out <- calculate.bv(population, activ[1], activ[2], activ[3], activ_bv, import.position.calculation=import.position.calculation, decodeOriginsU=decodeOriginsU, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)\n            population$breeding[[activ[1]]][[6+activ[2]]][activ_bv,activ[3]] <- temp_out[[1]]\n          }\n          population$breeding[[activ[1]]][[activ[2]]][[activ[3]]][[17]] <- c(population$breeding[[activ[1]]][[activ[2]]][[activ[3]]][[17]] ,population$breeding[[activ[1]]][[6+activ[2]]][,activ[3]])\n        }\n      }\n    }\n  }\n\n  if(print.error.sources){\n    print(best)\n  }\n\n  # Gezielte Alterung\n  if(is.matrix(reduce.group)==0 && length(reduce.group)>0){\n    reduce.group <- t(reduce.group)\n  }\n  if(length(reduce.group)>0){\n    reduce.group <- reduce.group[reduce.group[,1]!=0,]\n  }\n  if(length(reduce.group)>0){\n    for(index in 1:nrow(reduce.group)){\n      activ.reduce <- reduce.group[index,]\n      group.animals <- (population$breeding[[activ.reduce[1]]][[activ.reduce[2]+4]] == activ.reduce[4])\n      n.animals <- sum(group.animals)\n      to.kill <- n.animals - activ.reduce[3]\n      animal.position <- unique(c(0,group.animals * 1:length(group.animals)))[-1]\n      if(to.kill>0){\n        if(reduce.group.selection==\"random\"){\n          death <- sample(animal.position, to.kill)\n\n        } else if(reduce.group.selection==\"selection\"){\n          if(multiple.bve==\"add\"){\n            print(population$breeding[[activ.reduce[1]]][[activ.reduce[2]+2]])\n            bve.sum <- colSums(rbind(population$breeding[[activ.reduce[1]]][[activ.reduce[2]+2]][,animal.position]*multiple.bve.weights,0))\n          } else if(multiple.bve==\"ranking\"){\n            ranking <- population$breeding[[index]][[gender+2]][,relevant.animals]\n            for(bven in 1:population$info$bve.nr){\n              order <- sort(ranking[bven,], index.return=TRUE, decreasing=selection.critera[activ.reduce[2]])$ix\n              ranking[bven,order] <- length(order):1\n            }\n            bve.sum <- colSums(ranking*multiple.bve.weights)\n          }\n          chosen.animals <- sort(bve.sum, index.return=TRUE, decreasing=selection.critera[activ.reduce[2]])$ix\n          death <- chosen.animals[(length(chosen.animals)-to.kill+1):length(chosen.animals)]\n        }\n        for(modanimal in death){\n          population$breeding[[activ.reduce[1]]][[activ.reduce[2]]][[modanimal]][[17]] <- c(population$breeding[[activ.reduce[1]]][[activ.reduce[2]+4]][modanimal], current.gen)\n          population$breeding[[activ.reduce[1]]][[activ.reduce[2]+4]][modanimal] <- 187 # Number of Death\n        }\n      }\n\n\n    }\n  }\n  if(store.comp.times){\n    comp_times[6] <- as.numeric(Sys.time())\n  }\n\n  sample_prob <- list()\n  for(gender in 1:2){\n    if(length(best[[gender]])>0){\n      if(length(best.selection.manual.ratio[[gender]])==0){\n        individual_bv <- best[[gender]][,5]\n        min_bv <- min(individual_bv)\n        max_bv <- max(individual_bv)\n        if(min_bv==max_bv){\n          sample_prob[[gender]] <- rep(1, length(individual_bv))\n        } else{\n          sample_prob[[gender]] <- (individual_bv- min_bv) / (max_bv-min_bv) * (best.selection.ratio[[gender]]-1) + 1\n        }\n      } else{\n        sample_prob[[gender]] <- best.selection.manual.ratio[[gender]]\n      }\n    }\n  }\n\n  # Rekombinationsprozess\n  if(length(population$breeding)<=current.gen ){\n    population$breeding[[current.gen+1]] <- list()\n    population$info$size <- rbind(population$info$size, 0)\n  }\n\n  selection.rate <- list(numeric(selection.size[1]), numeric(selection.size[2]))\n  activ.selection.size <- selection.size\n  availables.m <- 1:selection.size[1]\n  availables.w <- 1:selection.size[2]\n  availables <- list(availables.m, availables.w)\n\n  if(relative.selection){\n    if(sum(best[[1]][,4]<0)>0){\n      best[[1]][(best[[1]][,4]<0),4] <- 0\n    }\n    if(sum(best[[2]][,4]<0)>0){\n      best[[2]][(best[[2]][,4]<0),4] <- 0\n    }\n\n    cum.sum.m <- cumsum(best[[1]][,4])\n    cum.sum.w <- cumsum(best[[2]][,4])\n    sum.m <- sum(best[[1]][,4])\n    sum.w <- sum(best[[2]][,4])\n    cum.sum <- list(cum.sum.m, cum.sum.w)\n    sum <- list(sum.m,sum.w)\n  }\n  current.size <- c(1,1)\n  for(gender in 1:2){\n    if(length(population$breeding[[current.gen+1]])<=2 || length(population$breeding[[current.gen+1]][[gender]])==0){\n      population$breeding[[current.gen+1]][[2+gender]] <- matrix(0, nrow=population$info$bve.nr, ncol=breeding.size[gender])\n      population$breeding[[current.gen+1]][[4+gender]] <- rep(new.migration.level, breeding.size[gender])\n      population$breeding[[current.gen+1]][[6+gender]] <- matrix(0, nrow=population$info$bve.nr, ncol=breeding.size[gender])\n      population$breeding[[current.gen+1]][[8+gender]] <- matrix(0, nrow=population$info$bve.nr, ncol=breeding.size[gender])\n      #    } else if(length(population$breeding[[current.gen+1]][[gender+2]])==0){\n      #      population$breeding[[current.gen+1]][[2+gender]] <- rep(0, breeding.size[gender])\n      #      population$breeding[[current.gen+1]][[4+gender]] <- rep(new.migration.level, breeding.size[gender])\n      #     population$breeding[[current.gen+1]][[6+gender]] <- new.bv[gender,]\n      #      population$breeding[[current.gen+1]][[8+gender]] <- new.bv.approx[gender,]\n    } else{\n      current.size[gender] <- length(population$breeding[[current.gen+1]][[4+gender]]) + 1\n      population$breeding[[current.gen+1]][[2+gender]] <- cbind(population$breeding[[current.gen+1]][[gender+2]], matrix(0, nrow= population$info$bve.nr, ncol=breeding.size[gender]))\n      population$breeding[[current.gen+1]][[4+gender]] <- c(population$breeding[[current.gen+1]][[gender+4]], rep(new.migration.level, breeding.size[gender]))\n      population$breeding[[current.gen+1]][[6+gender]] <- cbind(population$breeding[[current.gen+1]][[6+gender]], matrix(0, nrow= population$info$bve.nr, ncol=breeding.size[gender]))\n      population$breeding[[current.gen+1]][[8+gender]] <- cbind(population$breeding[[current.gen+1]][[8+gender]], matrix(0, nrow= population$info$bve.nr, ncol=breeding.size[gender]))\n    }\n    if(length(population$breeding[[current.gen+1]][[gender]])==0){\n      population$breeding[[current.gen+1]][[gender]] <- list()\n    }\n  }\n  if(length(praeimplantation)>0){\n    nsnps <- c(0,population$info$cumsnp)\n    praeimplantation <- cbind(praeimplantation, nsnps[praeimplantation[,1]] + praeimplantation[,2])\n    praeimplantation.max <- list()\n    for(gender in 1:2){\n      praeimplantation.max[[gender]] <- numeric(nrow(best[[gender]]))\n      for(index in 1:length(best[[gender]])){\n        activ <- best[[gender]][index,]\n        hap1 <- population$breeding[[activ[1]]][[activ[2]]][[activ[3]]][[9]][praeimplantation[,4]]\n        hap2 <- population$breeding[[activ[1]]][[activ[2]]][[activ[3]]][[10]][praeimplantation[,4]]\n        pos <- ((hap1==praeimplantation[,3]) + (hap2==praeimplantation[,3]))>0\n        praeimplantation.max[[gender]][index] <- sum(pos)\n      }\n    }\n    print(\"praeimplantation bisher nicht in Selektion enthalten\")\n  }\n\n  if(length(fixed.breeding.best)>0){\n    fixed.breeding <- matrix(0, nrow=nrow(fixed.breeding.best), ncol=7)\n\n    for(index in 1:nrow(fixed.breeding.best)){\n      fixed.breeding[index,1:3] <- best[[fixed.breeding.best[index,1]]][fixed.breeding.best[index,2], 1:3]\n      fixed.breeding[index,4:6] <- best[[fixed.breeding.best[index,3]]][fixed.breeding.best[index,4], 1:3]\n    }\n\n    fixed.breeding[,7] <- fixed.breeding.best[,5]\n    gender.animal <- fixed.breeding[,7] <- stats::rbinom(breeding.size.total, 1, fixed.breeding[,7]) +1\n    breeding.size <- c(sum(fixed.breeding[,7]==1), sum(fixed.breeding[,7]==2))\n  }\n\n## HERE IS AN ATTEMPT AT PARALLEL-GENERATION\n##  store.effect.freq and multiple correlated bvs deactivated\n  if(store.comp.times.generation){\n    pre_stuff <- 0\n    generation_stuff <- 0\n    bv_stuff <- 0\n  }\n  if(parallel.generation && breeding.size.total>0){\n\n    if(store.comp.times.generation){\n      tick <- as.numeric(Sys.time())\n    }\n    info_father_list <- info_mother_list <- matrix(0, nrow=breeding.size.total, ncol=5)\n    for(animal.nr in 1:breeding.size.total){\n      gender <- gender.animal[animal.nr]\n      if(length(fixed.breeding)>0){\n        info.father <- fixed.breeding[animal.nr,1:3]\n        info.mother <- fixed.breeding[animal.nr,4:6]\n      } else{\n        if(selfing.mating==FALSE){\n          gender1 <- 1\n          gender2 <- 2\n          if(same.sex.activ==FALSE && relative.selection==FALSE){\n            number1 <- availables[[gender1]][sample(1:activ.selection.size[gender1],1, prob=sample_prob[[gender1]][availables[[gender1]]])]\n            number2 <- availables[[gender2]][sample(1:activ.selection.size[gender2],1, prob=sample_prob[[gender2]][availables[[gender2]]])]\n            info.father <- best[[gender1]][number1,]\n            info.mother <- best[[gender2]][number2,]\n          } else if(same.sex.activ==FALSE && relative.selection){\n            info.father <- best[[gender1]][sum(cum.sum[[gender1]] <stats::runif(1,0,sum[[1]])) +1 ,1:3]\n            info.mother <- best[[gender2]][sum(cum.sum[[gender2]] <stats::runif(1,0,sum[[2]])) +1 ,1:3]\n          } else{\n            gender1 <- stats::rbinom(1,1,same.sex.gender) + 1 # ungleichviele tiere erhöht\n\n            gender2 <- stats::rbinom(1,1,same.sex.gender) + 1\n            number1 <- availables[[gender1]][sample(1:activ.selection.size[gender1],1, prob=sample_prob[[gender1]][availables[[gender1]]])]\n            number2 <- availables[[gender2]][sample(1:activ.selection.size[gender2],1, prob=sample_prob[[gender2]][availables[[gender2]]])]\n            test <- 1\n            while(same.sex.selfing==FALSE && number1==number2 && test < 100){\n              number2 <- availables[[gender2]][sample(1:activ.selection.size[gender2],1, prob=sample_prob[[gender2]][availables[[gender2]]])]\n              test <- test+1\n              if(test==100 && number1==number2){\n                print(\"Selbstung durchgefuehrt da nur ein Tier in Selektionsgruppe\")\n              }\n            }\n\n            if(relative.selection==FALSE){\n              info.father <- best[[gender1]][number1,]\n              # waehle fuers bveite Tier ein Tier aus der Gruppe der Nicht-besten Tiere\n              if(martini.selection){\n                options <- (1:population$info$size[best[[gender2]][1,1],gender2])[-best[[gender2]][,3]]\n                number2 <- sample(options,1)\n                info.mother <- c(best[[gender2]][1,1:2], number2)\n              } else{\n                info.mother <- best[[gender2]][number2,]\n              }\n            } else{\n              info.father <- best[[gender1]][sum(cum.sum[[gender1]] <stats::runif(1,0,cum.sum[[gender1]])) +1 ,1:3]\n              info.mother <- best[[gender2]][sum(cum.sum[[gender2]] <stats::runif(1,0,cum.sum[[gender2]])) +1 ,1:3]\n            }\n\n          }\n        } else{\n          gender1 <- gender2 <- stats::rbinom(1,1,selfing.gender)+1\n          if(length(availables[[gender1]])==0){\n            gender1 <- gender2 <- 3 - gender1\n          }\n          number1 <- number2 <- availables[[gender1]][sample(1:activ.selection.size[gender1],1, prob=sample_prob[[gender1]][availables[[gender1]]])]\n          info.father <- best[[gender1]][number1,]\n          info.mother <- best[[gender2]][number2,]\n\n        }\n        if(martini.selection==FALSE){\n          selection.rate[[gender1]][number1] <- selection.rate[[gender1]][number1] +1\n          selection.rate[[gender2]][number2] <- selection.rate[[gender2]][number2] +1\n\n          if(selection.rate[[gender1]][number1] >= max.offspring[gender1]){\n            activ.selection.size[gender1] <-  activ.selection.size[gender1] -1\n            availables[[gender1]] <- availables[[gender1]][availables[[gender1]]!=number1]\n          }\n          if(selection.rate[[gender2]][number2] >= max.offspring[gender2]){\n            if(gender1!= gender2 || number1 != number2){\n              activ.selection.size[gender2] <-  activ.selection.size[gender2] -1\n            }\n            availables[[gender2]] <- availables[[gender2]][availables[[gender2]]!=number2]\n          }\n        }\n\n      }\n      info_father_list[animal.nr,] <- info.father\n      info_mother_list[animal.nr,] <- info.mother\n    }\n    if(store.comp.times.generation){\n      tock <- as.numeric(Sys.time())\n      pre_stuff <- tock-tick\n    }\n\n    if(backend==\"doParallel\"){\n      doParallel::registerDoParallel(cores=ncore.generation)\n      print(\"True breeding value calculation does not work under parallelisation in windows!\")\n      if(length(randomSeed.generation)>0){\n        if (requireNamespace(\"doRNG\", quietly = TRUE)) {\n          doRNG::registerDoRNG(seed=randomSeed.generation)\n        } else{\n          stop(\"Usage of doRNG without being installed!\")\n        }\n      }\n    }\n\n    for(gender_running in 1:2){\n\n      if(store.comp.times.generation){\n        tick <- as.numeric(Sys.time())\n      }\n      new_animal <- foreach::foreach(indexb=(1:breeding.size.total)[gender.animal==gender_running],\n                            .packages=\"RekomBre\") %dopar% {\n\n                              info.father <- info_father_list[indexb,]\n                              info.mother <- info_mother_list[indexb,]\n                              father <- population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]]\n                              mother <- population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]]\n                              if(copy.animal){\n                                child1 <- list(father[[1]], father[[3]], father[[5]], father[[7]], father[[11]], 0, if(length(father)>19){father[[19]]} else{0})\n                                child2 <- list(father[[2]], father[[4]], father[[6]], father[[8]], father[[12]], 0, if(length(father)>19){father[[20]]} else{0})\n                              } else{\n                                child1 <- breeding.intern(info.father, father, population,\n                                                          mutation.rate, remutation.rate, recombination.rate,\n                                                          recom.f.indicator, recom.f.polynom, duplication.rate, duplication.length,\n                                                          duplication.recombination, delete.same.ursprung=delete.same.ursprung,\n                                                          gene.editing=(gene.editing.offspring*gene.editing.offspring.gender[1]), nr.edits= nr.edits,\n                                                          gen_architecture=gen.architecture.m,\n                                                          decodeOriginsU=decodeOriginsU)\n\n                                child2 <- breeding.intern(info.mother, mother, population,\n                                                          mutation.rate, remutation.rate, recombination.rate,\n                                                          recom.f.indicator, recom.f.polynom, duplication.rate, duplication.length,\n                                                          duplication.recombination, delete.same.ursprung=delete.same.ursprung,\n                                                          gene.editing=(gene.editing.offspring * gene.editing.offspring.gender[1]) , nr.edits= nr.edits,\n                                                          gen_architecture=gen.architecture.w,\n                                                          decodeOriginsU=decodeOriginsU)\n                              }\n                              if(dh.mating){\n                                if(stats::rbinom(1,1,dh.gender)==0){\n                                  child2 <- child1\n                                } else{\n                                  child1 <- child2\n                                }\n                              }\n\n                              # Fuer Praeimplantationsdiagnostik muesste hier die relevanten SNPs berechnet werden.\n\n                              if(length(praeimplantation)>0){\n                                # gender1/gender2 und number1/number2 werden von Selektion uebernommen und nicht bestimmt!\n                                # Praeimplantationsdiagnostik 1. Chromosom\n                                counter <- 1\n                                good1 <- 0\n                                n.snps <- sum(population$info$snp)\n                                while(good1==0){\n                                  hap1 <- rep(0,n.snps)\n                                  temp1 <- 0\n                                  current.animal <- child1\n                                  for(index2 in 1:(length(current.animal[[1]])-1)){\n                                    relevant.snp <- (population$info$snp.position < current.animal[[1]][index2+1])*(population$info$snp.position >= current.animal[[1]][index2])*(1:n.snps)\n                                    ursprung <- decodeOriginsU(current.animal[[3]],index2)\n                                    ursprung[1] <- population$info$origin_gen[ursprung[1]]\n                                    hap1[relevant.snp] <-population$breeding[[ursprung[1]]][[ursprung[2]]][[ursprung[3]]][[ursprung[4]+8]][relevant.snp]\n                                  }\n                                  if(length(current.animal[[2]])>0){\n                                    for(index2 in 1:length(current.animal[[2]])){\n                                      position <- which(population$info$snp.position==current.animal[[2]][index2])\n                                      hap1[position] <- 1-population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[9+temp1]][position]\n                                    }\n                                  }\n                                  if(hap1[pos] == praeimplantation.max[[gender1]][[number1]] || counter==25){\n                                    good1 <- 1\n                                    if(counter==25){print(\"Praeimplantation gescheitert!\")}\n                                  } else{\n                                    child1 <- breeding.intern(info.father, father, population,\n                                                              mutation.rate, remutation.rate, recombination.rate,\n                                                              recom.f.indicator, recom.f.polynom, duplication.rate, duplication.length,\n                                                              duplication.recombination, delete.same.ursprung=delete.same.ursprung,\n                                                              gene.editing=gene.editing, nr.edits= nr.edits,gen_architecture=gen.architecture.m,\n                                                              decodeOriginsU=decodeOriginsU)\n                                    counter <- counter +1\n                                  }\n                                }\n\n                                # Praeimplantationsdiagnostik 2. Chromosom\n\n                                good1 <- 0\n                                n.snps <- sum(population$info$snp)\n                                while(good1==0){\n                                  hap1 <- rep(0,n.snps)\n                                  temp1 <- 0\n                                  current.animal <- child2\n                                  for(index2 in 1:(length(current.animal[[1]])-1)){\n                                    relevant.snp <- (population$info$snp.position < current.animal[[1]][index2+1])*(population$info$snp.position >= current.animal[[1]][index2])*(1:n.snps)\n                                    ursprung <-  decodeOriginsU(current.animal[[3]],index2)\n                                    ursprung[1] <- population$info$origin_gen[ursprung[1]]\n                                    hap1[relevant.snp] <-population$breeding[[ursprung[1]]][[ursprung[2]]][[ursprung[3]]][[ursprung[4]+8]][relevant.snp]\n                                  }\n                                  if(length(current.animal[[2]])>0){\n                                    for(index2 in 1:length(current.animal[[2]])){\n                                      position <- which(population$info$snp.position==current.animal[[2]][index2])\n                                      hap1[position] <- 1-population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[9+temp1]][position]\n                                    }\n                                  }\n                                  if(hap1[pos] == praeimplantation.max[[gender2]][[number2]] || counter==25){\n                                    good1 <- 1\n                                    if(counter==25){print(\"Praeimplantation gescheitert!\")}\n                                  } else{\n                                    child2 <- breeding.intern(info.mother, mother, population,\n                                                              mutation.rate, remutation.rate, recombination.rate,\n                                                              recom.f.indicator, recom.f.polynom, duplication.rate, duplication.length,\n                                                              duplication.recombination, delete.same.ursprung=delete.same.ursprung,\n                                                              gene.editing=gene.editing, nr.edits= nr.edits,\n                                                              gen_architecture=gen.architecture.w, decodeOriginsU=decodeOriginsU)\n                                    counter <- counter +1\n                                  }\n                                }\n                              }\n\n                              child <- list()\n                              child[[1]] <- child1[[1]]\n                              child[[2]] <- child2[[1]]\n                              child[[3]] <- child1[[2]]\n                              child[[4]] <- child2[[2]]\n                              child[[5]] <- child1[[3]]\n                              child[[6]] <- child2[[3]]\n                              child[[7]] <- child1[[4]]\n                              child[[8]] <- child2[[4]]\n\n                              population$info$size[current.gen+1 ,gender] <- population$info$size[current.gen+1,gender] + 1\n\n                              if(is.vector(child1[[5]])){\n                                child[[11]] <- t(as.matrix(child1[[5]]))\n                              } else{\n                                child[[11]] <- child1[[5]]\n                              }\n                              if(is.vector(child2[[5]])){\n                                child[[12]] <- t(as.matrix(child2[[5]]))\n                              } else{\n                                child[[12]] <- child2[[5]]\n                              }\n                              if(save.recombination.history && current.gen==1){\n                                if(length(child1[[6]][-c(1,length(child1[[6]]))])>0){\n                                  child[[13]] <- cbind(current.gen, child1[[6]][-c(1,length(child1[[6]]))])\n                                } else{\n                                  child[[13]] <- cbind(0,0)\n                                }\n                                if(length( child2[[6]][-c(1,length(child2[[6]]))])>0){\n                                  child[[14]] <- cbind(current.gen, child2[[6]][-c(1,length(child2[[6]]))])\n                                } else{\n                                  child[[14]] <- cbind(0,0)\n                                }\n\n                              } else if(save.recombination.history && current.gen>1){\n                                if(length(child1[[6]][-c(1,length(child1[[6]]))])>0){\n                                  child[[13]] <- rbind(population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]][[13]], population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]][[14]], cbind(current.gen, child1[[6]][-c(1,length(child1[[6]]))]))\n                                } else{\n                                  child[[13]] <- rbind(population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]][[13]], population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]][[14]])\n\n                                }\n                                if(length( child2[[6]][-c(1,length(child2[[6]]))])>0){\n                                  child[[14]] <- rbind(population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]][[13]], population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]][[14]], cbind(current.gen, child2[[6]][-c(1,length(child2[[6]]))]))\n                                } else{\n                                  child[[14]] <- rbind(population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]][[13]], population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]][[14]])\n\n                                }\n\n                              } else{\n                                #child[[13]] <- \"test\"\n                              }\n\n                              if(new.bv.child==\"obs\"){\n                                child[[15]] <- n.observation\n                              } else{\n                                child[[15]] <- 0\n                              }\n                              child[[16]] <- 0\n                              child[[19]] <- child1[[7]]\n                              child[[20]] <- child2[[7]]\n\n                              child\n\n                            }\n      present_before <- population$info$size[current.gen+1,gender_running]\n      population$breeding[[current.gen+1]][[gender_running]] <-  c(population$breeding[[current.gen+1]][[gender_running]], new_animal)\n      population$info$size[current.gen+1,gender_running] <- length(population$breeding[[current.gen+1]][[gender_running]])\n\n      if(store.comp.times.generation){\n        tack <- as.numeric(Sys.time())\n        generation_stuff <- tack-tick + generation_stuff\n      }\n      if(store.effect.freq){\n        store.effect.freq <- FALSE\n        print(\"Effekt-Freq not available in parallel computing\")\n      }\n\n      # This currently does not work since computeSNPS does not work in doParallel enviroment.\n      new.bv.list <- foreach::foreach(indexb=(1:length(new_animal)),\n                            .packages=c(\"RekomBre\", \"miraculix\")) %dopar% {\n                            new.bv <- new.bv_approx <-  numeric(population$info$bve.nr)\n                            activ_bv <- which(population$info$bv.random[1:population$info$bve.calc]==FALSE)\n\n                            if(length(activ_bv)>0){\n                              temp_out <- calculate.bv(population, current.gen+1, gender_running, indexb + present_before, activ_bv, import.position.calculation=import.position.calculation, decodeOriginsU=decodeOriginsU, store.effect.freq=store.effect.freq, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)\n                              new.bv[activ_bv] <- temp_out[[1]]\n                              if(store.effect.freq){\n                                if(length(population$info$store.effect.freq) < (current.gen+1) || length(population$info$store.effect.freq[[current.gen+1]])==0){\n                                  population$info$store.effect.freq[[current.gen+1]] <- temp_out[[2]]\n                                } else{\n                                  population$info$store.effect.freq[[current.gen+1]] <- population$info$store.effect.freq[[current.gen+1]] + temp_out[[2]]\n                                }\n                              }\n                            }\n\n                            if(population$info$bve.calc > 0  && population$info$bv.random[population$info$bve.calc]){\n                              means <- 0.5*(population$breeding[[info.father[1]]][[6+info.father[2]]][[population$info$bve.calc:population$info$bve.nr,info.father[3]]] + population$breeding[[info.mother[1]]][[6+info.mother[2]]][[population$info$bve.calc:population$info$bve.nr,info.mother[3]]])\n                              varp <- kinship.emp(list(population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]], population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]]))\n                              varp <- (2 - (2* (varp[1,1]-0.5) + 2 * (varp[2,2]- 0.5)))/4\n\n                              if(FALSE){\n                                new.bv[population$info$bve.calc:population$info$bve.nr] <- stats::rnorm(1, mean=means, sd= sqrt(var*population$info$bv.random.variance[bven]))\n                              } else{\n                                if(population$info$bve.calc==1){\n                                  population$info$current.bv.random.variance <- varp * population$info$bv.random.variance\n                                  bv.var <- diag(sqrt(population$info$current.bv.random.variance)) %*%population$info$current.bv.correlation %*% diag(sqrt(population$info$current.bv.random.variance))\n                                  single.mean <- means\n                                } else{\n                                  population$info$current.bv.random.variance <- c(population$info$bv.random.variance[1:(population$info$bve.calc-1)],varp * population$info$bv.random.variance[population$info$bve.calc:population$info$bve.nr])\n                                  AA <- diag(sqrt(population$info$current.bv.random.variance)[1:(population$info$bve.calc-1)]) %*% population$info$current.bv.correlation[1:(population$info$bve.calc-1), 1:(population$info$bve.calc-1)]%*% diag(sqrt(population$info$current.bv.random.variance)[(1:(population$info$bve.calc-1))])\n                                  BB <- diag(sqrt(population$info$current.bv.random.variance)[1:(population$info$bve.calc-1)]) %*%population$info$current.bv.correlation[1:(population$info$bve.calc-1), -(1:(population$info$bve.calc-1))]%*% diag(sqrt(population$info$current.bv.random.variance)[-(1:(population$info$bve.calc-1))])\n                                  CC <- diag(sqrt(population$info$current.bv.random.variance)[-(1:(population$info$bve.calc-1))]) %*%population$info$current.bv.correlation[-(1:(population$info$bve.calc-1)), -(1:(population$info$bve.calc-1))] %*% diag(sqrt(population$info$current.bv.random.variance)[-(1:(population$info$bve.calc-1))])\n                                  if (requireNamespace(\"MASS\", quietly = TRUE)) {\n                                    bv.var <- CC - t(BB) %*% MASS::ginv(AA) %*% BB\n                                    single.mean <- means + t(BB) %*% MASS::ginv(AA) %*% ( new.bv[1:(population$info$bve.calc-1)]-mu1[1:(population$info$bve.calc-1)])\n                                  } else{\n                                    bv.var <- CC - t(BB) %*% solve(AA) %*% BB\n                                    single.mean <- means + t(BB) %*% solve(AA) %*% ( new.bv[1:(population$info$bve.calc-1)]-mu1[1:(population$info$bve.calc-1)])\n                                  }\n                                }\n\n                                bv.var_chol <- t(chol(bv.var))\n                                population$info$bv.correlation_col <- bv.var_chol\n\n                                random_part <- bv.var_chol %*% stats::rnorm(population$info$bve.nr - population$info$bve.calc +1, 0,1 )\n                                means_part <- single.mean\n                                new.bv[population$info$bve.calc:population$info$bve.nr] <-random_part + means_part\n                              }\n\n                            }\n                            for(bven in 1:population$info$bve.calc){\n                              if(new.bv.child==\"mean\"){\n                                activ_father <- population$breeding[[current.gen+1]][[gender_running]][[indexb + present_before]][[7]]\n                                activ_mother <- population$breeding[[current.gen+1]][[gender_running]][[indexb + present_before]][[8]]\n                                new.bv_approx[bven] <- mean(c(population$breeding[[activ_father[1]]][[8+activ_father[2]]][bven,activ_father[3]],population$breeding[[activ_mother[1]]][[8+activ_mother[2]]][bven,activ_mother[3]]))\n                              } else if(new.bv.child==\"obs\"){\n                                temp_random <- matrix(stats::rnorm(population$info$bve.nr*n.observation,0,1), ncol=n.observation)\n                                for(bven in 1:population$info$bve.nr){\n#                                  new.bv_approx[bven] <- (rowMeans(population$info$pheno.correlation %*% temp_random)[bven] * sqrt(sigma.e[bven]/n.observation) + new.bv[bven])\n                                  new.bv_approx[bven] <- (rowMeans(population$info$pheno.correlation %*% temp_random)[bven] * sqrt(sigma.e[bven]) + new.bv[bven])\n\n                                }\n                                new.bv_approx[bven] <- stats::rnorm(1, new.bv[bven], sd=sqrt(sigma.e[bven]/population$breeding[[current.gen+1]][[gender_running]][[indexb+present_before]][[15]]))\n                              } else if(new.bv.child==\"zero\"){\n                                new.bv_approx[bven] <- 0\n                              }\n                            }\n\n                            temp1 <- c(new.bv, new.bv_approx)\n                            temp1\n                            }\n      new.bv.list <- matrix(unlist(new.bv.list), ncol=length(new_animal))\n      population$breeding[[current.gen+1]][[gender_running+6]][,(present_before+1):(present_before+length(new_animal))] <- new.bv.list[1:(nrow(new.bv.list)/2),,drop=FALSE]\n      population$breeding[[current.gen+1]][[gender_running+8]][,(present_before+1):(present_before+length(new_animal))] <- new.bv.list[-(1:(nrow(new.bv.list)/2)),,drop=FALSE]\n\n      if(store.comp.times.generation){\n        tock <- as.numeric(Sys.time())\n        bv_stuff <- tock - tack + bv_stuff\n      }\n    }\n\n    if(backend==\"doParallel\"){\n      doParallel::stopImplicitCluster()\n    }\n\n\n  } else if(breeding.size.total>0){\n    for(animal.nr in 1:breeding.size.total){\n      if(store.comp.times.generation){\n        tick <- as.numeric(Sys.time())\n      }\n      gender <- gender.animal[animal.nr]\n      new.bv <- numeric(population$info$bve.nr)\n      new.bv_approx <- numeric(population$info$bve.nr)\n      if(length(fixed.breeding)>0){\n        info.father <- fixed.breeding[animal.nr,1:3]\n        info.mother <- fixed.breeding[animal.nr,4:6]\n      } else{\n        if(selfing.mating==FALSE){\n          gender1 <- 1\n          gender2 <- 2\n          if(same.sex.activ==FALSE && relative.selection==FALSE){\n            number1 <- availables[[gender1]][sample(1:activ.selection.size[gender1],1, prob=sample_prob[[gender1]][availables[[gender1]]])]\n            number2 <- availables[[gender2]][sample(1:activ.selection.size[gender2],1, prob=sample_prob[[gender2]][availables[[gender2]]])]\n            info.father <- best[[gender1]][number1,]\n            info.mother <- best[[gender2]][number2,]\n          } else if(same.sex.activ==FALSE && relative.selection){\n            info.father <- best[[gender1]][sum(cum.sum[[gender1]] <stats::runif(1,0,sum[[1]])) +1 ,1:3]\n            info.mother <- best[[gender2]][sum(cum.sum[[gender2]] <stats::runif(1,0,sum[[2]])) +1 ,1:3]\n          } else{\n            gender1 <- stats::rbinom(1,1,same.sex.gender) + 1 # ungleichviele tiere erhöht\n\n            gender2 <- stats::rbinom(1,1,same.sex.gender) + 1\n            number1 <- availables[[gender1]][sample(1:activ.selection.size[gender1],1, prob=sample_prob[[gender1]][availables[[gender1]]])]\n            number2 <- availables[[gender2]][sample(1:activ.selection.size[gender2],1, prob=sample_prob[[gender2]][availables[[gender2]]])]\n            test <- 1\n            while(same.sex.selfing==FALSE && number1==number2 && test < 100){\n              number2 <- availables[[gender2]][sample(1:activ.selection.size[gender2],1, prob=sample_prob[[gender2]][availables[[gender2]]])]\n              test <- test+1\n              if(test==100 && number1==number2){\n                print(\"Selbstung durchgefuehrt da nur ein Tier in Selektionsgruppe\")\n              }\n            }\n\n            if(relative.selection==FALSE){\n              info.father <- best[[gender1]][number1,]\n              # waehle fuers bveite Tier ein Tier aus der Gruppe der Nicht-besten Tiere\n              if(martini.selection){\n                options <- (1:population$info$size[best[[gender2]][1,1],gender2])[-best[[gender2]][,3]]\n                number2 <- sample(options,1)\n                info.mother <- c(best[[gender2]][1,1:2], number2)\n              } else{\n                info.mother <- best[[gender2]][number2,]\n              }\n            } else{\n              info.father <- best[[gender1]][sum(cum.sum[[gender1]] <stats::runif(1,0,cum.sum[[gender1]])) +1 ,1:3]\n              info.mother <- best[[gender2]][sum(cum.sum[[gender2]] <stats::runif(1,0,cum.sum[[gender2]])) +1 ,1:3]\n            }\n\n          }\n        } else{\n          gender1 <- gender2 <- stats::rbinom(1,1,selfing.gender)+1\n          if(length(availables[[gender1]])==0){\n            gender1 <- gender2 <- 3 - gender1\n          }\n          number1 <- number2 <- availables[[gender1]][sample(1:activ.selection.size[gender1],1, prob=sample_prob[[gender1]][availables[[gender1]]])]\n          info.father <- best[[gender1]][number1,]\n          info.mother <- best[[gender2]][number2,]\n\n        }\n        if(martini.selection==FALSE){\n          selection.rate[[gender1]][number1] <- selection.rate[[gender1]][number1] +1\n          selection.rate[[gender2]][number2] <- selection.rate[[gender2]][number2] +1\n\n          if(selection.rate[[gender1]][number1] >= max.offspring[gender1]){\n            activ.selection.size[gender1] <-  activ.selection.size[gender1] -1\n            availables[[gender1]] <- availables[[gender1]][availables[[gender1]]!=number1]\n          }\n          if(selection.rate[[gender2]][number2] >= max.offspring[gender2]){\n            if(gender1!= gender2 || number1 != number2){\n              activ.selection.size[gender2] <-  activ.selection.size[gender2] -1\n            }\n            availables[[gender2]] <- availables[[gender2]][availables[[gender2]]!=number2]\n          }\n        }\n\n      }\n      if(store.comp.times.generation){\n        tack <- as.numeric(Sys.time())\n        pre_stuff <- pre_stuff + tack -tick\n      }\n\n      father <- population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]]\n      mother <- population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]]\n      if(copy.animal){\n        child1 <- list(father[[1]], father[[3]], father[[5]], father[[7]], father[[11]], 0, if(length(father)>19){father[[19]]} else{0})\n        child2 <- list(father[[2]], father[[4]], father[[6]], father[[8]], father[[12]], 0, if(length(father)>19){father[[20]]} else{0})\n      } else{\n        child1 <- breeding.intern(info.father, father, population,\n                                  mutation.rate, remutation.rate, recombination.rate,\n                                  recom.f.indicator, recom.f.polynom, duplication.rate, duplication.length,\n                                  duplication.recombination, delete.same.ursprung=delete.same.ursprung,\n                                  gene.editing=(gene.editing.offspring*gene.editing.offspring.gender[1]), nr.edits= nr.edits,\n                                  gen_architecture=gen.architecture.m,\n                                  decodeOriginsU=decodeOriginsU)\n\n        child2 <- breeding.intern(info.mother, mother, population,\n                                  mutation.rate, remutation.rate, recombination.rate,\n                                  recom.f.indicator, recom.f.polynom, duplication.rate, duplication.length,\n                                  duplication.recombination, delete.same.ursprung=delete.same.ursprung,\n                                  gene.editing=(gene.editing.offspring * gene.editing.offspring.gender[1]) , nr.edits= nr.edits,\n                                  gen_architecture=gen.architecture.w,\n                                  decodeOriginsU=decodeOriginsU)\n      }\n      if(dh.mating){\n        if(stats::rbinom(1,1,dh.gender)==0){\n          child2 <- child1\n        } else{\n          child1 <- child2\n        }\n      }\n\n      # Fuer Praeimplantationsdiagnostik muesste hier die relevanten SNPs berechnet werden.\n\n      if(length(praeimplantation)>0){\n        # gender1/gender2 und number1/number2 werden von Selektion uebernommen und nicht bestimmt!\n        # Praeimplantationsdiagnostik 1. Chromosom\n        counter <- 1\n        good1 <- 0\n        n.snps <- sum(population$info$snp)\n        while(good1==0){\n          hap1 <- rep(0,n.snps)\n          temp1 <- 0\n          current.animal <- child1\n          for(index2 in 1:(length(current.animal[[1]])-1)){\n            relevant.snp <- (population$info$snp.position < current.animal[[1]][index2+1])*(population$info$snp.position >= current.animal[[1]][index2])*(1:n.snps)\n            ursprung <- decodeOriginsU(current.animal[[3]],index2)\n            ursprung[1] <- population$info$origin_gen[ursprung[1]]\n            hap1[relevant.snp] <-population$breeding[[ursprung[1]]][[ursprung[2]]][[ursprung[3]]][[ursprung[4]+8]][relevant.snp]\n          }\n          if(length(current.animal[[2]])>0){\n            for(index2 in 1:length(current.animal[[2]])){\n              position <- which(population$info$snp.position==current.animal[[2]][index2])\n              hap1[position] <- 1-population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[9+temp1]][position]\n            }\n          }\n          if(hap1[pos] == praeimplantation.max[[gender1]][[number1]] || counter==25){\n            good1 <- 1\n            if(counter==25){print(\"Praeimplantation gescheitert!\")}\n          } else{\n            child1 <- breeding.intern(info.father, father, population,\n                                      mutation.rate, remutation.rate, recombination.rate,\n                                      recom.f.indicator, recom.f.polynom, duplication.rate, duplication.length,\n                                      duplication.recombination, delete.same.ursprung=delete.same.ursprung,\n                                      gene.editing=gene.editing, nr.edits= nr.edits,gen_architecture=gen.architecture.m,\n                                      decodeOriginsU=decodeOriginsU)\n            counter <- counter +1\n          }\n        }\n\n        # Praeimplantationsdiagnostik 2. Chromosom\n\n        good1 <- 0\n        n.snps <- sum(population$info$snp)\n        while(good1==0){\n          hap1 <- rep(0,n.snps)\n          temp1 <- 0\n          current.animal <- child2\n          for(index2 in 1:(length(current.animal[[1]])-1)){\n            relevant.snp <- (population$info$snp.position < current.animal[[1]][index2+1])*(population$info$snp.position >= current.animal[[1]][index2])*(1:n.snps)\n            ursprung <-  decodeOriginsU(current.animal[[3]],index2)\n            ursprung[1] <- population$info$origin_gen[ursprung[1]]\n            hap1[relevant.snp] <-population$breeding[[ursprung[1]]][[ursprung[2]]][[ursprung[3]]][[ursprung[4]+8]][relevant.snp]\n          }\n          if(length(current.animal[[2]])>0){\n            for(index2 in 1:length(current.animal[[2]])){\n              position <- which(population$info$snp.position==current.animal[[2]][index2])\n              hap1[position] <- 1-population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[9+temp1]][position]\n            }\n          }\n          if(hap1[pos] == praeimplantation.max[[gender2]][[number2]] || counter==25){\n            good1 <- 1\n            if(counter==25){print(\"Praeimplantation gescheitert!\")}\n          } else{\n            child2 <- breeding.intern(info.mother, mother, population,\n                                      mutation.rate, remutation.rate, recombination.rate,\n                                      recom.f.indicator, recom.f.polynom, duplication.rate, duplication.length,\n                                      duplication.recombination, delete.same.ursprung=delete.same.ursprung,\n                                      gene.editing=gene.editing, nr.edits= nr.edits,\n                                      gen_architecture=gen.architecture.w, decodeOriginsU=decodeOriginsU)\n            counter <- counter +1\n          }\n        }\n      }\n\n\n\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]] <- list()\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[1]] <- child1[[1]]\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[2]] <- child2[[1]]\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[3]] <- child1[[2]]\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[4]] <- child2[[2]]\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[5]] <- child1[[3]]\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[6]] <- child2[[3]]\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[7]] <- child1[[4]]\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[8]] <- child2[[4]]\n\n      population$info$size[current.gen+1 ,gender] <- population$info$size[current.gen+1,gender] + 1\n\n      if(is.vector(child1[[5]])){\n        population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[11]] <- t(as.matrix(child1[[5]]))\n      } else{\n        population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[11]] <- child1[[5]]\n      }\n      if(is.vector(child2[[5]])){\n        population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[12]] <- t(as.matrix(child2[[5]]))\n      } else{\n        population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[12]] <- child2[[5]]\n      }\n      if(save.recombination.history && current.gen==1){\n        if(length(child1[[6]][-c(1,length(child1[[6]]))])>0){\n          population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[13]] <- cbind(current.gen, child1[[6]][-c(1,length(child1[[6]]))])\n        } else{\n          population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[13]] <- cbind(0,0)\n        }\n        if(length( child2[[6]][-c(1,length(child2[[6]]))])>0){\n          population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[14]] <- cbind(current.gen, child2[[6]][-c(1,length(child2[[6]]))])\n        } else{\n          population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[14]] <- cbind(0,0)\n        }\n\n      } else if(save.recombination.history && current.gen>1){\n        if(length(child1[[6]][-c(1,length(child1[[6]]))])>0){\n          population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[13]] <- rbind(population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]][[13]], population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]][[14]], cbind(current.gen, child1[[6]][-c(1,length(child1[[6]]))]))\n        } else{\n          population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[13]] <- rbind(population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]][[13]], population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]][[14]])\n\n        }\n        if(length( child2[[6]][-c(1,length(child2[[6]]))])>0){\n          population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[14]] <- rbind(population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]][[13]], population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]][[14]], cbind(current.gen, child2[[6]][-c(1,length(child2[[6]]))]))\n        } else{\n          population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[14]] <- rbind(population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]][[13]], population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]][[14]])\n\n        }\n\n      } else{\n        #population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[13]] <- \"test\"\n      }\n\n      if(new.bv.child==\"obs\"){\n        population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[15]] <- n.observation\n      } else{\n        population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[15]] <- 0\n      }\n\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[16]] <- 0\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[19]] <- child1[[7]]\n      population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[20]] <- child2[[7]]\n\n\n      if(store.comp.times.generation){\n        tock <- as.numeric(Sys.time())\n        generation_stuff <- generation_stuff + tock -tack\n      }\n      if(population$info$bve){\n        activ_bv <- which(population$info$bv.random[1:population$info$bve.calc]==FALSE)\n        if(length(activ_bv)>0){\n          temp_out <- calculate.bv(population, current.gen+1, gender, current.size[gender], activ_bv, import.position.calculation=import.position.calculation, decodeOriginsU=decodeOriginsU, store.effect.freq=store.effect.freq, bit.storing=bit.storing, nbits=nbits, output_compressed=FALSE)\n          new.bv[activ_bv] <- temp_out[[1]]\n          if(store.effect.freq){\n            if(length(population$info$store.effect.freq) < (current.gen+1) || length(population$info$store.effect.freq[[current.gen+1]])==0){\n              population$info$store.effect.freq[[current.gen+1]] <- temp_out[[2]]\n            } else{\n              population$info$store.effect.freq[[current.gen+1]] <- population$info$store.effect.freq[[current.gen+1]] + temp_out[[2]]\n            }\n          }\n        }\n\n        if(population$info$bve.calc > 0  && population$info$bv.random[population$info$bve.calc]){\n\n          #Means passt (Korrelation exakt wie gewünscht)\n          means <- 0.5*(population$breeding[[info.father[1]]][[6+info.father[2]]][population$info$bve.calc:population$info$bve.nr,info.father[3]] + population$breeding[[info.mother[1]]][[6+info.mother[2]]][population$info$bve.calc:population$info$bve.nr,info.mother[3]])\n\n          # Berechnung i (0-0.5)\n          varp <- kinship.emp(list(population$breeding[[info.father[1]]][[info.father[2]]][[info.father[3]]], population$breeding[[info.mother[1]]][[info.mother[2]]][[info.mother[3]]]))\n          varp <- (2 - (2* (varp[1,1]-0.5) + 2 * (varp[2,2]- 0.5)))/4\n\n          if(FALSE){\n            new.bv[population$info$bve.calc:population$info$bve.nr] <- stats::rnorm(1, mean=means, sd= sqrt(var*population$info$bv.random.variance[bven]))\n          } else{\n            if(population$info$bve.calc==1){\n              population$info$current.bv.random.variance <- varp * population$info$bv.random.variance\n              bv.var <- diag(sqrt(population$info$current.bv.random.variance)) %*%population$info$current.bv.correlation %*% diag(sqrt(population$info$current.bv.random.variance))\n              single.mean <- means\n            } else{\n              #population$info$current.bv.random.variance <- c(population$info$bv.random.variance[1:(population$info$bve.calc-1)], population$info$bv.random.variance[population$info$bve.calc:population$info$bve.nr])\n              population$info$current.bv.random.variance <- c(population$info$bv.random.variance[1:(population$info$bve.calc-1)],varp * population$info$bv.random.variance[population$info$bve.calc:population$info$bve.nr])\n\n              AA <- diag(sqrt(population$info$current.bv.random.variance)[1:(population$info$bve.calc-1)]) %*% population$info$current.bv.correlation[1:(population$info$bve.calc-1), 1:(population$info$bve.calc-1)]%*% diag(sqrt(population$info$current.bv.random.variance)[(1:(population$info$bve.calc-1))])\n              BB <- diag(sqrt(population$info$current.bv.random.variance)[1:(population$info$bve.calc-1)]) %*%population$info$current.bv.correlation[1:(population$info$bve.calc-1), -(1:(population$info$bve.calc-1))]%*% diag(sqrt(population$info$current.bv.random.variance)[-(1:(population$info$bve.calc-1))])\n              CC <- diag(sqrt(population$info$current.bv.random.variance)[-(1:(population$info$bve.calc-1))]) %*%population$info$current.bv.correlation[-(1:(population$info$bve.calc-1)), -(1:(population$info$bve.calc-1))] %*% diag(sqrt(population$info$current.bv.random.variance)[-(1:(population$info$bve.calc-1))])\n              if (requireNamespace(\"MASS\", quietly = TRUE)) {\n                bv.var <- CC - t(BB) %*% MASS::ginv(AA) %*% BB\n                single.mean <- means + t(BB) %*% MASS::ginv(AA) %*% ( new.bv[1:(population$info$bve.calc-1)]-mu1[1:(population$info$bve.calc-1)])\n              } else{\n                bv.var <- CC - t(BB) %*% solve(AA) %*% BB\n                single.mean <- means + t(BB) %*% solve(AA) %*% ( new.bv[1:(population$info$bve.calc-1)]-mu1[1:(population$info$bve.calc-1)])\n              }\n\n\n            }\n\n            bv.var_chol <- t(chol(bv.var))\n            population$info$bv.correlation_col <- bv.var_chol\n\n#            random_part <- varp * bv.var_chol %*% stats:rnorm(population$info$bve.nr - population$info$bve.calc +1, 0,1 )\n            random_part <- bv.var_chol %*% stats::rnorm(population$info$bve.nr - population$info$bve.calc +1, 0,1 )\n            means_part <- single.mean\n\n\n            new.bv[population$info$bve.calc:population$info$bve.nr] <-   single.mean  + random_part\n            #new.bv[population$info$bve.calc:population$info$bve.nr] <- bv.var_chol %*% stats::rnorm(population$info$bve.nr - population$info$bve.calc +1, 0,1 ) + single.mean\n          }\n\n\n        }\n\n        for(bven in 1:population$info$bve.calc){\n          if(new.bv.child==\"mean\"){\n            population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[15]] <- 0\n            new.bv_approx[bven] <- mean(c(population$breeding[[child1[[4]][1]]][[8+child1[[4]][2]]][bven,child1[[4]][3]],population$breeding[[child2[[4]][1]]][[8+child2[[4]][2]]][bven,child2[[4]][3]]))\n          } else if(new.bv.child==\"obs\"){\n            temp_random <- matrix(stats::rnorm(population$info$bve.nr*n.observation,0,1), ncol=n.observation)\n            for(bven in 1:population$info$bve.nr){\n              new.bv_approx[bven] <- (rowMeans(population$info$pheno.correlation %*% temp_random)[bven] * sqrt(sigma.e[bven]) + new.bv[bven])\n              # standartisierung doppelt gemoppelt?\n#              new.bv_approx[bven] <- (rowMeans(population$info$pheno.correlation %*% temp_random)[bven] * sqrt(sigma.e[bven]/n.observation) + new.bv[bven])\n            }\n            new.bv_approx[bven] <- stats::rnorm(1, new.bv[bven], sd=sqrt(sigma.e[bven]/population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[15]]))\n          } else if(new.bv.child==\"zero\"){\n            population$breeding[[current.gen+1]][[gender]][[current.size[gender]]][[15]] <- 0\n            new.bv_approx[bven] <- 0\n          }\n        }\n\n     }\n\n      population$breeding[[current.gen+1]][[2+gender]][,current.size[gender]] <- rep(0, population$info$bve.nr)\n      population$breeding[[current.gen+1]][[6+gender]][,current.size[gender]] <- new.bv\n      population$breeding[[current.gen+1]][[8+gender]][,current.size[gender]] <- new.bv_approx\n      #    } else if(length(population$breeding[[current.gen+1]][[gender+2]])==0){\n      #      population$breeding[[current.gen+1]][[2+gender]] <- rep(0, breeding.size[gender])\n      #      population$breeding[[current.gen+1]][[4+gender]] <- rep(new.migration.level, breeding.size[gender])\n      #     population$breeding[[current.gen+1]][[6+gender]] <- new.bv[gender,]\n      #      population$breeding[[current.gen+1]][[8+gender]] <- new.bv.approx[gender,]\n\n      if(store.comp.times.generation){\n        tock2 <- as.numeric(Sys.time())\n        bv_stuff <- bv_stuff+tock2-tock\n      }\n      current.size[gender] <- current.size[gender] +1\n    }\n  }\n\n  delete.haplotypes <- delete.haplotypes[delete.haplotypes>1]\n  if(length(delete.haplotypes)>0){\n    for(gen_r in delete.haplotypes){\n      for(gender in 1:2){\n        n.animals <- length(population$breeding[[gen_r]][[gender]])\n        if(n.animals>0){\n          for(index2 in 1:n.animals){\n            population$breeding[[gen_r]][[gender]][[index2]][[9]] <- \"removed\"\n            population$breeding[[gen_r]][[gender]][[index2]][[10]] <- \"removed\"\n          }\n        }\n      }\n    }\n  }\n  delete.individuals <- delete.individuals[delete.individuals>1]\n  if(length(delete.individuals)>0){\n    for(gen_r in delete.individuals){\n      for(gender in delete.gender){\n        n.animals <- length(population$breeding[[gen_r]][[gender]])\n        if(n.animals>0){\n          population$breeding[[gen_r]][[gender]]<- \"removed\"\n\n        }\n      }\n    }\n  }\n  if(store.breeding.totals){\n    cur <- length(population$info$breeding.totals) + 1L\n    population$info$breeding.totals[[cur]] <- list()\n    population$info$breeding.totals[[cur]][[1]] <- current.gen +1L\n    population$info$breeding.totals[[cur]][[2]] <- breeding.size\n    population$info$breeding.totals[[cur]][[3]] <- best[[1]]\n    population$info$breeding.totals[[cur]][[4]] <- best[[2]]\n    population$info$breeding.totals[[cur]][[5]] <- selection.rate[[1]]\n    population$info$breeding.totals[[cur]][[6]] <- selection.rate[[2]]\n  }\n\n  if(store.bve.data && bve){\n    cur <- length(population$info$bve.data) + 1\n    population$info$bve.data[[cur]] <- list()\n    population$info$bve.data[[cur]][[1]] <- current.gen\n    population$info$bve.data[[cur]][[2]] <- sigma.e\n    population$info$bve.data[[cur]][[3]] <- sigma.e.hat\n    population$info$bve.data[[cur]][[4]] <- sigma.s\n    population$info$bve.data[[cur]][[5]] <- sigma.a.hat\n    population$info$bve.data[[cur]][[6]] <- bve.database\n    population$info$bve.data[[cur]][[7]] <- new.bv.observation\n    population$info$bve.data[[cur]][[8]] <- y_real\n    population$info$bve.data[[cur]][[9]] <- y_hat\n    population$info$bve.data[[cur]][[10]] <- y\n  }\n  population$info$last.sigma.e <- sigma.e\n\n\n  if(store.comp.times){\n    comp_times[7] <- as.numeric(Sys.time())\n    comp_times <- c(comp_times[-1] - comp_times[-length(comp_times)], comp_times[length(comp_times)]-comp_times[1])\n    population$info$comp_times <- round(rbind(population$info$comp_times, comp_times, deparse.level = 0), digits=4)\n    if(nrow(population$info$comp_times)==1){\n      colnames(population$info$comp_times) <- c(\"Preparation\", \"New_Real_ZW\", \"Phenotypes\", \"ZWS\",\"Selektion\",\"Generation\",\"Total\")\n    }\n  }\n  if(store.comp.times.bve){\n    comp_times_bve <- c(comp_times_bve[-1] - comp_times_bve[-length(comp_times_bve)], zcalc, z_chol, z_uhat, comp_times_bve[length(comp_times_bve)]-comp_times_bve[1])\n    population$info$comp_times_bve <- round(rbind(population$info$comp_times_bve, comp_times_bve, deparse.level = 0), digits=4)\n    if(nrow(population$info$comp_times_bve)==1){\n      colnames(population$info$comp_times_bve) <- c(\"y_z_import\", \"a_calculation\", \"solveMixed\",\"Gwas_stuff\", \"zcalc\", \"z_chol\", \"z_uhat\", \"Total\")\n    }\n  }\n  if(store.comp.times.generation){\n    comp_times_generation <- c(pre_stuff, generation_stuff, bv_stuff, sum(pre_stuff, generation_stuff, bv_stuff))\n    population$info$comp_times_generation <- round(rbind(population$info$comp_times_generation, comp_times_generation, deparse.level = 0), digits=4)\n    if(nrow(population$info$comp_times_generation)==1){\n      colnames(population$info$comp_times_generation) <- c(\"Preparation\", \"Generation\", \"BV-Calculation\", \"Total\")\n    }\n  }\n\n  if(length(name.cohort)>0){\n    population$info$cohorts <- rbind(population$info$cohorts, c(current.gen+1, breeding.size[1:2], new.migration.level, current.size-breeding.size))\n    if(nrow(population$info$cohorts)==1){\n      colnames(population$info$cohorts) <- c(\"generation\", \"male individuals\", \"female individuals\", \"migration level\", \"position first male\", \"position first female\")\n    }\n  }\n  if(Rprof){\n    Rprof(NULL)\n    population$info$Rprof[[length(population$info$Rprof)+1]] <- utils::summaryRprof()\n  }\n  return(population)\n}\n\n",
    "created" : 1535265952538.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1846926420",
    "id" : "7CD35C2C",
    "lastKnownWriteTime" : 1535966147,
    "last_content_update" : 1535966147730,
    "path" : "C:/Users/tpook/Desktop/R-Stuff/MoBPS/R/breeding.diploid.R",
    "project_path" : "R/breeding.diploid.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}