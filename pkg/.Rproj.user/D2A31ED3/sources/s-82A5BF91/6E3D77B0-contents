#### Funktion zur Optimierung; Verhindert negative Werte:
OCT <- function(A,u,Q,cAc=NA){                # bei NA wird cAc (Increase of average relationship) minimiert

Opt.int <- function(A, u, Q, cAc=NA){

 A1 <- solve(A)
 QAQ1 <- solve(t(Q)%*%A1%*%Q)
 minA <- round(0.25*sum(QAQ1)+0.000005,5)
 if(!is.na(cAc)){
  if(minA>cAc){stop(paste("Minimal increase possible is for cAc is ",minA,sep=""))}
 }else{
  cAc <- minA
 }
 lambda0 <- as.numeric(sqrt((t(u)%*%(A1-A1%*%Q%*%QAQ1%*%t(Q)%*%A1)%*%u)/(4*cAc-sum(QAQ1))) )
 lambda <- QAQ1%*%(t(Q)%*%A1%*%u - lambda0)

 xopt <- A1%*%(u-Q%*%lambda)/(2*lambda0)
 return(list(xopt,cAc))
}

 rr <- Opt.int(A,u,Q,cAc)
 xopt <- rr[[1]]
 minA <- rr[[2]]
 n <- length(u)
 names(u) <- 1:n
 for(i in 1:length(xopt)){
  if((min(xopt) >= 0)){break}
  neg <- which(xopt < 0)
  A <- A[-neg,-neg]
  u <- u[-neg]
  Q <- Q[-neg,]
  if(length(u)==2){xopt=rep(0.5,2);break}
  xopt <- Opt.int(A,u,Q,cAc)[[1]]
 }
 res <- numeric(n)
 res[as.numeric(names(u))] <- xopt
 print(paste("Minimal increase is ",minA,sep=""))
 return(list("Optimal c"=res, "c'u"=t(xopt)%*%u))
 }
save(OCT, file="OCTFunction.RData")


#### Paramter eingeben:
A <- rbind(c(1,0.25,0.5,0),c(0.25, 1,0.125,0.125),c(0.5,0.125,1.0625,0),c(0,0.125,0,1))
u <- c(100,80,120,110)
Q <- cbind(c(1,1,0,0),c(0,0,1,1))
minA <- 0.25*sum(solve(t(Q)%*%solve(A)%*%Q))
cAc <- 0.9


#### Funktion aufrufen:
OCT(A=A,u=u,Q=Q)
OCT(A=A,u=u,Q=Q,cAc=0.369)
OCT(A=A,u=u,Q=Q,cAc=0.3789)


A <- matrix(0,ncol=14,nrow=14)
A[upper.tri(A,diag=FALSE)] <- sample(c(0,0.125,0.25,0.5),91,replace=TRUE)
A <- A + t(A)
diag(A) <- runif(14,1,1.2)
diag(A)[sample(1:14,10)] <- 1
write.table(A, file="Amatrix_Ex1.txt",quote=FALSE, col.names=FALSE,row.names=FALSE)
