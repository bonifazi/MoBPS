'#
  Authors
Torsten Pook, torsten.pook@uni-goettingen.de

Copyright (C) 2017 -- 2018  Torsten Pook

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 3
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
'#

#' Generation of the starting population
#'
#' Generation of the starting population
#' @param file Path to a json-file generated by the user-interface
#' @param total Json-file imported via jsonlite::read_json
#' @param miraculix Use miraculix in simulation
#' @param remove.effect.position should be included in the interface!
#' @export

json.simulation <- function(file=NULL, total=NULL, miraculix=TRUE, remove.effect.position=FALSE){
  if(length(file)>0){
    if (requireNamespace("jsonlite", quietly = TRUE)) {
      total <- jsonlite::read_json(path="C:/Users/pook/Desktop/chicken_4lineCross_v7.json")
    } else{
      stop("Usage of jsonlite without being installed!")
    }

  }
  nodes <- total[[1]]
  edges <- total[[2]]
  geninfo <- unique(total[[3]])
  traitinfo <- total[[4]]
  major <- list()
  n_traits <- length(traitinfo)
  for(index in 1:n_traits){
    major[[index]] <- total[[index+4]]
  }

  cor_gen <- matrix(as.numeric(unlist(total[[15]])), nrow=n_traits, ncol=n_traits)
  cor_pheno <- matrix(as.numeric(unlist(total[[16]])), nrow=n_traits, ncol=n_traits)


  ######################## REALITY - CHECKS ############################
  {
    # Correct nodes are Founders
    ids <- possible_founder <-  numeric(length(nodes))
    for(index in 1:length(nodes)){
      ids[index] <- nodes[[index]]$id
    }
    for(index in 1:length(edges)){
      possible_founder[which(edges[[index]]$to==ids)] <- 1
    }

    for(index in which(possible_founder==0)){
      if(nodes[[index]]$Founder=="No"){
        nodes[[index]]$Founder <- "Yes"
        cat(paste0("Changed Note ", nodes[[index]]$id, " to Founder-Note! No incoming edge\n"))
      }
    }

    # All edges
    for(index in 1:length(edges)){
      if(edges[[index]]$Breedingtype==""){
        cat(paste0("Edge ", edges[[index]]$Name, " without breeding type. Invalid breeding program!\n"))

      }
    }

    # Selected cohort is not bigger than founder cohort
    for(index in 1:length(edges)){
      from <- which(edges[[index]]$from==ids)
      to <- which(edges[[index]]$to==ids)
      if((nodes[[from]]$individuals < nodes[[to]]$individuals) && (edges[[index]]$Breedingtype=="Selection")){
        cat(paste0("more individuals selected than in founding note in ", edges[[index]]$Name, ".Automatically changed to selected all individuals\n"))
        nodes[[to]]$individuals <- nodes[[from]]$individuals
      }
    }

  }

  ################### Preparation ############################
  {
    # check for Ind
    same.sex.activ <- FALSE
    same.sex.sex <- 0.5
    for(index in 1:length(nodes)){
      if(nodes[[index]]$sex=="Indefinit"){
        for(index2 in 1:length(nodes)){
          nodes[[index2]]$sex <- "Male"
        }
        same.sex.activ <- TRUE
        same.sex.sex <- 0
      }
    }

    splits <- NULL
    n_male <- NULL
    for(index in 1:length(nodes)){
      if(nodes[[index]]$sex=="Both"){
        splits <- c(splits, nodes[[index]]$id)
        nodes[[length(nodes)+1]] <- nodes[[index]]
        nodes[[index]]$sex <- "Male"
        nodes[[length(nodes)]]$sex <- "Female"
        nodes[[index]]$id <- paste0(nodes[[index]]$id, "_M")
        nodes[[length(nodes)]]$id <- paste0(nodes[[length(nodes)]]$id, "_W")
        nodes[[index]]$label <- paste0(nodes[[index]]$label, "_M")
        nodes[[length(nodes)]]$label <- paste0(nodes[[length(nodes)]]$label, "_W")
        nodes[[index]]$individuals <- round(as.numeric(nodes[[index]]$individuals) * as.numeric(nodes[[index]]$MaleGenderQuota))
        n_male <- c(n_male,nodes[[index]]$individuals)
        nodes[[length(nodes)]]$individuals <- as.numeric(nodes[[length(nodes)]]$individuals) - nodes[[index]]$individuals
        nodes[[index]]$MaleGenderQuota <- 1
        nodes[[length(nodes)]]$MaleGenderQuota <- 0
      }
    }

    for(index in 1:length(edges)){
      wfrom <- which(edges[[index]]$from==splits)
      wto <- which(edges[[index]]$to==splits)
      if(length(wfrom)>0 && length(wto)>0){
        edges[[length(edges)+1]] <- edges[[index]]
        edges[[index]]$to <- paste0(edges[[index]]$to, "_M")
        edges[[length(edges)]]$to <- paste0(edges[[length(edges)]]$to, "_W")
        edges[[index]]$from <- paste0(edges[[index]]$from, "_M")
        edges[[length(edges)]]$from <- paste0(edges[[length(edges)]]$from, "_W")
      } else if(length(wto)>0){
        edges[[length(edges)+1]] <- edges[[index]]
        edges[[index]]$to <- paste0(edges[[index]]$to, "_M")
        edges[[length(edges)]]$to <- paste0(edges[[length(edges)]]$to, "_W")
      } else if(length(wfrom)>0){
        edges[[length(edges)+1]] <- edges[[index]]
        edges[[index]]$from <- paste0(edges[[index]]$from, "_M")
        edges[[length(edges)]]$from <- paste0(edges[[length(edges)]]$from, "_W")
      }

    }



    ids <- numeric(length(nodes))
    sex <- numeric(length(nodes))
    for(index in 1:length(nodes)){
      ids[index] <- nodes[[index]]$id
      sex[index] <- as.numeric(nodes[[index]]$sex=="Female")
    }

    # Remove sex-switch
    for(index in length(edges):1){
      sex1 <- sex[which(edges[[index]]$from==ids)]
      sex2 <- sex[which(edges[[index]]$to==ids)]
      if(sex1!=sex2 && edges[[index]]$Breedingtype!="Reproduction"){
        edges[[index]] <- NULL
      }
    }

    # Identify founder cohorts
    # Add "Founder" as a breeding type - If selected allow for a dataset to be imported!
    founder <- NULL
    ids <- numeric(length(nodes))
    repeat_node <- numeric(length(nodes))
    for(index in 1:length(nodes)){
      if(nodes[[index]]$Founder=="Yes"){
        founder <- c(founder,index)
      }
      ids[index] <- nodes[[index]]$id
    }
    for(index in 1:length(edges)){
      if(edges[[index]]$Breedingtype=="Repeat"){
        repeat_node[which(edges[[index]]$from==ids)] <- 1
      }
    }

    ## Check for repeats
    link2 <- NULL

    for(index in 1:length(edges)){
      link <- NULL

      if(edges[[index]]$Breedingtype=="Repeat"){
        n_rep <- as.numeric(edges[[index]]$NumberOfRepeat)
        nodes_to_repeat <- NULL
        edges_to_repeat <- NULL
        start <- which(ids==edges[[index]]$to)
        step <- start
        prev <- NULL
        while(length(step)!=length(prev)||length(prev)==0){
          prev <- step
          for(index2 in 1:length(edges)){
            desti <- which(edges[[index2]]$to==ids)
            ori <- which(edges[[index2]]$from==ids)
            if(repeat_node[ori]){
              #          if(index!=index2){
              # Ermittle weiter Knoten Quelle fuer neuen Repeat
              for(index3 in 1:length(edges)){
                if(edges[[index3]]$Breedingtype=="Repeat" && edges[[index3]]$from==edges[[index2]]$from){
                  start <- unique(c(start, which(edges[[index3]]$to==ids)))
                  step <- unique(c(step, which(edges[[index3]]$to==ids)))
                  link <- rbind(link, c(ori, which(edges[[index3]]$to==ids)))
                  link2 <- unique(c(link2, index3))
                  edges[[index3]]$Breedingtype <- "PerformedRepeat"
                }
                #           }
              }
            } else{
              if(sum(ori==prev)>0){

                step <- unique(c(step, desti))
                edges_to_repeat <- unique(c(edges_to_repeat, index2))
              }

            }
          }
        }

        nodes_to_repeat <- step[!duplicated(c(start, step))[-(1:length(start))]]
        nodes_to_repeat <- sort(nodes_to_repeat)
        edges_to_repeat <- sort(edges_to_repeat)
        link <- unique(link)
        #    for(index4 in start){
        #      edges[[index4]]$Breedingtype <- "PerformedRepeat"
        #    }
        for(index4 in 1:n_rep){
          for(nodrep in nodes_to_repeat){
            nodes[[length(nodes)+1]] <- nodes[[nodrep]]
            nodes[[length(nodes)]]$Founder <- "No"
            nodes[[length(nodes)]]$id <- paste0(nodes[[length(nodes)]]$id, "_",index4)
            nodes[[length(nodes)]]$label <- paste0(nodes[[length(nodes)]]$label, "_",index4)
          }
          for(edgesrep in edges_to_repeat){
            edges[[length(edges)+1]] <- edges[[edgesrep]]
            test <- ids[start]==edges[[length(edges)]]$from
            if(sum(test)){
              take <- link[which(link[,2]==start[which(test)]),1]
              if(index4==1){
                edges[[length(edges)]]$from <- paste0(ids[take])
              } else{
                edges[[length(edges)]]$from <- paste0(ids[take],"_", index4-1)
              }

            } else{
              edges[[length(edges)]]$from <- paste0(edges[[length(edges)]]$from,"_", index4)
            }

            edges[[length(edges)]]$to <- paste0(edges[[length(edges)]]$to,"_", index4)
            edges[[length(edges)]]$id <- paste0(edges[[length(edges)]]$id,"_", index4)
          }
        }

        for(sonstcheck in (1:length(ids))[-step]){
          for(edgeindex in 1:length(edges)){
            if(edges[[edgeindex]]$to==ids[sonstcheck] && sum(edges[[edgeindex]]$from==ids[nodes_to_repeat])>0){
              edges[[sonstcheck]]$from <- paste0(edges[[sonstcheck]]$from, "_", n_rep)
            }
          }
        }

        founder <- NULL
        ids <- numeric(length(nodes))
        repeat_node <- numeric(length(nodes))
        for(index in 1:length(nodes)){
          if(nodes[[index]]$Founder=="Yes"){
            founder <- c(founder,index)
          }
          ids[index] <- nodes[[index]]$id
        }
        for(index in 1:length(edges)){
          if(edges[[index]]$Breedingtype=="Repeat"){
            repeat_node[which(edges[[index]]$from==ids)] <- 1
          }
        }
      }
    }

    for(changeto in sort(link2, decreasing = TRUE)){
      edges[[changeto]] <- NULL
    }

    ## Determine genetic architecture
    if(geninfo[[1]]$Length_of_Chromosomes=="True"){
      nchromo <- as.numeric(geninfo[[1]]$chromosomes)
      nsnp <- as.numeric(rep(geninfo[[1]]$SNPs, nchromo))
      chromo.length <- as.numeric(rep(geninfo[[1]]$GenomeLength, nchromo)) /100
    } else{
      nchromo <- as.numeric(geninfo[[1]]$Different_Number_of_Chromo)
      nsnp <- NULL
      chromo.length <- NULL
      for(index in 1:nchromo){
        name1 <- paste0("chromo", index, "_Length")
        name2 <- paste0("chromo", index, "_MD")
        chromo.length <- c(chromo.length, geninfo[[1]][[name1]]/100)
        nsnp <- c(nsnp, round(geninfo[[1]][[name1]]/100 * geninfo[[1]][[name2]] ))
      }
    }

    trait_matrix <- matrix(unlist(traitinfo), nrow=n_traits, byrow=TRUE)

    #traitmean <- as.numeric(c(geninfo[[1]]$MilkYield_Mean, geninfo[[1]]$NonReturnRate_Mean, geninfo[[1]]$SomaticCellScore_Mean))
    traitmean <- as.numeric(trait_matrix[,4])
    trait_weigths <- as.numeric(trait_matrix[,9])
    groups <- length(nodes)
    #heritability <- as.numeric(c(geninfo[[1]]$MilkYield_Hertit, geninfo[[1]]$NonReturnRate_Hertit, geninfo[[1]]$SomaticCellScore_Hertit))
    heritability <- as.numeric(trait_matrix[,6])

    # Species not needed, traitvariance not needed,
    position <- matrix(0, nrow=length(nodes), ncol=4)
    rownames(position) <- ids
    founding_a <- c(0,0)
    mig_m <- numeric(0)
    mig_f <- numeric(0)

    sex.s <- NULL
    # CHECK FOR ME THAN 2 FOUNDERS (MORE THAN 1 of a sex- Migration level...)
    new_mig <- c(0,0)


    founder_data <- FALSE
    for(index in 1:length(founder)){

      sex <- as.numeric(nodes[[founder[index]]]$sex=="Female")+1
      size <- as.numeric(nodes[[founder[index]]]$individuals)
      founding_a[sex] <- founding_a[sex] + size
      sex.s <- c(sex.s, rep(sex, size))
      if(sex==1){
        mig_m <- c(mig_m, rep(new_mig[1], size))
        mig <- new_mig[2]
        new_mig[1] <- new_mig[1] + 1
      }
      if(sex==2){
        mig_f <- c(mig_f, rep(new_mig[2], size))
        mig <- new_mig[2]
        new_mig[2] <- new_mig[2] + 1
      }
      position[founder[index],] <- c(1, sex, mig, size)
      if(length(nodes[[founder[index]]]$path)>0){
        founder_data <- TRUE
      }

    }
  }


  ################### Import genetic data #############################
  {
    dataset <- "random"
    if(founder_data){
      dataset <- matrix(0L, nrow= sum(nsnp), ncol = sum(position[,4])*2)
      path_list <- NULL
      no_data <- numeric(length(founder))
      for(index in 1:length(founder)){
        path_list <- c(path_list, nodes[[founder[index]]]$path )
      }
      starts <- cumsum(c(1, position[founder,4]))*2-1
      for(path in unique(c("",path_list))[-1]){
        load(path)
        takes <- which(path_list==path)
        no_data[takes] <- 1
        take <- NULL
        for(index in takes){
          take <- c(take, starts[index]:(starts[index+1]-1))
        }
        if(nrow(haplo)!=sum(nsnp)){
          nsnp <- floor(nsnp*nrow(haplo)/sum(nsnp))
          nsnp[1] <- nsnp[1] + nrow(haplo)-sum(nsnp)
          dataset <- matrix(0L, nrow= sum(nsnp), ncol = sum(position[,4])*2)
        }
        if(length(haplo) != length(dataset[,take])){
          cat("Size of Founder-dataset not in concorance with node size!\n")
          haplo <- rep(haplo, length.out=length(dataset[,take]))
        }
        dataset[,take] <- haplo
      }
      if(sum(no_data==0)>0){
        takes <- which(no_data==0)
        take <- NULL
        for(index in takes){
          take <- c(take, starts[index]:(starts[index+1]-1))
        }
        p_i <- miraculix::allele_freq(miraculix::createSNPmatrix(dataset[,-takes]))*2
        dataset[,take] <- stats::rbinom(nrow(dataset)*length(take),1, prob=p_i)
      } else{
        p_i <- miraculix::allele_freq(miraculix::createSNPmatrix(dataset))*2
      }
    }

  }

  ############### Generate Base-Population
  {
    population <- NULL

    chr.nr <- sum(nsnp)
    cumsnp <- cumsum(c(1, nsnp))
    for(index in 1:length(nsnp)){
      if(nsnp[index]>0){
        chr.nr[cumsnp[index]:(cumsnp[index+1]-1)] <- index
      }

    }
    population <- creating.diploid(dataset = dataset, nsnp = sum(nsnp), nindi=length(sex.s),
                                   sex.s = sex.s, chromosome.length = chromo.length,
                                   snps.equidistant = TRUE, miraculix = miraculix,
                                   chr.nr = chr.nr
    )
    # Cohort names
    cohort_info <- cbind(ids[founder], 1, position[founder,4], position[founder,4], position[founder,3], 1+cumsum(c(0,position[founder,4]))[-length(founder)], 1+cumsum(c(0,position[founder,4]))[-length(founder)] - sum(sex.s==1) )

    cohort_info[(cohort_info[,7]>=1),c(3,6)] <- 0
    cohort_info[(cohort_info[,7]<1),c(4,7)] <- 0


    population$info$cohorts <- cohort_info

    colnames(population$info$cohorts) <- c("name","generation", "male individuals", "female individuals", "class", "position first male", "position first female")



    population <- creating.trait(population, n.additive = as.numeric(trait_matrix[,7]),
                                 shuffle.cor = cor_gen, new.phenotype.correlation = cor_pheno,
                                 shuffle.traits=1:n_traits)


    pheno.sex <- c(1,2)

    if(length(dataset)==1){
      mgen <- rep(1,sum(population$info$size[1,]))
      msex <- c(rep(1,population$info$size[1,1]), rep(2, population$info$size[1,2]))
      mnr <- c(1:population$info$size[1,1], 1:population$info$size[1,2])
      if(population$info$size[1,1]==0){
        mnr <- 1:population$info$size[1,2]
      }
      if(population$info$size[1,2]==0){
        mnr <- 1:population$info$size[1,1]
      }
      mgeno <- miraculix::computeSNPS(population, mgen, msex, mnr, what = "geno", output_compressed=TRUE)
      p_i <- miraculix::allele_freq(mgeno)
    }
    # Correct Scaling


    snp.before <- cumsum(c(0,population$info$snp))
    for(index in 1:n_traits){
      effect_p <- population$info$real.bv.add[[index]][,1]+ snp.before[population$info$real.bv.add[[index]][,2]]
      mean <- population$info$real.bv.add[[index]][,3]*(1-p_i[effect_p])^2 + population$info$real.bv.add[[index]][,4]*(1-p_i[effect_p])*p_i[effect_p] +
        population$info$real.bv.add[[index]][,5]*(p_i[effect_p])^2
      new_var <- as.numeric(trait_matrix[index,5])
      old_var <- sum((population$info$real.bv.add[[index]][,3]-mean)^2*(1-p_i[effect_p])^2)+
        sum((population$info$real.bv.add[[index]][,4]-mean)^2*(1-p_i[effect_p])*p_i[effect_p]) +
        sum((population$info$real.bv.add[[index]][,5]-mean)^2*(p_i[effect_p])^2)
      population$info$real.bv.add[[index]][,3:5] <- population$info$real.bv.add[[index]][,3:5] * sqrt(new_var / old_var)

      mqtl <- NULL
      if(length(major[[index]])>0){
        for(index in 1:length(major[[index]])){
          rbind(mqtl, as.numeric(unlist(major[[index]]))[1:7])
        }
      }
      mqtl <- mqtl[mqtl[,1]!=0,,drop=FALSE]
      population$info$real.bv.add[[index]] <- rbind(population$info$real.bv.add[[index]],
                                                    mqtl[,c(1,4:7)])
      population$info$base.bve[index] <- traitmean[index] - sum(mqtl[,5:7]*c(1,2,1)/4) - sum(mean)
    }


    population$breeding[[1]][[5]] <- mig_m
    population$breeding[[1]][[6]] <- mig_f

  }


  ################## Last preps ########################
  {
    simulated <- founder
    left <- (1:groups)[-simulated]

    # Add edges info to nodes
    for(index in 1:length(edges)){
      to_node <- which(edges[[index]]$to==ids)
      nodes[[to_node]]$Breedingtype <- edges[[index]]$Breedingtype
      if(nodes[[to_node]]$Breedingtype=="Selection"){
        nodes[[to_node]]$selectionType <- edges[[index]]$selectionType
        nodes[[to_node]]$proportion <- edges[[index]]$proportion
        nodes[[to_node]]$origin <- edges[[index]]$from
        nodes[[to_node]]$RelationshipMatrix <- edges[[index]]$RelationshipMatrix
        nodes[[to_node]]$BVEMethod <- edges[[index]]$BVEMethod
        nodes[[to_node]]$offspring <- edges[[index]]$offspring
      }
      if(nodes[[to_node]]$Breedingtype=="Reproduction"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
      }
      if(nodes[[to_node]]$Breedingtype=="Recombination"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
        nodes[[to_node]]$mutation <- edges[[index]]$New_Mutation_Rate
        nodes[[to_node]]$remutation <- edges[[index]]$New_Remutation_Rate
        nodes[[to_node]]$recom <- edges[[index]]$Number_of_Recombination_Per_M
      }
      if(nodes[[to_node]]$Breedingtype=="Reproduction_Selfing"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
      }
      if(nodes[[to_node]]$Breedingtype=="DH_Gene"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
      }
      if(nodes[[to_node]]$Breedingtype=="Cloning"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
      }
      if(nodes[[to_node]]$Breedingtype=="Combine"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
      }

    }

    phenotype_groups <- numeric(length(nodes))
    for(index in 1:length(edges)){
      phenotype_groups[which(ids==edges[[index]]$from)] <- 1
    }

    priority_breeding <- ids[(1-phenotype_groups)*1:length(ids)]


    n_tester <- n_tester_generated <- numeric(length(nodes))
    for(index in 1:length(edges)){
      if(length(intersect(priority_breeding, edges[[index]]$to))){
        n_tester[which(ids==edges[[index]]$from)] <- n_tester[which(ids==edges[[index]]$from)] +1
      }
    }


  }


  ############## Actual simulations ########################
  {
    generation <- 1
    while(length(left)>0){
      generation <- generation + 1
      cat(paste0("Start simulation of generation:", generation,"\n"))
      possible <- ids[left]
      stock <- ids[-left]
      for(index in 1:length(edges)){
        there <- which(edges[[index]]$to==possible)
        if(length(there)>0){


          if(sum(edges[[index]]$from==stock)==0){
            if(possible[there]=="B_pre_sel") cat(index)
            possible <- possible[-there]

          }
        }
      }
      if(length(intersect(possible, priority_breeding))>0){
        possible <- intersect(possible, priority_breeding)
      } else{
        stock <- ids[-unique(c(left, (n_tester>n_tester_generated)*(1:length(n_tester))))]
        for(index in 1:length(edges)){
          there <- which(edges[[index]]$to==possible)
          if(length(there)>0){


            if(sum(edges[[index]]$from==stock)==0){
              possible <- possible[-there]
            }
          }
        }
      }
      # Remove group for which not all testers are generated

      if(length(possible)==0){
        stop("invalite breeding program")
      }
      for(group in possible){
        groupnr <- which(ids==group)
        simulated <- c(simulated, groupnr)
        sex <- as.numeric(nodes[[groupnr]]$sex=="Female") + 1


        breeding.size <- as.numeric(nodes[[groupnr]]$individual) * c(sex==1, sex==2)
        involved_groups <- position[nodes[[groupnr]]$origin,,drop=FALSE]
        involved_groups <- unique(position[nodes[[groupnr]]$origin,,drop=FALSE])
        selection.size <- c(sum(involved_groups[,4]*(involved_groups[,2]==1)), sum(involved_groups[,4] * (involved_groups[,2]==2)))


        used.generations.m <- numeric(generation-1)
        for(index in 1:nrow(involved_groups)){
          if(involved_groups[index,2]==1){
            used.generations.m[involved_groups[index,1]] <- used.generations.m[involved_groups[index,1]] + involved_groups[index,4]
          }
        }
        used.generations.w <- numeric(generation-1)
        for(index in 1:nrow(involved_groups)){
          if(involved_groups[index,2]==2){
            used.generations.w[involved_groups[index,1]] <- used.generations.w[involved_groups[index,1]] + involved_groups[index,4]
          }
        }
        migration.level.m <- involved_groups[involved_groups[,2]==1,3]
        migration.level.w <- involved_groups[involved_groups[,2]==2,3]


        if(nodes[[groupnr]]$Breedingtype=="Selection"){
          activemmreml <- FALSE
          activbglr <- FALSE
          if(nodes[[groupnr]]$selectionType=="Phenotypic"){
            bve <- FALSE
            selection <- "function"
            phenotype.bv <- TRUE
            computeA <- "vanRaden"
          } else if(nodes[[groupnr]]$selectionType=="Random"){
            bve <- FALSE
            selection <- "random"
            phenotype.bv <- FALSE
            computeA <- "vanRaden"
          } else if(nodes[[groupnr]]$selectionType=="BVE"){
            bve <- TRUE
            selection <- "function"
            phenotype.bv <- FALSE
            if(nodes[[groupnr]]$RelationshipMatrix=="Pedigree"){
              cat("Dont use Pedigree currently\n")
            } else{
              computeA <- "vanRaden"
            }
            if(nodes[[groupnr]]$BVEMethod=="REML-GBLUP"){
              activemmreml <- TRUE
            } else if(nodes[[groupnr]]$BVEMethod=="RKHS") {
              activbglr <- TRUE
            }
          }
          if(nodes[[groupnr]]$offspring=="Yes"){
            bve.childbase.parents <- involved_groups[,1:2,drop=FALSE]
            if(length(pheno.sex)==1){
              bve.childbase.children <- cbind((min(bve.childbase.parents[,1])+1): length(used.generations.m),pheno.sex)
            } else{
              bve.childbase.children <- rbind(cbind((min(bve.childbase.parents[,1])+1): length(used.generations.m),1),
                                              cbind((min(bve.childbase.parents[,1])+1): length(used.generations.m),2))
            }

            population <- breeding.diploid(population, breeding.size=breeding.size,
                                           bve=bve, computation.A = computeA,
                                           bve.childbase=TRUE,
                                           bve.childbase.parents=bve.childbase.parents,
                                           bve.childbase.children=bve.childbase.children,
                                           BGLR.bve = activbglr,
                                           emmreml.bve = activemmreml,
                                           selection.size= breeding.size,
                                           copy.individual = TRUE,
                                           max.offspring = c(1,1),
                                           heritability = heritability,
                                           sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                           new.bv.observation = "non_obs",
                                           selection.m = selection,
                                           phenotype.bv = phenotype.bv,
                                           add.gen = generation,
                                           bve.database = involved_groups[,1:2, drop=FALSE],
                                           selfing.mating=TRUE,
                                           selfing.sex=(sex-1),
                                           class.m = migration.level.m,
                                           class.f = migration.level.w,
                                           used.generations.m = used.generations.m,
                                           used.generations.f = used.generations.w,
                                           new.class = new_mig[sex],
                                           new.bv.observation.sex = pheno.sex,
                                           multiple.bve.scale=TRUE,
                                           multiple.bve.weights = trait_weigths,
                                           remove.effect.position = remove.effect.position,
                                           name.cohort = nodes[[groupnr]]$label,
                                           bve.class=c(migration.level.m, migration.level.w))
          } else{
            population <- breeding.diploid(population, breeding.size=breeding.size,
                                           bve=bve, computation.A = computeA,
                                           BGLR.bve = activbglr,
                                           emmreml.bve = activemmreml,
                                           selection.size= breeding.size,
                                           copy.individual = TRUE,
                                           max.offspring = c(1,1),
                                           heritability = heritability,
                                           sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                           new.bv.observation = "non_obs",
                                           selection.m = selection,
                                           phenotype.bv = phenotype.bv,
                                           add.gen = generation,
                                           bve.database = involved_groups[,1:2, drop=FALSE],
                                           selfing.mating=TRUE,
                                           selfing.sex=(sex-1),
                                           class.m = migration.level.m,
                                           class.f = migration.level.w,
                                           used.generations.m = used.generations.m,
                                           used.generations.f = used.generations.w,
                                           new.class = new_mig[sex],
                                           new.bv.observation.sex = pheno.sex,
                                           multiple.bve.scale=TRUE,
                                           multiple.bve.weights = trait_weigths,
                                           remove.effect.position = remove.effect.position,
                                           name.cohort = nodes[[groupnr]]$label,
                                           bve.class=c(migration.level.m, migration.level.w))
          }

        } else if(nodes[[groupnr]]$Breedingtype=="Reproduction"){

          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= selection.size,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         #                                     phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         same.sex.activ = same.sex.activ,
                                         same.sex.sex = same.sex.sex,
                                         new.bv.observation.sex = pheno.sex,
                                         name.cohort = nodes[[groupnr]]$label)
        } else if(nodes[[groupnr]]$Breedingtype=="Reproduction_Selfing"){

          selfing.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= selection.size,
                                         selfing.mating = TRUE,
                                         selfing.sex =  selfing.sex,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         new.bv.observation.sex = pheno.sex,
                                         name.cohort = nodes[[groupnr]]$label)
        } else if(nodes[[groupnr]]$Breedingtype=="DH_Gene"){

          dh.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= selection.size,
                                         dh.mating = TRUE,
                                         dh.sex =  dh.sex,
                                         selfing.mating = TRUE,
                                         selfing.sex = dh.sex,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         new.bv.observation.sex = pheno.sex,
                                         name.cohort = nodes[[groupnr]]$label)
        } else if(nodes[[groupnr]]$Breedingtype=="Recombination"){

          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         mutation.rate = nodes[[groupnr]]$mutation,
                                         remutation.rate = nodes[[groupnr]]$remutation,
                                         recombination.rate = nodes[[groupnr]]$recom,
                                         selection.size= selection.size,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         new.bv.observation.sex = pheno.sex,
                                         name.cohort = nodes[[groupnr]]$label)
        } else if(nodes[[groupnr]]$Breedingtype=="Cloning"){

          selfing.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= selection.size,
                                         copy.individual = TRUE,
                                         selfing.mating = TRUE,
                                         selfing.sex =  selfing.sex,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         new.bv.observation.sex = pheno.sex,
                                         name.cohort = nodes[[groupnr]]$label)
        } else if(nodes[[groupnr]]$Breedingtype=="Combine"){
          selfing.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))

          if(sum(breeding.size)!=sum(c(used.generations.m,used.generations.w))){
            cat("Number of individuals in combined note doesnt fit - automatically changed!\n")
            breeding.size <- breeding.size * sum(c(used.generations.m,used.generations.w)) / sum(breeding.size)
          }
          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= breeding.size,
                                         copy.individual = TRUE,
                                         max.offspring = c(1,1),
                                         selfing.mating=TRUE,
                                         selfing.sex=selfing.sex,
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         add.gen = generation,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         name.cohort = nodes[[groupnr]]$label)
        }

        position[groupnr,] <- c(generation, sex, new_mig[sex], sum(breeding.size))
        new_mig[sex] <- new_mig[sex] + 1


        if(phenotype_groups[groupnr]==0){
          tested <- which(duplicated(c(nodes[[groupnr]]$origin, ids))[-(1:length(nodes[[groupnr]]$origin))])
          n_tester_generated[tested] <- n_tester_generated[tested] + 1
        }

      }
      cat("Generated groups:")
      cat(possible)
      left <- (1:groups)[-simulated]

    }

  }

  return(population)

}
