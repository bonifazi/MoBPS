'#
  Authors
Torsten Pook, torsten.pook@uni-goettingen.de

Copyright (C) 2017 -- 2018  Torsten Pook

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 3
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
'#

#' Generation of the starting population
#'
#' Generation of the starting population
#' @param file Path to a json-file generated by the user-interface
#' @param total Json-file imported via jsonlite::read_json
#' @param miraculix Use miraculix in simulation
#' @param remove.effect.position should be included in the interface!
#' @export

json.simulation <- function(file=NULL, total=NULL, miraculix=TRUE, remove.effect.position=FALSE){
  if(length(file)>0){
    if (requireNamespace("jsonlite", quietly = TRUE)) {
      total <- jsonlite::read_json(path=file)
    } else{
      stop("Usage of jsonlite without being installed!")
    }

  }
  nodes <- total[[1]]
  edges <- total[[2]]
  geninfo <- total[[3]]
  traitinfo <- total[[4]]
  major <- list()
  n_traits <- length(traitinfo)
  map <- NULL
  if((n_traits)>0){
    for(index in 1:n_traits){
      major[[index]] <- traitinfo[[index]]$'Trait QTL Info'
    }
  }

  selection_index_raw <- total[[5]]

  if(n_traits>0){
    selection_index_name <- numeric(n_traits)
    selection_index <- matrix(0, nrow=length(selection_index_raw), ncol=n_traits)
    for(index in 1:length(selection_index_raw)){
      selection_index[index,] <- as.numeric(unlist(selection_index_raw[[index]])[1:n_traits+1])
      selection_index_name[index] <- selection_index_raw[[index]][[1]]
    }
  }

  if(n_traits>0){
    cor_gen <- cor_pheno <- matrix(0, nrow=n_traits, ncol= n_traits)
    nr <- 1
    vector_pheno <- unlist(total[[6]])
    vector_gen <- unlist(total[[7]])
    for(index1 in 1:n_traits){
      for(index2 in index1:n_traits){
        cor_pheno[index2,index1] <- cor_pheno[index1,index2] <- vector_pheno[nr]
        cor_gen[index2,index1] <- cor_gen[index1,index2] <- vector_gen[nr]
        nr <- nr + 1
      }
    }
  }


  # Creating-types:
  # 0 - Founder
  # 1 - Selection
  # 2 - Reproduction
  # 3 - Recombination
  # 4 - Reproduction_Selfing
  # 5 - DH_Gene
  # 6 - Cloning
  # 7 - Combine
  # 8 - Aging


  #### Character - Numeric trafo ######
  for(index in 1:length(nodes)){
    nodes[[index]]$'Number of Individuals' <- as.numeric(nodes[[index]]$'Number of Individuals')
    nodes[[index]]$'Proportion of Male' <- as.numeric(nodes[[index]]$'Proportion of Male')
  }


  #### MANUEL MODIFICATION:

  {
    pheno.sex <- 1:2
    remove.effect.position <- FALSE
  }

  ######################## REALITY - CHECKS ############################
  {
    {
      for(index in 1:length(nodes)){
        if(length(nodes[[index]]$earliest_time)==0){
          print("Manually entered earliest time.")
          nodes[[index]]$earliest_time <- 0
        }
      }
    }
    {
      for(index in 1:length(edges)){
        if(length(edges[[index]]$'Time Needed')==0){
          print("Manually entered time_needed")
          if(edges[[index]]$'Breeding Type'=="Selection" ||edges[[index]]$'Breeding Type'=="Combine"){
            edges[[index]]$'Time Needed' <- 0
          } else{
            edges[[index]]$'Time Needed' <- 1
          }
        }
      }
    }
    # Diagonal of pheno/cor-matrix
    if(n_traits>0 && sum(diag(cor_gen)==1)!= nrow(cor_gen)){
      diag(cor_gen) <- 1
      print("Diagonal of cor-matrix must be 1")
    }
    if(n_traits>0 && sum(diag(cor_pheno)==1)!= nrow(cor_pheno)){
      diag(cor_pheno) <- 1
      print("Diagonal of cor-matrix must be 1")
    }


    # Correct nodes are Founders
    ids <- possible_founder <-  earliest_time <- numeric(length(nodes))
    for(index in 1:length(nodes)){
      ids[index] <- nodes[[index]]$id
      earliest_time[index] <- nodes[[index]]$earliest_time
    }
    for(index in 1:length(edges)){
      possible_founder[which(edges[[index]]$to==ids)] <- 1
    }

    for(index in which(possible_founder==0)){
      if(nodes[[index]]$Founder=="No"){
        nodes[[index]]$Founder <- "Yes"
        cat(paste0("Changed Note ", nodes[[index]]$id, " to Founder-Note! No incoming edge\n"))
      }
    }

    # All edges
    for(index in 1:length(edges)){
      if(edges[[index]]$'Breeding Type'==""){
        cat(paste0("Edge ", edges[[index]]$Name, " without breeding type. Invalid breeding program!\n"))

      }
    }

    # Selected cohort is not bigger than founder cohort
    for(index in 1:length(edges)){
      from <- which(edges[[index]]$from==ids)
      to <- which(edges[[index]]$to==ids)
      if((nodes[[from]]$'Number of Individuals' < nodes[[to]]$'Number of Individuals') && (edges[[index]]$'Breeding Type'=="Selection")){
        cat(paste0("more individuals selected than in founding note in ", edges[[index]]$Name, ".Automatically changed to selected all individuals\n"))
        nodes[[to]]$'Number of Individuals' <- nodes[[from]]$'Number of Individuals'
      }
    }

  }

  ################### Preparation ############################
  {
    # check for Ind
    same.sex.activ <- FALSE
    same.sex.sex <- 0.5
    for(index in 1:length(nodes)){
      if(nodes[[index]]$'Sex'=="Indefinit"){
        for(index2 in 1:length(nodes)){
          nodes[[index2]]$'Sex' <- "Male"
        }
        same.sex.activ <- TRUE
        same.sex.sex <- 0
      }
    }

    splits <- NULL
    n_male <- NULL
    for(index in 1:length(nodes)){
      if(nodes[[index]]$'Sex'=="Both"){
        splits <- c(splits, nodes[[index]]$id)
        nodes[[length(nodes)+1]] <- nodes[[index]]
        nodes[[index]]$'Sex' <- "Male"
        nodes[[length(nodes)]]$'Sex' <- "Female"
        nodes[[index]]$id <- paste0(nodes[[index]]$id, "_M")
        nodes[[length(nodes)]]$id <- paste0(nodes[[length(nodes)]]$id, "_W")
        nodes[[index]]$label <- paste0(nodes[[index]]$label, "_M")
        nodes[[length(nodes)]]$label <- paste0(nodes[[length(nodes)]]$label, "_W")
        nodes[[index]]$'Number of Individuals' <- round(as.numeric(nodes[[index]]$'Number of Individuals') * as.numeric(nodes[[index]]$'Proportion of Male'))
        n_male <- c(n_male,nodes[[index]]$'Number of Individuals')
        nodes[[length(nodes)]]$'Number of Individuals' <- as.numeric(nodes[[length(nodes)]]$'Number of Individuals') - nodes[[index]]$'Number of Individuals'
        nodes[[index]]$'Proportion of Male' <- 1
        nodes[[length(nodes)]]$'Proportion of Male' <- 0
      }
    }

    for(index in 1:length(edges)){
      wfrom <- which(edges[[index]]$from==splits)
      wto <- which(edges[[index]]$to==splits)
      if(length(wfrom)>0 && length(wto)>0){
        edges[[length(edges)+1]] <- edges[[index]]
        edges[[index]]$to <- paste0(edges[[index]]$to, "_M")
        edges[[length(edges)]]$to <- paste0(edges[[length(edges)]]$to, "_W")
        edges[[index]]$from <- paste0(edges[[index]]$from, "_M")
        edges[[length(edges)]]$from <- paste0(edges[[length(edges)]]$from, "_W")
      } else if(length(wto)>0){
        edges[[length(edges)+1]] <- edges[[index]]
        edges[[index]]$to <- paste0(edges[[index]]$to, "_M")
        edges[[length(edges)]]$to <- paste0(edges[[length(edges)]]$to, "_W")
      } else if(length(wfrom)>0){
        edges[[length(edges)+1]] <- edges[[index]]
        edges[[index]]$from <- paste0(edges[[index]]$from, "_M")
        edges[[length(edges)]]$from <- paste0(edges[[length(edges)]]$from, "_W")
      }

    }



    ids <- earliest_time <- numeric(length(nodes))
    sex <- numeric(length(nodes))
    for(index in 1:length(nodes)){
      earliest_time[index] <- nodes[[index]]$earliest_time
      ids[index] <- nodes[[index]]$id
      sex[index] <- as.numeric(nodes[[index]]$'Sex'=="Female")
    }

    # Remove sex-switch
    for(index in length(edges):1){
      sex1 <- sex[which(edges[[index]]$from==ids)]
      sex2 <- sex[which(edges[[index]]$to==ids)]
      if(sex1!=sex2 && edges[[index]]$'Breeding Type'!="Reproduction"){
        edges[[index]] <- NULL
      }
    }

    # Identify founder cohorts
    # Add "Founder" as a breeding type - If selected allow for a dataset to be imported!
    founder <- NULL
    ids <- earliest_time <-  numeric(length(nodes))
    repeat_node <- numeric(length(nodes))
    for(index in 1:length(nodes)){
      if(nodes[[index]]$Founder=="Yes"){
        founder <- c(founder,index)
      }
      ids[index] <- nodes[[index]]$id
      earliest_time[index] <- nodes[[index]]$earliest_time
    }
    for(index in 1:length(edges)){
      if(edges[[index]]$'Breeding Type'=="Repeat"){
        repeat_node[which(edges[[index]]$from==ids)] <- 1
      }
    }

    ## Check for repeats
    link2 <- NULL

    for(index in 1:length(edges)){
      link <- NULL

      if(edges[[index]]$'Breeding Type'=="Repeat"){
        n_rep <- as.numeric(edges[[index]]$'Number of Repeat')
        nodes_to_repeat <- NULL
        edges_to_repeat <- NULL
        start <- which(ids==edges[[index]]$to)
        step <- start
        prev <- NULL
        while(length(step)!=length(prev)||length(prev)==0){
          prev <- step
          for(index2 in 1:length(edges)){
            desti <- which(edges[[index2]]$to==ids)
            ori <- which(edges[[index2]]$from==ids)
            if(repeat_node[ori]){
              #          if(index!=index2){
              # Ermittle weiter Knoten Quelle fuer neuen Repeat
              for(index3 in 1:length(edges)){
                if(edges[[index3]]$'Breeding Type'=="Repeat" && edges[[index3]]$from==edges[[index2]]$from){
                  start <- unique(c(start, which(edges[[index3]]$to==ids)))
                  step <- unique(c(step, which(edges[[index3]]$to==ids)))
                  link <- rbind(link, c(ori, which(edges[[index3]]$to==ids)))
                  link2 <- unique(c(link2, index3))
                  edges[[index3]]$'Breeding Type' <- "PerformedRepeat"
                }
                #           }
              }
            } else{
              if(sum(ori==prev)>0){

                step <- unique(c(step, desti))
                edges_to_repeat <- unique(c(edges_to_repeat, index2))
              }

            }
          }
        }

        nodes_to_repeat <- step[!duplicated(c(start, step))[-(1:length(start))]]
        nodes_to_repeat <- sort(nodes_to_repeat)
        edges_to_repeat <- sort(edges_to_repeat)
        link <- unique(link)
        #    for(index4 in start){
        #      edges[[index4]]$'Breeding Type' <- "PerformedRepeat"
        #    }
        for(index4 in 1:n_rep){
          for(nodrep in nodes_to_repeat){
            nodes[[length(nodes)+1]] <- nodes[[nodrep]]
            nodes[[length(nodes)]]$Founder <- "No"
            nodes[[length(nodes)]]$id <- paste0(nodes[[length(nodes)]]$id, "_",index4)
            nodes[[length(nodes)]]$label <- paste0(nodes[[length(nodes)]]$label, "_",index4)
          }
          for(edgesrep in edges_to_repeat){
            edges[[length(edges)+1]] <- edges[[edgesrep]]
            test <- ids[start]==edges[[length(edges)]]$from
            if(sum(test)){
              take <- link[which(link[,2]==start[which(test)]),1]
              if(index4==1){
                edges[[length(edges)]]$from <- paste0(ids[take])
              } else{
                edges[[length(edges)]]$from <- paste0(ids[take],"_", index4-1)
              }

            } else{
              edges[[length(edges)]]$from <- paste0(edges[[length(edges)]]$from,"_", index4)
            }

            edges[[length(edges)]]$to <- paste0(edges[[length(edges)]]$to,"_", index4)
            edges[[length(edges)]]$id <- paste0(edges[[length(edges)]]$id,"_", index4)
          }
        }

        for(sonstcheck in (1:length(ids))[-step]){
          for(edgeindex in 1:length(edges)){
            if(edges[[edgeindex]]$to==ids[sonstcheck] && sum(edges[[edgeindex]]$from==ids[nodes_to_repeat])>0){
              edges[[sonstcheck]]$from <- paste0(edges[[sonstcheck]]$from, "_", n_rep)
            }
          }
        }

        founder <- NULL
        ids <- earliest_time <- numeric(length(nodes))
        repeat_node <- numeric(length(nodes))
        for(index in 1:length(nodes)){
          if(nodes[[index]]$Founder=="Yes"){
            founder <- c(founder,index)
          }
          ids[index] <- nodes[[index]]$id
          earliest_time[index] <- nodes[[index]]$earliest_time
        }
        for(index in 1:length(edges)){
          if(edges[[index]]$'Breeding Type'=="Repeat"){
            repeat_node[which(edges[[index]]$from==ids)] <- 1
          }
        }
      }
    }

    for(changeto in sort(link2, decreasing = TRUE)){
      edges[[changeto]] <- NULL
    }

    ## Determine genetic architecture


    if(geninfo$'Use Ensembl Map'=="Yes"){
      map <- ensembl.map(dataset = geninfo$'Ensembl Dataset',
                         filter = geninfo$'Ensembl Filter',
                         filter.values = geninfo$'Ensembl Filter Values')
      nchromo <- max(as.numeric(map[,1]))
      nsnp <- chromo.length <- numeric(nchromo)
      for(index in 1:nchromo){
        nsnp[index] <- sum(map[,1]==index)
        chromo.length[index] <- max(as.numeric(map[map[,1]==index,3])) / 100000000

      }
      cat("Assume 100.000.000 bp/M in Ensembl Map \n")

    } else if(length(map)>0){
      nchromo <- max(as.numeric(map[,1]))
      nsnp <- chromo.length <- numeric(nchromo)
      for(index in 1:nchromo){
        nsnp[index] <- sum(map[,1]==index)
        chromo.length[index] <- max(as.numeric(map[map[,1]==index,3])) / 100000000

      }
      cat("Assume 100.000.000 bp/M in Imported Map \n")

    } else if(geninfo$'Chromosomes of Equal Length'=="Yes"){
      nchromo <- as.numeric(geninfo$'Number of Chromosomes')
      nsnp <- rep(as.numeric(geninfo$'Chromosomes Info'[[1]]$Length) * as.numeric(geninfo$'Chromosomes Info'[[1]]$MD), nchromo)
      chromo.length <- rep(as.numeric(geninfo$'Chromosomes Info'[[1]]$Length) * as.numeric(geninfo$'Chromosomes Info'[[1]]$Recombination, nchromo) /100, nchromo)
    } else{
      nchromo <- as.numeric(geninfo$'Number of Chromosomes')
      chromo.length <- nsnp <- numeric(nchromo)
      for(index in 1:nchromo){
        nsnp[index] <- rep(as.numeric(geninfo$'Chromosomes Info'[[index]]$Length) * as.numeric(geninfo$'Chromosomes Info'[[index]]$MD), nchromo)
        chromo.length[index] <- rep(as.numeric(geninfo$'Chromosomes Info'[[index]]$Length) * as.numeric(geninfo$'Chromosomes Info'[[index]]$Recombination, nchromo) /100, nchromo)

      }
    }
    if(length(map)==0){
      for(index in 1:nchromo){
        map <- rbind(map, cbind(index, paste0("SNP", 1:nsnp[index]), NA, NA, NA))
      }
    }

    if(n_traits>0){
      trait_matrix <- matrix(0, nrow=n_traits, ncol=8)
      for(index in 1:n_traits){
        trait_matrix[index,] <- unlist(traitinfo[[index]])[1:8]
      }


      #traitmean <- as.numeric(c(geninfo[[1]]$MilkYield_Mean, geninfo[[1]]$NonReturnRate_Mean, geninfo[[1]]$SomaticCellScore_Mean))
      traitmean <- as.numeric(trait_matrix[,3])
      trait_weigths <- as.numeric(trait_matrix[,8])

      #heritability <- as.numeric(c(geninfo[[1]]$MilkYield_Hertit, geninfo[[1]]$NonReturnRate_Hertit, geninfo[[1]]$SomaticCellScore_Hertit))
      heritability <- as.numeric(trait_matrix[,5])
      if(sum(is.na(heritability))>0){
        print("No heritability entered - set heritability to 0.5 for all those traits")
        heritability[is.na(heritability)]==0
      }

    } else{
      heritability <- NULL
    }
    groups <- length(nodes)


    # Species not needed, traitvariance not needed,
    position <- matrix(0, nrow=length(nodes), ncol=4)
    rownames(position) <- ids
    founding_a <- c(0,0)
    mig_m <- numeric(0)
    mig_f <- numeric(0)

    sex.s <- NULL
    # CHECK FOR ME THAN 2 FOUNDERS (MORE THAN 1 of a sex- Migration level...)
    new_mig <- c(0,0)


    founder_data <- FALSE
    for(index in 1:length(founder)){

      sex <- as.numeric(nodes[[founder[index]]]$'Sex'=="Female")+1
      size <- as.numeric(nodes[[founder[index]]]$'Number of Individuals')
      founding_a[sex] <- founding_a[sex] + size
      sex.s <- c(sex.s, rep(sex, size))
      if(sex==1){
        mig_m <- c(mig_m, rep(new_mig[1], size))
        mig <- new_mig[1]
        new_mig[1] <- new_mig[1] + 1
      }
      if(sex==2){
        mig_f <- c(mig_f, rep(new_mig[2], size))
        mig <- new_mig[2]
        new_mig[2] <- new_mig[2] + 1
      }
      position[founder[index],] <- c(1, sex, mig, size)
      if(nchar(nodes[[founder[index]]]$Path)>0){
        founder_data <- TRUE
      }

    }
  }


  ################### Import genetic data #############################
  {
    dataset <- "random"
    if(founder_data){
      dataset <- matrix(0L, nrow= sum(nsnp), ncol = sum(position[,4])*2)
      path_list <- NULL
      no_data <- numeric(length(founder))
      for(index in 1:length(founder)){
        path_list <- c(path_list, nodes[[founder[index]]]$Path )
      }
      starts <- cumsum(c(1, position[founder,4]))*2-1
      for(path in unique(c("",path_list))[-1]){
        load(path)
        takes <- which(path_list==path)
        no_data[takes] <- 1
        take <- NULL
        for(index in takes){
          take <- c(take, starts[index]:(starts[index+1]-1))
        }
        if(nrow(haplo)!=sum(nsnp)){
          nsnp <- floor(nsnp*nrow(haplo)/sum(nsnp))
          nsnp[1] <- nsnp[1] + nrow(haplo)-sum(nsnp)
          dataset <- matrix(0L, nrow= sum(nsnp), ncol = sum(position[,4])*2)
        }
        if(length(haplo) != length(dataset[,take])){
          cat("Size of Founder-dataset not in concorance with node size!\n")
          haplo <- rep(haplo, length.out=length(dataset[,take]))
        }
        dataset[,take] <- haplo
      }
      if(sum(no_data==0)>0){
        takes <- which(no_data==0)
        take <- NULL
        for(index in takes){
          take <- c(take, starts[index]:(starts[index+1]-1))
        }
        if(miraculix){
          p_i <- miraculix::allele_freq(miraculix::createSNPmatrix(dataset[,-takes]))*2
        } else{
          p_i <- rowMeans(dataset[,-takes])
        }
        if(sum(!is.na(map[,5]))){
          cat("Replace allele-freq in dataset generation with Map allele freqs \n")
          p_i[!is.na(map[,5])] <- map[!is.na(map[,5]),5]
        }

        dataset[,take] <- stats::rbinom(nrow(dataset)*length(take),1, prob=p_i)
      } else{
        if(miraculix){
          p_i <- miraculix::allele_freq(miraculix::createSNPmatrix(dataset))*2
        } else{
          p_i <- rowMeans(dataset[,-takes])
        }

      }
    }

  }

  ############### Generate Base-Population
  {
    population <- NULL

    population <- creating.diploid(dataset = dataset, nindi=length(sex.s),
                                   sex.s = sex.s, chromosome.length = chromo.length,
                                   snps.equidistant = if(is.na(map[1,4])) {TRUE} else {FALSE}, miraculix = miraculix,
                                   chr.nr = map[,1], bp=map[,3], snp.name = map[,2],
                                   freq = map[,5], snp.position = if(is.na(map[1,4])) {NULL} else {map[,4]}
    )
    # Cohort names
    gender_founder <- numeric(length(founder))
    nr <- 1
    for(index in 1:length(founder)){
      gender_founder[index] <- sex.s[nr]
      nr <- nr + position[founder[index],4]
    }
    founder_temp <- founder[sort(gender_founder,index.return=TRUE)$ix]
    cohort_info <- cbind(ids[founder_temp], 1, position[founder_temp,4], position[founder_temp,4], position[founder_temp,3], 1+cumsum(c(0,position[founder_temp,4]))[-(length(founder_temp)+1)], 1+cumsum(c(0,position[founder_temp,4]))[-(length(founder_temp)+1)] - sum(sex.s==1),
                         earliest_time[founder_temp], 0)


    cohort_info[(cohort_info[,7]>=1),c(3,6)] <- 0
    cohort_info[(cohort_info[,7]<1),c(4,7)] <- 0


    population$info$cohorts <- cohort_info

    colnames(population$info$cohorts) <- c("name","generation", "male individuals", "female individuals", "class", "position first male", "position first female",
                                           "time point", "creating.type")

    if(n_traits>0){
      population <- creating.trait(population, n.additive = as.numeric(trait_matrix[,6]),
                                   shuffle.cor = cor_gen, new.phenotype.correlation = cor_pheno,
                                   shuffle.traits=1:n_traits)
    }




    if(n_traits>0){
      if(length(dataset)==1){
        mgen <- rep(1,sum(population$info$size[1,]))
        msex <- c(rep(1,population$info$size[1,1]), rep(2, population$info$size[1,2]))
        mnr <- c(1:population$info$size[1,1], 1:population$info$size[1,2])
        if(population$info$size[1,1]==0){
          mnr <- 1:population$info$size[1,2]
        }
        if(population$info$size[1,2]==0){
          mnr <- 1:population$info$size[1,1]
        }
        if(miraculix){
          mgeno <- miraculix::computeSNPS(population, mgen, msex, mnr, what = "geno", output_compressed=TRUE)
          p_i <- miraculix::allele_freq(mgeno)
        } else{
          mgeno <- matrix(0, nrow=sum(population$info$snp), ncol=length(mgen))
          for(index in 1:length(mgen)){
            mgeno[,index] <- colSums(compute.snps(population, mgen[index], msex[index], mnr[index]))
          }
          p_i <- rowMeans(mgeno)/2
        }

      }
      # Correct Scaling


      snp.before <- cumsum(c(0,population$info$snp))

      for(index in 1:n_traits){
        effect_p <- population$info$real.bv.add[[index]][,1]+ snp.before[population$info$real.bv.add[[index]][,2]]
        mean <- population$info$real.bv.add[[index]][,3]*(1-p_i[effect_p])^2 + population$info$real.bv.add[[index]][,4]*(1-p_i[effect_p])*p_i[effect_p] +
          population$info$real.bv.add[[index]][,5]*(p_i[effect_p])^2
        new_var <- as.numeric(trait_matrix[index,4])
        old_var <- sum((population$info$real.bv.add[[index]][,3]-mean)^2*(1-p_i[effect_p])^2)+
          sum((population$info$real.bv.add[[index]][,4]-mean)^2*(1-p_i[effect_p])*p_i[effect_p]) +
          sum((population$info$real.bv.add[[index]][,5]-mean)^2*(p_i[effect_p])^2)
        population$info$real.bv.add[[index]][,3:5] <- population$info$real.bv.add[[index]][,3:5] * sqrt(new_var / old_var)

        mean <- population$info$real.bv.add[[index]][,3]*(1-p_i[effect_p])^2 + population$info$real.bv.add[[index]][,4]*(1-p_i[effect_p])*p_i[effect_p] +
          population$info$real.bv.add[[index]][,5]*(p_i[effect_p])^2

        mqtl <- to_enter <- NULL
        if(length(major[[index]])>0){
          mqtl <- matrix(unlist(major[[index]]), ncol=8, byrow=TRUE)
          to_enter <- mqtl[,c(1,4:7)]
          storage.mode(to_enter) <- "numeric"
        }


        mqtl <- mqtl[mqtl[,1]!=0,,drop=FALSE]
        population$info$real.bv.add[[index]] <- rbind(population$info$real.bv.add[[index]],
                                                      to_enter)
        population$info$base.bv[index] <- traitmean[index] - sum(to_enter[,3:5]*c(1,2,1)/4) - sum(mean)
      }

    }


    population$breeding[[1]][[5]] <- mig_m
    population$breeding[[1]][[6]] <- mig_f

  }


  ################## Last preps ########################
  {
    simulated <- founder
    left <- (1:groups)[-simulated]

    # Add edges info to nodes
    for(index in 1:length(edges)){
      to_node <- which(edges[[index]]$to==ids)
      nodes[[to_node]]$'Breeding Type' <- edges[[index]]$'Breeding Type'
      if(nodes[[to_node]]$'Breeding Type'=="Selection"){
        nodes[[to_node]]$'Selection Type' <- edges[[index]]$'Selection Type'
        #      nodes[[to_node]]$proportion <- edges[[index]]$proportion # not needed?
        nodes[[to_node]]$origin <- edges[[index]]$from
        nodes[[to_node]]$'Relationship Matrix' <- edges[[index]]$'Relationship Matrix'
        nodes[[to_node]]$'BVE Method' <- edges[[index]]$'BVE Method'
        nodes[[to_node]]$'Use Offspring for BVE' <- edges[[index]]$'Use Offspring for BVE'
        nodes[[to_node]]$edge.nr <- c(nodes[[to_node]]$edge.nr,index)
        nodes[[to_node]]$'Time Needed' <- c(nodes[[to_node]]$'Time Needed',edges[[index]]$'Time Needed')
        nodes[[to_node]]$'Selection Index' <- edges[[index]]$'Selection Index'
      }
      if(nodes[[to_node]]$'Breeding Type'=="Reproduction"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
        nodes[[to_node]]$edge.nr <- c(nodes[[to_node]]$edge.nr,index)
        nodes[[to_node]]$'Time Needed' <- c(nodes[[to_node]]$'Time Needed',edges[[index]]$'Time Needed')
      }
      if(nodes[[to_node]]$'Breeding Type'=="Recombination"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
        nodes[[to_node]]$mutation <- edges[[index]]$'New Mutation Rate'
        nodes[[to_node]]$remutation <- edges[[index]]$'New Remutation Rate'
        nodes[[to_node]]$recom <- edges[[index]]$'Number of Rec per M'
        nodes[[to_node]]$edge.nr <- c(nodes[[to_node]]$edge.nr,index)
        nodes[[to_node]]$'Time Needed' <- c(nodes[[to_node]]$'Time Needed',edges[[index]]$'Time Needed')
      }
      if(nodes[[to_node]]$'Breeding Type'=="Reproduction_Selfing"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
        nodes[[to_node]]$edge.nr <- c(nodes[[to_node]]$edge.nr,index)
        nodes[[to_node]]$'Time Needed' <- c(nodes[[to_node]]$'Time Needed',edges[[index]]$'Time Needed')
      }
      if(nodes[[to_node]]$'Breeding Type'=="DH_Gene"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
        nodes[[to_node]]$edge.nr <- c(nodes[[to_node]]$edge.nr,index)
        nodes[[to_node]]$'Time Needed' <- c(nodes[[to_node]]$'Time Needed',edges[[index]]$'Time Needed')
      }
      if(nodes[[to_node]]$'Breeding Type'=="Cloning"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
        nodes[[to_node]]$edge.nr <- c(nodes[[to_node]]$edge.nr,index)
        nodes[[to_node]]$'Time Needed' <- c(nodes[[to_node]]$'Time Needed',edges[[index]]$'Time Needed')
      }
      if(nodes[[to_node]]$'Breeding Type'=="Combine"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
        nodes[[to_node]]$edge.nr <- c(nodes[[to_node]]$edge.nr,index)
        nodes[[to_node]]$'Time Needed' <- c(nodes[[to_node]]$'Time Needed',edges[[index]]$'Time Needed')
      }
      if(nodes[[to_node]]$'Breeding Type'=="Aging"){
        nodes[[to_node]]$origin <- c(nodes[[to_node]]$origin,edges[[index]]$from)
        nodes[[to_node]]$edge.nr <- c(nodes[[to_node]]$edge.nr,index)
        nodes[[to_node]]$'Time Needed' <- c(nodes[[to_node]]$'Time Needed',edges[[index]]$'Time Needed')
      }

    }

    phenotype_groups <- numeric(length(nodes))
    for(index in 1:length(edges)){
      phenotype_groups[which(ids==edges[[index]]$from)] <- 1
    }

    priority_breeding <- ids[(1-phenotype_groups)*1:length(ids)]


    n_tester <- n_tester_generated <- numeric(length(nodes))
    for(index in 1:length(edges)){
      if(length(intersect(priority_breeding, edges[[index]]$to))){
        n_tester[which(ids==edges[[index]]$from)] <- n_tester[which(ids==edges[[index]]$from)] +1
      }
    }


  }


  ############## Actual simulations ########################
  {
    generation <- 1
    while(length(left)>0){
      generation <- generation + 1
      cat(paste0("Start simulation of generation:", generation,"\n"))
      possible <- ids[left]
      stock <- ids[-left]
      for(index in 1:length(edges)){
        there <- which(edges[[index]]$to==possible)
        if(length(there)>0){


          if(sum(edges[[index]]$from==stock)==0){
            if(possible[there]=="B_pre_sel") cat(index)
            possible <- possible[-there]

          }
        }
      }
      if(length(intersect(possible, priority_breeding))>0){
        possible <- intersect(possible, priority_breeding)
      } else{
        stock <- ids[-unique(c(left, (n_tester>n_tester_generated)*(1:length(n_tester))))]
        for(index in 1:length(edges)){
          there <- which(edges[[index]]$to==possible)
          if(length(there)>0){


            if(sum(edges[[index]]$from==stock)==0){
              possible <- possible[-there]
            }
          }
        }
      }
      # Remove group for which not all testers are generated

      if(length(possible)==0){
        stop("invalite breeding program")
      }
      for(group in possible){
        groupnr <- which(ids==group)
        simulated <- c(simulated, groupnr)
        sex <- as.numeric(nodes[[groupnr]]$'Sex'=="Female") + 1


        breeding.size <- as.numeric(nodes[[groupnr]]$individual) * c(sex==1, sex==2)
        involved_groups <- position[nodes[[groupnr]]$origin,,drop=FALSE]
        involved_groups <- unique(position[nodes[[groupnr]]$origin,,drop=FALSE])
        selection.size <- c(sum(involved_groups[,4]*(involved_groups[,2]==1)), sum(involved_groups[,4] * (involved_groups[,2]==2)))


        used.generations.m <- numeric(generation-1)
        for(index in 1:nrow(involved_groups)){
          if(involved_groups[index,2]==1){
            used.generations.m[involved_groups[index,1]] <- used.generations.m[involved_groups[index,1]] + involved_groups[index,4]
          }
        }
        used.generations.w <- numeric(generation-1)
        for(index in 1:nrow(involved_groups)){
          if(involved_groups[index,2]==2){
            used.generations.w[involved_groups[index,1]] <- used.generations.w[involved_groups[index,1]] + involved_groups[index,4]
          }
        }
        migration.level.m <- involved_groups[involved_groups[,2]==1,3]
        migration.level.w <- involved_groups[involved_groups[,2]==2,3]

        # Derive time.point
        time.point <- 0
        origins <- nodes[[which(ids==group)]]$origin
        time_needed <- as.numeric(nodes[[which(ids==group)]]$'Time Needed')
        for(temp1 in 1:length(origins)){
          time.point <- as.numeric(population$info$cohorts[population$info$cohorts[,1]==origins[temp1],8]) + time_needed[temp1]

        }
        time.point <- max(nodes[[which(ids==group)]]$earliest_time, time.point)


        if(nodes[[groupnr]]$'Breeding Type'=="Selection"){
          activemmreml <- FALSE
          activbglr <- FALSE
          if(nodes[[groupnr]]$'Selection Type'=="Phenotypic"){
            bve <- FALSE
            selection <- "function"
            phenotype.bv <- TRUE
            computeA <- "vanRaden"
          } else if(nodes[[groupnr]]$'Selection Type'=="Random"){
            bve <- FALSE
            selection <- "random"
            phenotype.bv <- FALSE
            computeA <- "vanRaden"
          } else if(nodes[[groupnr]]$'Selection Type'=="BVE"){
            bve <- TRUE
            selection <- "function"
            phenotype.bv <- FALSE
            if(nodes[[groupnr]]$'Relationship Matrix'=="Pedigree"){
              cat("Dont use Pedigree currently\n")
            } else{
              computeA <- "vanRaden"
            }
            if(nodes[[groupnr]]$'BVE Method'=="REML-GBLUP"){
              activemmreml <- TRUE
            } else if(nodes[[groupnr]]$'BVE Method'=="RKHS") {
              activbglr <- TRUE
            }
          }
          if(nodes[[groupnr]]$'Use Offspring for BVE'=="Yes"){
            bve.childbase.parents <- involved_groups[,1:2,drop=FALSE]
            if(length(pheno.sex)==1){
              bve.childbase.children <- cbind((min(bve.childbase.parents[,1])+1): nrow(population$info$size),pheno.sex)
            } else{
              bve.childbase.children <- rbind(cbind((min(bve.childbase.parents[,1])+1): nrow(population$info$size),1),
                                              cbind((min(bve.childbase.parents[,1])+1): nrow(population$info$size),2))
            }

            population <- breeding.diploid(population, breeding.size=breeding.size,
                                           bve=bve, computation.A = computeA,
                                           bve.childbase=TRUE,
                                           bve.childbase.parents=bve.childbase.parents,
                                           bve.childbase.children=bve.childbase.children,
                                           BGLR.bve = activbglr,
                                           emmreml.bve = activemmreml,
                                           selection.size= breeding.size,
                                           copy.individual = TRUE,
                                           max.offspring = c(1,1),
                                           heritability = heritability,
                                           sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                           new.bv.observation = "non_obs",
                                           selection.m = selection,
                                           phenotype.bv = phenotype.bv,
                                           add.gen = generation,
                                           bve.database = involved_groups[,1:2, drop=FALSE],
                                           selfing.mating=TRUE,
                                           selfing.sex=(sex-1),
                                           class.m = migration.level.m,
                                           class.f = migration.level.w,
                                           used.generations.m = used.generations.m,
                                           used.generations.f = used.generations.w,
                                           new.class = new_mig[sex],
                                           multiple.bve.scale=TRUE,
                                           multiple.bve.weights = selection_index[which(selection_index_name==nodes[[groupnr]]$'Selection Index')],
                                           remove.effect.position = remove.effect.position,
                                           name.cohort = nodes[[groupnr]]$label,
                                           bve.class=c(migration.level.m, migration.level.w),
                                           time.point = time.point,
                                           creating.type = 1)
          } else{
            population <- breeding.diploid(population, breeding.size=breeding.size,
                                           bve=bve, computation.A = computeA,
                                           BGLR.bve = activbglr,
                                           emmreml.bve = activemmreml,
                                           selection.size= breeding.size,
                                           copy.individual = TRUE,
                                           max.offspring = c(1,1),
                                           heritability = heritability,
                                           sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                           new.bv.observation = "non_obs",
                                           selection.m = selection,
                                           phenotype.bv = phenotype.bv,
                                           add.gen = generation,
                                           bve.database = involved_groups[,1:2, drop=FALSE],
                                           selfing.mating=TRUE,
                                           selfing.sex=(sex-1),
                                           class.m = migration.level.m,
                                           class.f = migration.level.w,
                                           used.generations.m = used.generations.m,
                                           used.generations.f = used.generations.w,
                                           new.class = new_mig[sex],
                                           multiple.bve.scale=TRUE,
                                           multiple.bve.weights = selection_index[which(selection_index_name==nodes[[groupnr]]$'Selection Index')],
                                           remove.effect.position = remove.effect.position,
                                           name.cohort = nodes[[groupnr]]$label,
                                           bve.class=c(migration.level.m, migration.level.w),
                                           time.point = time.point,
                                           creating.type = 1)
          }

        } else if(nodes[[groupnr]]$'Breeding Type'=="Reproduction"){

          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= selection.size,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         #                                     phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         same.sex.activ = same.sex.activ,
                                         same.sex.sex = same.sex.sex,
                                         name.cohort = nodes[[groupnr]]$label,
                                         time.point = time.point,
                                         creating.type = 2)
        } else if(nodes[[groupnr]]$'Breeding Type'=="Reproduction_Selfing"){

          selfing.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= selection.size,
                                         selfing.mating = TRUE,
                                         selfing.sex =  selfing.sex,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         name.cohort = nodes[[groupnr]]$label,
                                         time.point = time.point,
                                         creating.type = 4)
        } else if(nodes[[groupnr]]$'Breeding Type'=="DH_Gene"){

          dh.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= selection.size,
                                         dh.mating = TRUE,
                                         dh.sex =  dh.sex,
                                         selfing.mating = TRUE,
                                         selfing.sex = dh.sex,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         name.cohort = nodes[[groupnr]]$label,
                                         time.point = time.point,
                                         creating.type = 5)
        } else if(nodes[[groupnr]]$'Breeding Type'=="Recombination"){

          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         mutation.rate = nodes[[groupnr]]$mutation,
                                         remutation.rate = nodes[[groupnr]]$remutation,
                                         recombination.rate = nodes[[groupnr]]$recom,
                                         selection.size= selection.size,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         name.cohort = nodes[[groupnr]]$label,
                                         time.point = time.point,
                                         creating.type = 3)
        } else if(nodes[[groupnr]]$'Breeding Type'=="Cloning"){

          selfing.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= selection.size,
                                         copy.individual = TRUE,
                                         selfing.mating = TRUE,
                                         selfing.sex =  selfing.sex,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         name.cohort = nodes[[groupnr]]$label,
                                         time.point = time.point,
                                         creating.type = 6)

        } else if(nodes[[groupnr]]$'Breeding Type'=="Aging"){

          selfing.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))
          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= selection.size,
                                         copy.individual = TRUE,
                                         selfing.mating = TRUE,
                                         selfing.sex =  selfing.sex,
                                         heritability = heritability,
                                         sigma.e.database = cbind(1,(1:2)[population$info$size[1,]>0]),
                                         new.bv.observation = "non_obs",
                                         selection.m = "random",
                                         phenotype.bv = phenotype.bv,
                                         add.gen = generation,
                                         bve.database = involved_groups[,1:2, drop=FALSE],
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         name.cohort = nodes[[groupnr]]$label,
                                         max.offspring = 1,
                                         time.point = time.point,
                                         creating.type = 8)

        } else if(nodes[[groupnr]]$'Breeding Type'=="Combine"){
          selfing.sex <- as.numeric(selection.size[2]>0)- 0.5 * as.numeric((selection.size[1]>0)*(selection.size[2]>0))

          if(sum(breeding.size)!=sum(c(used.generations.m,used.generations.w))){
            cat("Number of individuals in combined note doesnt fit - automatically changed!\n")
            breeding.size <- breeding.size * sum(c(used.generations.m,used.generations.w)) / sum(breeding.size)
          }
          population <- breeding.diploid(population, breeding.size=breeding.size,
                                         selection.size= breeding.size,
                                         copy.individual = TRUE,
                                         max.offspring = c(1,1),
                                         selfing.mating=TRUE,
                                         selfing.sex=selfing.sex,
                                         class.m = migration.level.m,
                                         class.f = migration.level.w,
                                         add.gen = generation,
                                         used.generations.m = used.generations.m,
                                         used.generations.f = used.generations.w,
                                         new.class = new_mig[sex],
                                         name.cohort = nodes[[groupnr]]$label,
                                         time.point = time.point,
                                         creating.type = 7)
        }

        position[groupnr,] <- c(generation, sex, new_mig[sex], sum(breeding.size))
        new_mig[sex] <- new_mig[sex] + 1


        if(phenotype_groups[groupnr]==0){
          tested <- which(duplicated(c(nodes[[groupnr]]$origin, ids))[-(1:length(nodes[[groupnr]]$origin))])
          n_tester_generated[tested] <- n_tester_generated[tested] + 1
        }

      }
      cat("Generated groups:")
      cat(possible)
      left <- (1:groups)[-simulated]

    }

  }

  ############## Attach json-infos ########################

  population$info$json <- list(nodes, edges, geninfo, traitinfo, major)

  return(population)

}
