if(subpop==1){
change <- target_diff
} else{
change <- target_diff - current_diff
}
diff_freq <- c(p_i[[subpop]][valid_markers0], - p_i[[subpop]][valid_markers1])
effect_size <- change / sum(abs(diff_freq)) / 2
direction <- diff_freq > 0
snp_index <- chromo_index <- numeric(length(valid_markers))
for(index2 in 1:length(valid_markers)){
chromo_index[index2] <- max(which(c(0,population$info$cumsnp)<=valid_markers[index2]))
snp_index[index2] <- valid_markers[index2] - c(0,population$info$cumsnp)[chromo_index[index2]]
}
add.effects <- cbind(snp_index, chromo_index, 2* effect_size, effect_size,   0)
add.effects[direction==TRUE,3:5] <- cbind(rep(0, sum(direction)), rep(effect_size, sum(direction)), rep(2*effect_size, sum(direction)))
population$info$real.bv.add[[active_trait]] <- rbind(population$info$real.bv.add[[active_trait]], add.effects)
population$info$bv.calculated <- FALSE
if(subpop==1){
population <- breeding.diploid(population, verbose=verbose)
population$info$bv.calculated <- FALSE
}
}
}
}
}
}
}
if(length(trafos)>0){
for(index in 1:length(trafos)){
if(length(trafos[[index]])>0){
population <- creating.phenotypic.transform(population, phenotypic.transform.function = trafos[[index]], trait = index)
}
}
}
setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/development/MoBPS/")
devtools::load_all()
devtools::check()
set.seed(42)
library(MoBPS)
population <- creating.diploid(nsnp = 5000, nindi = 50, sex.quota=0,
chr.nr = 5, chromosome.length = 1, name.cohort = "1yearRams")
population <- creating.diploid(population = population, freq = "same", nindi = 10,
sex.quota=0, name.cohort = "2yearRams")
population <- creating.diploid(population = population, freq = "same", nindi = 50,
sex.quota=1, name.cohort = "1yearEwes")
population <- creating.diploid(population = population, freq = "same", nindi = 40,
sex.quota=1, name.cohort = "2yearEwes")
population <- creating.diploid(population = population, freq = "same", nindi = 30,
sex.quota=1, name.cohort = "3yearEwes")
summary(population)
get.cohorts(population, extended = TRUE)
population <- creating.trait(population, n.additive = 1000, mean.target = 100, var.target = 30, trait.name = "Meat")
get.qtl(population)
get.qtl.effects(population)
population <- breeding.diploid(population, phenotyping = "all", heritability = 0.3)
get.pheno(population, cohorts="1yearRams")
population <- breeding.diploid(population, breeding.size = c(50,0),
selection.m.cohorts = "2yearRams",
selection.f.cohorts = c("2yearEwes", "3yearEwes"),
name.cohort = "1yearRamsNext"
)
population <- breeding.diploid(population, breeding.size = c(0,50),
selection.m.cohorts = "2yearRams",
selection.f.cohorts = c("2yearEwes", "3yearEwes"),
name.cohort = "1yearEwesNext",
add.gen=2
)
population <- breeding.diploid(population, breeding.size = c(10,0), selection.size = c(10,0),
selection.m.cohorts = "1yearRams",
copy.individual.m = TRUE,
selection.criteria = "pheno",
add.gen=2,
name.cohort = "2yearRamsNext")
population <- breeding.diploid(population, breeding.size = c(0,40),
selection.size = c(0,40),
selection.f.cohorts = "1yearEwes",
copy.individual.f = TRUE,
selection.criteria = "random",
add.gen=2,
name.cohort = "2yearEwesNext")
population <- breeding.diploid(population, breeding.size = c(0,30),
selection.size = c(0,30),
selection.f.cohorts = "2yearEwes",
copy.individual.f = TRUE,
selection.criteria = "random",
add.gen=2,
name.cohort = "3yearEwesNext")
get.cohorts(population, extended = TRUE)
summary(population)
# The tools sees that 360 individuals were generated
# This counts copies of individuals multiple times!
# However, each individual is also assigned with a unique id
# e.g. As 2yearRamsNext are just a copy of 10 individuals from 1yearRams the ids are matching
# In a breeding value estimation, only one copy of an individual is used
get.id(population, cohorts = "1yearRams")
get.id(population, cohorts="2yearRamsNext")
# Examplary breeding value estimation
population <- breeding.diploid(population, bve = TRUE, bve.gen=1)
# Set remove.effect.position to remove real QTLs from the breeding value estimation
population <- breeding.diploid(population, bve = TRUE, bve.gen=1, remove.effect.position = TRUE)
# Add a genotyping array with only 2500 Markers
population <- add.array(population, marker.included = rep(c(0,1),2500), array.name = "Small_Array")
population <- breeding.diploid(population, breeding.size = c(50,0),
selection.m.cohorts = "2yearRamsNext",
selection.f.cohorts = "2yearEwesNext",
share.genotyped = 0.5,
genotyped.array = "Small_Array")
# Extract genotypes for the new generation:
get.geno(population, gen=3)
get.geno(population, gen=3, non.genotyped.as.missing = TRUE)
set.seed(42)
library(MoBPS)
# Simulation of the Breeding scheme entered in the Web-interface
population <- json.simulation(file="C:/Users/pook/Desktop/MoBPS_workshop_gft/Task2/Simple Sheep Advanced_baseline.json")
# Simulation of the Breeding scheme entered in the Web-interface
population <- json.simulation(file="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS_workshop_gft/Task2/Simple Sheep Advanced_baseline.json")
# Simulation of the Breeding scheme entered in the Web-interface
population <- json.simulation(file="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_workshop_gft/Task2/Simple Sheep Advanced_baseline.json")
# Simulation of the Breeding scheme entered in the Web-interface
population <- json.simulation(file="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_GFT&KWS/Task2/Simple Sheep Advanced_baseline.json")
warnings(0)
warnings()
# Better use:
# - summary() for a brief overview
# - get.XXX with XXX being whatever you are interested in (get.geno, get.recombi, get.pedigree)
summary(population)
get.cohorts(population)
cohorts_to_analyze <- paste0("1yearEwesNext_", 1:20)
BVS <- numeric(20)
for(index in 1:20){
BVS[index] <- mean(get.bv(population, cohorts = cohorts_to_analyze[index])[1,])
}
plot(BVS, ylab="genomic value", xlab = "generation", type="l", lwd=2,
main="Genomic value for 1yearEwes")
library(MoBPS)
set.seed(42)
# Import genomic data from the first pool
population <- creating.diploid(vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_GFT&KWS/Task6/Pool1.vcf",
name.cohort = "Pool1", sex.quota = 0)
# Import genomic data from the second pool
population <- creating.diploid(population = population, vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_GFT&KWS/Task6/Pool2.vcf",
name.cohort = "Pool2", sex.quota = 1)
population <- creating.trait(population, n.additive = c(10,1000,500), n.equal.dominant = c(0,0,500))
population <- bv.standardization(population, mean.target = c(100,100,100), var.target = c(5,5,5))
population <- breeding.diploid(population, breeding.size = c(100,0),
selection.m.cohorts = "Pool1", selection.f.cohorts = "Pool2",
name.cohort = "Hybrid")
# Principle components analysis
get.pca(population, gen=1:2, coloring=c(rep(1,10), rep(2,10), rep(3,100)))
# Extraction of the genomic values of all included lines
bv_pool1 <- get.bv(population, cohorts="Pool1")
bv_pool2 <- get.bv(population, cohorts="Pool2")
bv_hybrid <- get.bv(population, cohorts="Hybrid")
# For trait 3 we can we much higher genomic values of the hybrid lines
# Trait architecture with dominant effects
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
hist(bv_pool1[2,], xlim=c(94,115), main="Trait 2", xlab="genomic value")
hist(bv_pool1[3,], xlim=c(94,115), main="Trait 3", xlab="genomic value")
hist(bv_pool2[1,], xlim=c(94,115), main="", ylab="Pool 2", xlab="genomic value")
hist(bv_pool2[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_pool2[3,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[1,], xlim=c(94,115), main="", ylab="Hybrids", xlab="genomic value")
hist(bv_hybrid[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[3,], xlim=c(94,115), main="", xlab="genomic value")
rowMeans(bv_pool1)
rowMeans(bv_pool2)
rowMeans(bv_hybrid)
# On average each line is used 10 times for reproduction
# There is however sampling effects
ped <- get.pedigree(population, gen=2)
table(ped[,2])
table(ped[,3])
set.seed(42)
library(MoBPS)
# Generation of the founder population
population <- creating.diploid(nindi=100, nsnp=25000, chr.nr=5, n.additive = 1000, chromosome.length = 3)
summary(population)
array2 <- array3 <- array4 <- rep(FALSE, 25000)
array2[sample(1:25000, 10000)] <- TRUE
# This array was actually not put in the task - more to get a better feeling on when predictions
# are actually breaking down.
array3[sample(1:25000, 2000)] <- TRUE
array4[sample(1:25000, 100)] <- TRUE
population <- add.array(population, marker.included = array2)
population <- add.array(population, marker.included = array3)
population <- add.array(population, marker.included = array4)
for(index in 1:10){
population <- breeding.diploid(population, breeding.size = 100)
}
# On default all individuals are assumed to be genotyped
# use share.genotyped to generate some non-genotyped individuals
population <- breeding.diploid(population, breeding.size = 100, share.genotyped = 0.2)
# Generation of phenotypic data
# In generation 11 & 12 all individuals are phenotyped
population <- breeding.diploid(population, phenotyping.gen = 11:12, heritability = 0.3)
# In generation 10 only males are phenotyped
population <- breeding.diploid(population, phenotyping.database = cbind(10,1), heritability = 0.3)
# Looking at the prints provides helpful information to validate that the tool is doing what you want it do be doing!
population <- breeding.diploid(population, bve=TRUE, bve.gen=11)
population <- breeding.diploid(population, bve=TRUE, bve.gen=11, relationship.matrix = "pedigree")
# BVE with various different arrays
population <- breeding.diploid(population, bve=TRUE, bve.gen=11, bve.array = 2)
# Generation of the founder population
population <- creating.diploid(nindi=100, nsnp=25000, chr.nr=5, n.additive = 1000, chromosome.length = 3)
summary(population)
array2 <- array3 <- array4 <- rep(FALSE, 25000)
array2[sample(1:25000, 10000)] <- TRUE
# This array was actually not put in the task - more to get a better feeling on when predictions
# are actually breaking down.
array3[sample(1:25000, 2000)] <- TRUE
array4[sample(1:25000, 100)] <- TRUE
population <- add.array(population, marker.included = array2)
population <- add.array(population, marker.included = array3)
population <- add.array(population, marker.included = array4)
for(index in 1:10){
population <- breeding.diploid(population, breeding.size = 100, share.genotyped = 1)
}
# On default all individuals are assumed to be genotyped
# use share.genotyped to generate some non-genotyped individuals
population <- breeding.diploid(population, breeding.size = 100, share.genotyped = 0.2)
# Generation of phenotypic data
# In generation 11 & 12 all individuals are phenotyped
population <- breeding.diploid(population, phenotyping.gen = 11:12, heritability = 0.3)
# In generation 10 only males are phenotyped
population <- breeding.diploid(population, phenotyping.database = cbind(10,1), heritability = 0.3)
# Looking at the prints provides helpful information to validate that the tool is doing what you want it do be doing!
population <- breeding.diploid(population, bve=TRUE, bve.gen=11)
population <- breeding.diploid(population, bve=TRUE, bve.gen=11, relationship.matrix = "pedigree")
# BVE with various different arrays
population <- breeding.diploid(population, bve=TRUE, bve.gen=11, bve.array = 2)
population <- breeding.diploid(population, bve=TRUE, bve.gen=11, bve.array = 3)
population <- breeding.diploid(population, bve=TRUE, bve.gen=11, bve.array = 4)
population <- breeding.diploid(population, bve=TRUE, bve.gen=11, remove.effect.position=TRUE)
population <- breeding.diploid(population, bve=TRUE, bve.gen=11, remove.effect.position=TRUE, bve.array = 4)
# default BVE method is GBLUP -> all non-genotyped individuals are excluded from the BVE
population <- breeding.diploid(population, bve=TRUE, bve.gen=12)
population <- breeding.diploid(population, bve=TRUE, bve.gen=12, singlestep.active = TRUE)
population <- breeding.diploid(population, bve=TRUE, bve.gen=12, relationship.matrix = "pedigree")
# Prediction accuracy for phenotypes lines is much better than for remaining lines
population <- breeding.diploid(population, bve=TRUE, bve.gen=10)
analyze.bv(population, database = cbind(10,1))
analyze.bv(population, database = cbind(10,2))
# Visualization of estimated breeding values and real breeding values
# Estimated breeding values for females show much less variation (as they were not phenotyped)
bvs <- get.bv(population, gen=10)
bves <- get.bve(population, gen=10)
plot(bvs[1,], bves[1,], col=c(rep("blue",50), rep("red",50)))
set.seed(42)
library(MoBPS)
population <- creating.diploid(nsnp=5000, nindi = 100, sex.quota = 0.9,
name.cohort = "Founders")
population <- creating.trait(population, n.additive = 1000, mean.target = 100, var.target = 10)
# Generation of offspring
population <- breeding.diploid(population, breeding.size = c(45,45), name.cohort = "Offspring" )
# Generation of phenotypes for female offspring
population <- breeding.diploid(population, phenotyping.cohorts = "Offspring_F", heritability = 0.3)
# Calculate average offspring performance for our sires/dams
# As the two cohorts are both part of generation 1 we can also just use gen instead of cohorts
population <- breeding.diploid(population, offpheno.parents.gen = 1, offpheno.offspring.gen = 2)
# As female only have limited number of sires those average should be taken with more caution
get.pheno.off(population, gen=1)
get.pheno.off.count(population, gen=1)
ped <- get.pedigree(population, gen=2)
pheno <- get.pheno(population, gen=2)
parents_name <- get.pedigree(population, database = cbind(1,1))[,1]
off_pheno <- numeric(length(parents_name))
for(index in 1:10){
off_pheno[index] <- mean( pheno[which(ped[,2]== parents_name[index])], na.rm=TRUE)
}
# Perform a breeding value estimation
# Make sure that only 45 individuals in your simulation were phenotyped!
population <- breeding.diploid(population, bve=TRUE, bve.gen = c(1,2))
## Either use just the males:
pheno_off <- get.pheno.off(population, cohorts="Founders_M")
bvs <- get.bv(population, cohorts="Founders_M")
bves <- get.bve(population, cohorts="Founders_M")
# The prediction accuracy is the correlation between
# estimated and real breeding values
cor(bvs[1,], bves[1,])
cor(bvs[1,], pheno_off[1,])
bv <- get.bv(population, gen=1)
bve <- get.bve(population, gen=1)
off <- get.pheno.off(population, gen=1)
cor(bv[1,], off[1,], use = "complete.obs")
cor(bv[1,!is.na(off)], bve[1,!is.na(off)], use = "complete.obs")
# A single simulation is not sufficient to judge which of the two estimation techniques is better
# A single simulation is not sufficient to judge which of the two estimation techniques is better
# Average offspring phenotypes should be very similar to a pedigree-based breeding value estimation
# A single simulation is not sufficient to judge which of the two estimation techniques is better
# Average offspring phenotypes should be very similar to a pedigree-based breeding value estimation
# Which typically should be inferior to the prediction of genomic values of the parents
# A single simulation is not sufficient to judge which of the two estimation techniques is better
# Average offspring phenotypes should be very similar to a pedigree-based breeding value estimation
# Which typically should be inferior to the prediction of genomic values of the parents
# However if the main objective is maximizing offspring performance and traits
# A single simulation is not sufficient to judge which of the two estimation techniques is better
# Average offspring phenotypes should be very similar to a pedigree-based breeding value estimation
# Which typically should be inferior to the prediction of genomic values of the parents
# However if the main objective is maximizing offspring performance and traits
# are non-additive this might be a good alternative!
# A single simulation is not sufficient to judge which of the two estimation techniques is better
# Average offspring phenotypes should be very similar to a pedigree-based breeding value estimation
# Which typically should be inferior to the prediction of genomic values of the parents
# However if the main objective is maximizing offspring performance and traits
# are non-additive this might be a good alternative!
set.seed(42)
library(MoBPS)
library(MoBPSmaps)
# Down-sample maize array to 10k SNPs
map <- MoBPSmaps::map_maize1[sort(sample(1:nrow(MoBPSmaps::map_maize1), 10000)),]
# Sample target allele frequencies for the flint and dent pool
allele_freq_flint <- runif(10000,0,1)
allele_freq_dent <- runif(10000,0,1)
# Looking at the allele frequency spectrum
hist(allele_freq_dent)
# Sex can usually be neglected in plant breeding simulations
# Still, each individual / animal / line is assigned with a sex
# We would highly encourage simulate all lines with the same sex OR use the sex to differantiate between gene pools etc
# to give the simulation more structure
population <- creating.diploid(nindi=100, map = map, sex.quota=0,
freq = allele_freq_flint, name = "Flint_material",
n.additive = 500, n.equal.dominant = 500)
# Make sure Dent tester plants are fully inbred
population <- creating.diploid(population = population, dataset="homorandom", nindi=1,
sex.quota=1, freq = allele_freq_dent, name="Dent_tester_1")
population <- creating.diploid(population = population, dataset="homorandom", nindi=1,
sex.quota=1, freq = allele_freq_dent, name="Dent_tester_2")
population <- creating.diploid(population = population, dataset="homorandom", nindi=1,
sex.quota=1, freq = allele_freq_dent, name="Dent_tester_3")
# Having a look at the population structure
get.pca(population, cohorts="Flint_material")
get.pca(population, gen=1)
get.pca(population, gen=1, components = c(3,4))
# Generate crosses from the founding material
population <- breeding.diploid(population, selection.m.cohorts = "Flint_material",
selection.size = c(100,0),
breeding.size = c(1000,0),
name.cohort = "Flint_cross")
# Generate DH lines from the crosses - this includes the entire DH generation process including meiosis
# and doubling of one of the haplotpes
population <- breeding.diploid(population, selection.m.cohorts = "Flint_cross",
selection.size = c(1000,0),
breeding.size = c(1000,0), dh.mating = TRUE,
max.offspring = 1,
name.cohort = "Cross_DHs")
# Generate lines in a yield trial
population <- breeding.diploid(population, selection.m.cohorts = "Cross_DHs",
selection.f.cohorts = "Dent_tester_1",
breeding.size = c(1000,0), name.cohort = "Yield_trial_1",
max.offspring = c(1,1000))
# Generate phenotypes within the yield trial
population <- breeding.diploid(population, heritability = 0.3,
phenotyping.cohorts = "Yield_trial_1")
# Extract the average phenotypes of the offspring for each cross
population <- breeding.diploid(population, offpheno.parents.cohorts = "Cross_DHs",
offpheno.offspring.cohorts = "Yield_trial_1")
# Perform a breeding value estimation for DHs
population <- breeding.diploid(population, bve=TRUE, bve.cohorts = "Cross_DHs",
rrblup.bve = TRUE, input.phenotype = "off")
# Select the top 250 DHs for the second yield trial - these are the same lines as before!
# BTW: it is not necessary to generate this cohorts. It just can make it easier for downstream analysis
population <- breeding.diploid(population, selection.m.cohorts = "Cross_DHs",
copy.individual.m = TRUE,
selection.size=c(250,0), name.cohort = "Cross_DHs_sel")
# Yield Trial 2
population <- breeding.diploid(population, breeding.size = c(750,0),
selection.f.cohorts = c("Dent_tester_1", "Dent_tester_2", "Dent_tester_3"),
selection.m.cohorts =  "Cross_DHs_sel",
breeding.all.combination = TRUE,
name.cohort = "Yield_trial_2")
population <- breeding.diploid(population, heritability = 0.3,
phenotyping.cohorts = "Yield_trial_2")
population <- breeding.diploid(population, offpheno.parents.cohorts = "Cross_DHs_sel",
offpheno.offspring.cohorts = "Yield_trial_2")
population <- breeding.diploid(population, bve=TRUE, bve.cohorts = "Cross_DHs_sel",
rrblup.bve = TRUE, input.phenotype = "off")
# Select the top 5 DHs based on the second yield trial
population <- breeding.diploid(population, selection.m.cohorts = "Cross_DHs_sel",
copy.individual.m = TRUE,
selection.size=c(5,0), name.cohort = "Cross_DHs_final")
# This is the genomic value of the DHs itself - not for a cross to a dent line
par(mfrow=c(3,1))
hist(get.bv(population, cohorts="Cross_DHs")[1,], xlim=c(250,400), xlab="genomic value", main ="Genomic value in initial DHs")
hist(get.bv(population, cohorts="Cross_DHs_sel")[1,], xlim=c(250,400), xlab="genomic value", main ="Genomic value in selected DHs")
hist(get.bv(population, cohorts="Cross_DHs_final")[1,], xlim=c(250,400), xlab="genomic value", main ="Genomic value in final DHs")
# figure out position of the first parent
get.database(population, cohorts="Cross_DHs_sel")
# figure out position of the first parent
get.database(population, cohorts=c("Dent_tester_1", "Dent_tester_2", "Dent_tester_3"))
# Each row codes the mating between two individuals (column 1-3; column 4-6)
# This will mate the individual stored in generation 5, sex 1, nr 1 with individual generation 1, sex 2, nr 1
fixed.breeding <- cbind(5,1,1, 1,2,1)
population <- breeding.diploid(population, fixed.breeding = fixed.breeding, name.cohort = "Fixed_example")
fixed.breeding <- matrix(0, nrow=750, ncol=6)
# Dent tester 1
fixed.breeding[1:250,] <- cbind(5,1,1:250,1,2,1)
# Dent tester 2
fixed.breeding[251:500,] <- cbind(5,1,1:250,1,2,2)
# Dent tester 3
fixed.breeding[501:750,] <- cbind(5,1,1:250,1,2,3)
population <- breeding.diploid(population, breeding.size = c(750,0),
fixed.breeding = fixed.breeding, name.cohort = "Yield_trial_2_alt")
set.seed(42)
library(MoBPS)
library(MoBPSmaps)
# Simulation of the LD build up
dataset <- founder.simulation(nindi=100, map = MoBPSmaps::map_sheep2,
nfinal = 60+120, n.gen = 50)
# Use a genomic map from the MoBPSmap R-package
# Import genomic data from the dataset-matrix ((each individual has 2 haplotypes))
population <- creating.diploid(dataset = dataset[,1:100], nindi = 50, sex.quota=0, map=MoBPSmaps::map_sheep2,
name.cohort = "1yearRams_0")
population <- creating.diploid(dataset = dataset[,101:120], population = population, nindi = 10,
sex.quota=0, name.cohort = "2yearRams_0")
population <- creating.diploid(dataset = dataset[,121:220], population = population, nindi = 50,
share.genotyped = 1, sex.quota=1, name.cohort = "1yearEwes_0")
population <- creating.diploid(dataset = dataset[,221:300], population = population, nindi = 40,
share.genotyped = 1, sex.quota=1, name.cohort = "2yearEwes_0")
population <- creating.diploid(dataset = dataset[,301:360], population = population, nindi = 30,
share.genotyped = 1, sex.quota=1, name.cohort = "3yearEwes_0")
summary(population)
population <- creating.trait(population, n.additive = c(1000,1000), mean.target = 100, var.target = c(30,20),
shuffle.traits = 1:2, shuffle.cor = matrix(c(1, 0.2,
0.2,1), nrow=2))
litter_size <- matrix(c(2, 0.5,
3, 0.3,
4, 0.2), ncol=2, byrow=TRUE)
for(index in 1:20){
# phenotypes for the second trait are only generated for selected cohorts
population <- breeding.diploid(population, phenotyping.gen = index,
heritability = c(0.3,0.2), n.observation = c(1,0))
population <- breeding.diploid(population,
phenotyping.cohorts = paste0(c("2yearRams_", "2yearEwes_", "3yearEwes_"), index-1),
heritability = c(0.3,0.2), n.observation = c(0,1))
# As some individuals are non genotyped a genomic breeding value estimation does not work
# Either use a pedigree-based evaluation or single-step
# Otherwise non-genotyped individuals will automatically be removed for the estimation
population <- breeding.diploid(population, bve = TRUE, bve.gen = index, singlestep.active = TRUE,
bve.cohorts = paste0(c("1yearRams_", "2yearRams_", "1yearEwes_", "2yearEwes_", "3yearEwes_"), index-1))
# Generation of new individuals via reproduction
population <- breeding.diploid(population, breeding.size = c(50,50),
selection.m.cohorts = paste0("2yearRams_", index-1),
selection.f.cohorts = c(paste0("2yearEwes_",index-1), paste0("3yearEwes_",index-1)),
name.cohort = paste0("NewOffspring_",index),
repeat.mating = litter_size,
share.genotyped = 0
)
population <- breeding.diploid(population, breeding.size = c(50,0),
selection.size = c(50,0),
copy.individual.m = TRUE,
selection.m.cohorts = paste0("NewOffspring_",index, "_M"),
name.cohort = paste0("1yearRams_", index),
add.gen=index+1,
added.genotyped = 1
)
population <- breeding.diploid(population, breeding.size = c(0,50),
selection.size = c(0,50),
copy.individual.f = TRUE,
selection.f.cohorts = paste0("NewOffspring_",index, "_F"),
name.cohort = paste0("1yearEwes_", index),
add.gen=index+1,
added.genotyped = 0.5
)
# Generation of new individuals via selection
population <- breeding.diploid(population, breeding.size = c(10,0), selection.size = c(10,0),
selection.m.cohorts = paste0("1yearRams_", index-1),
copy.individual.m = TRUE,
selection.criteria = "bve",
add.gen=index+1,
name.cohort = paste0("2yearRams_", index))
population <- breeding.diploid(population, breeding.size = c(0,40),
selection.size = c(0,40),
selection.f.cohorts = paste0("1yearEwes_", index-1),
copy.individual.f = TRUE,
selection.criteria = "random",
add.gen=index+1,
name.cohort = paste0("2yearEwes_", index)
)
population <- breeding.diploid(population, breeding.size = c(0,30),
selection.size = c(0,30),
selection.f.cohorts = paste0("2yearEwes_", index-1),
copy.individual.f = TRUE,
selection.criteria = "random",
add.gen=index+1,
name.cohort = paste0("3yearEwes_", index)
)
}
summary(population)
rowMeans(get.bv(population, gen=21))
cor(t(get.bv(population, gen=21)))
rowMeans(get.bv(population, cohorts="1yearRams_0"))
rowMeans(get.bv(population, cohorts="1yearRams_20"))
rowMeans(get.bv(population, cohorts="2yearRams_20"))
cohorts_to_analyze <- paste0("1yearRams_", 1:20)
# By increasing ibd.obs and hbd.obs you can increase the accuracy of the calculation of kinship between individuals and within//inbreeding
inbreeding <- numeric(20)
for(index in 1:20){
inbreeding[index] <- 2* (kinship.emp.fast(population, cohorts = cohorts_to_analyze[index])[2] -0.5)
}
setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/development/MoBPS/")
devtools::load_all()
devtools::build()
devtools::install_local()
detach(MoBPS)
detach("package:MoBPSmaps", unload = TRUE)
library(MoBPS)
detach("package:MoBPS", unload = TRUE)
sessionInfo()
devtools::install_local()
setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/development/MoBPS/")
devtools::install_local()
