position[groupnr,] <- c(generation, sex, new_mig[sex], sum(breeding.size))
new_mig[sex] <- new_mig[sex] + 1
if(phenotype_groups[groupnr]==0){
tested <- which(duplicated(c(nodes[[groupnr]]$origin, ids))[-(1:length(nodes[[groupnr]]$origin))])
n_tester_generated[tested] <- n_tester_generated[tested] + 1
}
}
}
}
if(length(geninfo$advanced_history)>0 && geninfo$advanced_history && base.cycle < Inf && generation%%base.cycle == 0){
population <- new.base.generation(population, base.gen = generation,
delete.previous.gen = delete.previous.gen)
}
if(generation != (length(generation_group)+2)){
alive_cohorts <- c(alive_cohorts, generation_group[[generation-1]])
new_cohorts <- population$info$cohorts[(nrow(population$info$cohorts)-length(generation_group[[generation-1]])+1):nrow(population$info$cohorts),,drop=FALSE]
new_numbers <- as.numeric(new_cohorts[,3])
new_numbers[new_numbers==0] <- as.numeric(new_cohorts[new_numbers==0,4])
# Creating-types:
# 0 - Founder
# 1 - Selection
# 2 - Reproduction
# 3 - Recombination
# 4 - Selfing
# 5 - DH-Production
# 6 - Cloning
# 7 - Combine
# 8 - Aging
# 9 - Split
non_copy <- new_cohorts[,9] == 0 | new_cohorts[,9] == 2 | new_cohorts[,9] == 3 | new_cohorts[,9] == 4 | new_cohorts[,9] == 5 | new_cohorts[,9] == 6
new_numbers[!non_copy] <- 0
alive_numbers <- c(alive_numbers, new_numbers)
}
#      death_to <- rbind(death_to, matrix(0, nrow=length(generation_group[[generation-1]]), ncol=nrow(culling_reason)))
t2 <- as.numeric(Sys.time())
from <- if(generation==2){0} else{generation_times[generation-2]}
if(generation != (length(generation_group)+2)){
to <- generation_times[generation-1]
} else{
to <- Inf
}
if(verbose & nrow(culling_reason)>0) cat(paste0("Start culling modul for time span ", from ," to ", to,".\n"))
for(cohort_index in alive_cohorts[alive_numbers>0]){
individual_time <- get.age.point(population, cohorts = cohort_index)
age_start <- min(from - individual_time) ## min()
age_end <- max(to - individual_time) ## max()
sex <- if(population$info$cohorts[cohort_index,4]=="0"){"Male"} else{"Female"}
sex1 <- as.numeric(sex=="Female") + 1
# Time - period, sex
active_culling <- as.numeric(culling_reason[,2]) > age_start & as.numeric(culling_reason[,2]) <= age_end & (culling_reason[,3] == sex | culling_reason[,3]=="Both")
active_cohort <- which(population$info$cohorts[,1]==cohort_index)
for(culling_index in which(active_culling)){
age_start_single <- from - individual_time
age_end_single <- to - individual_time
active_single <- (as.numeric(culling_reason[culling_index,2]) > age_start_single) & (as.numeric(culling_reason[culling_index,2]) <= age_end_single) & rep(culling_reason[culling_index,3] == sex | culling_reason[culling_index,3]=="Both", length(age_end_single))
death_counter <- get.class(population, cohorts=cohort_index)
active_single <- active_single & (death_counter != (-1))
if(sum(active_single)>0){
population <- breeding.diploid(population,
culling.cohorts = cohort_index,
culling.time = as.numeric(culling_reason[culling_index,2]),
culling.name = culling_reason[culling_index,1],
culling.bv1 = as.numeric(culling_reason[culling_index,6]),
culling.bv2 = as.numeric(culling_reason[culling_index,8]),
culling.share1 = as.numeric(culling_reason[culling_index,5]),
culling.share2 = as.numeric(culling_reason[culling_index,7]),
culling.index = selection_index[which(selection_index_name==culling_reason[culling_index,4]),],
culling.single = active_single,
culling.all.copy=TRUE,
verbose=verbose
)
if(length(population$info$culling.stats)>=active_cohort){
new_death <- sum(death_counter != get.class(population, cohorts=cohort_index))
} else{
new_death <- 0
}
if(length(new_death)>0){
alive_numbers[active_cohort] <- alive_numbers[active_cohort] - new_death
}
}
}
if(alive_numbers[active_cohort]==0){
if(verbose) cat(paste0("All individuals in cohort ", cohort_index, " are death.\n"))
if(verbose) cat("Reason for death:\n")
for(index in 1:nrow(population$info$culling.stats[[active_cohort]])){
if(verbose) cat(population$info$culling.stats[[active_cohort]][index,])
if(verbose) cat("\n")
}
}
}
t3 <- as.numeric(Sys.time())
if(generation != (length(generation_group)+2)){
if(verbose){
cat("Generated groups: \n")
cat(generation_group[[generation-1]])
cat("\n")
cat("Time spend: ")
cat(round(t3-t1, digits=2))
cat(" seconds.\n")
cat("For generation: ")
cat(round(t2-t1, digits=2))
cat(" seconds.\n")
cat("For culling: ")
cat(round(t3-t2, digits=2))
cat(" seconds.\n")
}
}
if(TRUE){
temp1 <- length(population$breeding)
population <- clean.up(population, gen = temp1)
for(index2 in 3:30){
test <- population$breeding[[temp1]][[index2]]==as.integer(population$breeding[[temp1]][[index2]])
test[is.na(test)] <- 0
test[is.na(population$breeding[[temp1]][[index2]])] <- 1
if(prod(test)==1){
storage.mode(population$breeding[[temp1]][[index2]]) <- "integer"
}
}
}
if(sum(alive_numbers<0)>0){ stop("Some multi-death?!")}
if(export.population!=FALSE && export.gen == generation){
if(verbose) cat("Export population list to ", export.population)
population_demiraculix <- demiraculix(population)
save(file=export.population, list=c("population", "population_demiraculix"))
}
}
}
}
if(!skip.population){
delete_stuff <- rep(FALSE, length(nodes))
for(index in 1:length(nodes)){
delete_stuff[index] <- nodes[[index]]$delete_info
}
if(sum(delete_stuff)>0){
del_database <- get.database(population, cohorts = ids[delete_stuff])
for(index in 1:nrow(del_database)){
for(index2 in del_database[index,3]:del_database[index,4]){
population$breeding[[del_database[index,1]]][[del_database[index,2]]][[index2]] <- "removed"
}
}
}
}
if(log != FALSE){
sink(zz, append = TRUE, type = c("message"))
warnings()
sink(NULL)
sink(NULL, type=c("message"))
}
if(skip.population){
return(list(costdata, expected_time))
} else{
population$info$json <- list(nodes, edges, geninfo, traitinfo, major, housing, phenotyping, ids)
population$info$cost.data <- as.data.frame(costdata)
population$info$expected.time <- as.data.frame(expected_time)
return(population)
}
}
setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/development/MoBPS/")
devtools::load_all()
devtools::build()
setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/development/MoBPS/")
devtools::load_all()
devtools::build()
pop <- creating.diploid(nsnp=10000, nindi=100,
chr.nr=5, chromosome.length=2,
n.additive=50, n.dominant=10,
name.cohort="Founder",
share.genotyped = 1,
var.target = 1)
pop <- creating.diploid(nsnp=10000, nindi=100,
chr.nr=5, chromosome.length=2,
n.additive=50, n.dominant=10,
name.cohort="Founder",
share.genotyped = 1,
var.target = 1)
# Generate phenotypic observations for all individuals
# Residual variance is set to result in a heritablity of 0.5
pop <- breeding.diploid(pop, heritability=0.5,
phenotyping="all")
# Perform a breeding value estimation using all individuals
# of generation 1 (which are all).
pop <- breeding.diploid(pop, bve=TRUE,
bve.gen = 1)
# Generate 100 offspring
# Use the top 20 male and top 20 female based on their BVE
# All male individuals from the "Founder" cohort are used
# as potential sires.
# All female individuals from the "Founder cohort are used
# as potential dams.
# The resulting cohort in named "Offspring".
pop1 <- breeding.diploid(pop, breeding.size=100,
selection.size=c(20,20),
selection.criteria = "bve",
selection.m.cohorts="Founder_M",
selection.f.cohorts="Founder_F",
name.cohort="Offspring")
# Same procedure, just with a higher selection intensity
# on the male side.
pop2 <- breeding.diploid(pop, breeding.size=100,
selection.size=c(5,20),
selection.m="function",
selection.m.cohorts="Founder_M",
selection.f.cohorts="Founder_F",
name.cohort="Offspring")
?breeding.diploid
set.seed(42)
library(MoBPS)
# Simulation of the Breeding scheme entered in the Web-interface
population <- json.simulation(file="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_WIAS/Task2/Simple Sheep Advanced_baseline.json")
library(MoBPS)
set.seed(42)
# Import genomic data from the first pool
population <- creating.diploid(vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_WIAS/Task6/Pool1.vcf",
name.cohort = "Pool1", sex.quota = 0)
# Import genomic data from the second pool
population <- creating.diploid(population = population, vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_WIAS/Task6/Pool2.vcf",
name.cohort = "Pool2", sex.quota = 1)
population <- creating.trait(population, n.additive = c(10,1000,500), n.equal.dominant = c(0,0,500))
population <- bv.standardization(population, mean.target = c(100,100,100), var.target = c(5,5,5))
library(MoBPS)
set.seed(42)
# Import genomic data from the first pool
population <- creating.diploid(vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_WIAS/Task6/Pool1.vcf",
name.cohort = "Pool1", sex.quota = 0, founder.pool = 1)
# Import genomic data from the second pool
population <- creating.diploid(population = population, vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_WIAS/Task6/Pool2.vcf",
name.cohort = "Pool2", sex.quota = 1, founder.pool = 2)
population <- creating.trait(population, n.additive = c(10,1000,500), n.equal.dominant = c(0,0,500))
population <- bv.standardization(population, mean.target = c(100,100,100), var.target = c(5,5,5))
population <- breeding.diploid(population, breeding.size = c(100,0),
selection.m.cohorts = "Pool1", selection.f.cohorts = "Pool2",
name.cohort = "Hybrid")
summary(population)
# Principle components analysis
get.pca(population, gen=1:2, coloring=c(rep(1,10), rep(2,10), rep(3,100)))
# Extraction of the genomic values of all included lines
bv_pool1 <- get.bv(population, cohorts="Pool1")
bv_pool2 <- get.bv(population, cohorts="Pool2")
bv_hybrid <- get.bv(population, cohorts="Hybrid")
# For trait 3 we can we much higher genomic values of the hybrid lines
# Trait architecture with dominant effects
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
hist(bv_pool1[2,], xlim=c(94,115), main="Trait 2", xlab="genomic value")
hist(bv_pool1[3,], xlim=c(94,115), main="Trait 3", xlab="genomic value")
hist(bv_pool2[1,], xlim=c(94,115), main="", ylab="Pool 2", xlab="genomic value")
hist(bv_pool2[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_pool2[3,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[1,], xlim=c(94,115), main="", ylab="Hybrids", xlab="genomic value")
hist(bv_hybrid[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[3,], xlim=c(94,115), main="", xlab="genomic value")
rowMeans(bv_pool1)
rowMeans(bv_pool2)
rowMeans(bv_hybrid)
set.mean.pool
pop = set.mean.pool(population, mean = c(90, 110), trait = 1,
gen = 1, reference = "pool")
# Extraction of the genomic values of all included lines
bv_pool1 <- get.bv(population, cohorts="Pool1")
bv_pool2 <- get.bv(population, cohorts="Pool2")
bv_hybrid <- get.bv(population, cohorts="Hybrid")
# For trait 3 we can we much higher genomic values of the hybrid lines
# Trait architecture with dominant effects
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
population = set.mean.pool(population, mean = c(90, 110), trait = 1,
gen = 1, reference = "pool")
# Extraction of the genomic values of all included lines
bv_pool1 <- get.bv(population, cohorts="Pool1")
bv_pool2 <- get.bv(population, cohorts="Pool2")
bv_hybrid <- get.bv(population, cohorts="Hybrid")
# For trait 3 we can we much higher genomic values of the hybrid lines
# Trait architecture with dominant effects
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
population = set.mean.pool(population, mean = c(110, 98), trait = 1,
gen = 1, reference = "pool")
# For trait 3 we can we much higher genomic values of the hybrid lines
# Trait architecture with dominant effects
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
# Extraction of the genomic values of all included lines
bv_pool1 <- get.bv(population, cohorts="Pool1")
bv_pool2 <- get.bv(population, cohorts="Pool2")
bv_hybrid <- get.bv(population, cohorts="Hybrid")
# For trait 3 we can we much higher genomic values of the hybrid lines
# Trait architecture with dominant effects
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
hist(bv_pool1[2,], xlim=c(94,115), main="Trait 2", xlab="genomic value")
hist(bv_pool1[3,], xlim=c(94,115), main="Trait 3", xlab="genomic value")
hist(bv_pool2[1,], xlim=c(94,115), main="", ylab="Pool 2", xlab="genomic value")
hist(bv_pool2[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_pool2[3,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[1,], xlim=c(94,115), main="", ylab="Hybrids", xlab="genomic value")
hist(bv_hybrid[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[3,], xlim=c(94,115), main="", xlab="genomic value")
rowMeans(bv_pool1)
rowMeans(bv_pool2)
rowMeans(bv_hybrid)
get.effects(population)
get.effect(population)
get.qtl.effects(population)
get.qtl.effects(population)[[1]][[1]]
library(MoBPS)
set.seed(42)
# Import genomic data from the first pool
population <- creating.diploid(vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_WIAS/Task6/Pool1.vcf",
name.cohort = "Pool1", sex.quota = 0, founder.pool = 1)
# Import genomic data from the second pool
population <- creating.diploid(population = population, vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_WIAS/Task6/Pool2.vcf",
name.cohort = "Pool2", sex.quota = 1, founder.pool = 2)
# Generation of the three different traits
population <- creating.trait(population, n.additive = c(10,1000,500), n.equal.dominant = c(0,0,500))
# You can use mean.target or var.target in creating.diploid or use bv.standardization
# bv.standardization can not only be applied in the initial generation but also
# at later time stages (e.g. if you first want to model some generations of drift / selection / build up)
population <- bv.standardization(population, mean.target = c(100,100,100), var.target = c(5,5,5))
# Simulation of matings between lines from the two gene pools
population <- breeding.diploid(population, breeding.size = c(100,0),
selection.m.cohorts = "Pool1", selection.f.cohorts = "Pool2",
name.cohort = "Hybrid")
summary(population)
# Principle components analysis
get.pca(population, gen=1:2, coloring=c(rep(1,10), rep(2,10), rep(3,100)))
# Extraction of the genomic values of all included lines
bv_pool1 <- get.bv(population, cohorts="Pool1")
bv_pool2 <- get.bv(population, cohorts="Pool2")
bv_hybrid <- get.bv(population, cohorts="Hybrid")
# For trait 3 we can we much higher genomic values of the hybrid lines
# Trait architecture with dominant effects
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
hist(bv_pool1[2,], xlim=c(94,115), main="Trait 2", xlab="genomic value")
hist(bv_pool1[3,], xlim=c(94,115), main="Trait 3", xlab="genomic value")
hist(bv_pool2[1,], xlim=c(94,115), main="", ylab="Pool 2", xlab="genomic value")
hist(bv_pool2[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_pool2[3,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[1,], xlim=c(94,115), main="", ylab="Hybrids", xlab="genomic value")
hist(bv_hybrid[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[3,], xlim=c(94,115), main="", xlab="genomic value")
rowMeans(bv_pool1)
rowMeans(bv_pool2)
rowMeans(bv_hybrid)
population = set.mean.pool(population, mean = c(110, 98), trait = 1,
gen = 1, reference = "pool")
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
hist(bv_pool1[2,], xlim=c(94,115), main="Trait 2", xlab="genomic value")
hist(bv_pool1[3,], xlim=c(94,115), main="Trait 3", xlab="genomic value")
hist(bv_pool2[1,], xlim=c(94,115), main="", ylab="Pool 2", xlab="genomic value")
hist(bv_pool2[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_pool2[3,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[1,], xlim=c(94,115), main="", ylab="Hybrids", xlab="genomic value")
hist(bv_hybrid[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[3,], xlim=c(94,115), main="", xlab="genomic value")
rowMeans(bv_pool1)
rowMeans(bv_pool2)
rowMeans(bv_hybrid)
# Extraction of the genomic values of all included lines
bv_pool1 <- get.bv(population, cohorts="Pool1")
bv_pool2 <- get.bv(population, cohorts="Pool2")
bv_hybrid <- get.bv(population, cohorts="Hybrid")
# For trait 3 we can we much higher genomic values of the hybrid lines
# Trait architecture with dominant effects
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
hist(bv_pool1[2,], xlim=c(94,115), main="Trait 2", xlab="genomic value")
hist(bv_pool1[3,], xlim=c(94,115), main="Trait 3", xlab="genomic value")
hist(bv_pool2[1,], xlim=c(94,115), main="", ylab="Pool 2", xlab="genomic value")
hist(bv_pool2[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_pool2[3,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[1,], xlim=c(94,115), main="", ylab="Hybrids", xlab="genomic value")
hist(bv_hybrid[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[3,], xlim=c(94,115), main="", xlab="genomic value")
rowMeans(bv_pool1)
rowMeans(bv_pool2)
rowMeans(bv_hybrid)
get.qtl.effects(population)[[1]][[1]]
get.qtl.effects(population)[[1]][[1]][5500,]
library(MoBPS)
set.seed(42)
# Import genomic data from the first pool
population <- creating.diploid(vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_WIAS/Task6/Pool1.vcf",
name.cohort = "Pool1", sex.quota = 0, founder.pool = 1)
# Import genomic data from the second pool
population <- creating.diploid(population = population, vcf="C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/MoBPS_Workshop_WIAS/Task6/Pool2.vcf",
name.cohort = "Pool2", sex.quota = 1, founder.pool = 2)
# Generation of the three different traits
population <- creating.trait(population, n.additive = c(10,1000,500), n.equal.dominant = c(0,0,500))
# You can use mean.target or var.target in creating.diploid or use bv.standardization
# bv.standardization can not only be applied in the initial generation but also
# at later time stages (e.g. if you first want to model some generations of drift / selection / build up)
population <- bv.standardization(population, mean.target = c(100,100,100), var.target = c(5,5,5))
# Simulation of matings between lines from the two gene pools
population <- breeding.diploid(population, breeding.size = c(100,0),
selection.m.cohorts = "Pool1", selection.f.cohorts = "Pool2",
name.cohort = "Hybrid")
summary(population)
# Principle components analysis
get.pca(population, gen=1:2, coloring=c(rep(1,10), rep(2,10), rep(3,100)))
# Extraction of the genomic values of all included lines
bv_pool1 <- get.bv(population, cohorts="Pool1")
bv_pool2 <- get.bv(population, cohorts="Pool2")
bv_hybrid <- get.bv(population, cohorts="Hybrid")
# For trait 3 we can we much higher genomic values of the hybrid lines
# Trait architecture with dominant effects
par(mfrow=c(3,3))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
hist(bv_pool1[2,], xlim=c(94,115), main="Trait 2", xlab="genomic value")
hist(bv_pool1[3,], xlim=c(94,115), main="Trait 3", xlab="genomic value")
hist(bv_pool2[1,], xlim=c(94,115), main="", ylab="Pool 2", xlab="genomic value")
hist(bv_pool2[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_pool2[3,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[1,], xlim=c(94,115), main="", ylab="Hybrids", xlab="genomic value")
hist(bv_hybrid[2,], xlim=c(94,115), main="", xlab="genomic value")
hist(bv_hybrid[3,], xlim=c(94,115), main="", xlab="genomic value")
rowMeans(bv_pool1)
rowMeans(bv_pool2)
rowMeans(bv_hybrid)
real.bv.add = get.qtl.effects(population)[[1]]
real.bv.add
real.bv.add[,7] = 1
real.bv.add
real.bv.add = get.qtl.effects(population)[[1]][[1]]
real.bv.add[,7] = 1
pop1 = creating.trait(population, replace.traits = TRUE,
real.bv.add = real.bv.add)
bv_pool1 <- get.bv(pop1, cohorts="Pool1")
bv_pool2 <- get.bv(pop1, cohorts="Pool2")
bv_hybrid <- get.bv(pop1, cohorts="Hybrid")
par(mfrow=c(3,1))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
hist(bv_pool2[1,], xlim=c(94,115), main="", ylab="Pool 2", xlab="genomic value")
bv_pool2[1,]
hist(bv_hybrid[1,], xlim=c(94,115), main="", ylab="Hybrids", xlab="genomic value")
pop2 = set.mean.pool(population, mean = c(110, 98), trait = 1,
gen = 1, reference = "pool")
get.qtl.effects(pop2)[[1]][[1]]
bv_pool1 <- get.bv(pop2, cohorts="Pool1")
bv_pool2 <- get.bv(pop2, cohorts="Pool2")
bv_hybrid <- get.bv(pop2, cohorts="Hybrid")
par(mfrow=c(3,1))
hist(bv_pool1[1,], xlim=c(94,115), main="Trait 1", ylab="Pool 1", xlab="genomic value")
hist(bv_pool2[1,], xlim=c(94,115), main="", ylab="Pool 2", xlab="genomic value")
hist(bv_hybrid[1,], xlim=c(94,115), main="", ylab="Hybrids", xlab="genomic value")
setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/development/MoBPS/")
devtools::load_all()
pop <- creating.diploid(nsnp=10000, nindi=100,
chr.nr=5, chromosome.length=2,
n.additive=50, n.dominant=10,
name.cohort="Founder",
share.genotyped = 1,
var.target = 1)
pop <- creating.diploid(nsnp=10000, nindi=100,
chr.nr=5, chromosome.length=2,
n.additive=50, n.dominant=10,
name.cohort="Founder",
share.genotyped = 1,
var.target = 1)
pop <- creating.diploid(nsnp=10000, nindi=100,
chr.nr=5, chromosome.length=2,
n.additive=50, n.dominant=10,
name.cohort="Founder",
share.genotyped = 1,
var.target = 1)
# Generate phenotypic observations for all individuals
# Residual variance is set to result in a heritablity of 0.5
pop <- breeding.diploid(pop, heritability=0.5,
phenotyping="all")
# Perform a breeding value estimation using all individuals
# of generation 1 (which are all).
pop <- breeding.diploid(pop, bve=TRUE,
bve.gen = 1)
# Generate 100 offspring
# Use the top 20 male and top 20 female based on their BVE
# All male individuals from the "Founder" cohort are used
# as potential sires.
# All female individuals from the "Founder cohort are used
# as potential dams.
# The resulting cohort in named "Offspring".
pop1 <- breeding.diploid(pop, breeding.size=100,
selection.size=c(20,20),
selection.criteria = "bve",
selection.m.cohorts="Founder_M",
selection.f.cohorts="Founder_F",
name.cohort="Offspring")
?breeding.diploid
set.seed(42)
library(MoBPS)
population <- creating.diploid(nsnp = 5000, nindi = 50, sex.quota=0,
chr.nr = 5, chromosome.length = 1, name.cohort = "1yearRams")
population <- creating.diploid(population = population, freq = "same", nindi = 10,
sex.quota=0, name.cohort = "2yearRams")
population <- creating.diploid(population = population, freq = "same", nindi = 50,
sex.quota=1, name.cohort = "1yearEwes")
population <- creating.diploid(population = population, freq = "same", nindi = 40,
sex.quota=1, name.cohort = "2yearEwes")
population <- creating.diploid(population = population, freq = "same", nindi = 30,
sex.quota=1, name.cohort = "3yearEwes")
summary(population)
get.cohorts(population, extended = TRUE)[,1:4]
population <- creating.trait(population, n.additive = 1000, mean.target = 100,
var.target = 30, trait.name = "Meat")
get.qtl(population)
get.qtl.effects(population)
population <- breeding.diploid(population, phenotyping = "all", heritability = 0.3)
get.pheno(population, cohorts="1yearRams")
population <- breeding.diploid(population, breeding.size = c(50,0),
selection.m.cohorts = "2yearRams",
selection.f.cohorts = c("2yearEwes", "3yearEwes"),
name.cohort = "1yearRamsNext")
