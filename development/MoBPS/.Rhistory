G <- newG
}
###Festlegung: breeding cycle 10 als Startpunkt (1-9 zur Simulation der Altersstruktur raus)
start = 10
##End20 damit 21 nicht drin
end = 20
rep <- as.numeric(rep)
## Schreibe hier die Art der Kohorte fuer die Plots erstellt werden sollen
## Ersetze jeweils den Zyklus mit X
cohorts_to_plot <- which(coh_type=="Zuchtpopulation_X_M" & rep>=start & rep<=end)
selectionindex = c(10, 7.5, 7.5, 20, 10, 2.5, 2.5, 3.125, 5, 0, 15, 0, 0, 0, 2.5, 2.5, 2.5, 6.25, 3.125, 0, 0, 0)
is_ref <- which(coh_type=="Zuchtpopulation_X_M" & rep==start)
# Standardisierung aller Simulation auf die start-Generation (Burn-in)
for(sc in 1:6){
ref1 <- BV_total[[sc]][,is_ref]
ref2 <-  BVE_total[[sc]][,is_ref]
ref3 <- Pheno_total[[sc]][,is_ref]
for(coh in unique(coh_type)){
to_scale <- which(coh_type==coh)
BV_total[[sc]][,to_scale] = BV_total[[sc]][,to_scale] - ref1
BVE_total[[sc]][,to_scale] =  BVE_total[[sc]][,to_scale] - ref2
Pheno_total[[sc]][,to_scale] =  Pheno_total[[sc]][,to_scale] - ref3
for(index in 1:250){
if(length(conf[[sc]]) >= index && length(conf[[sc]][[index]])>0){
conf[[sc]][[index]][,to_scale] <- conf[[sc]][[index]][,to_scale] - ref1
}
}
}
}
###Format AngebN: Farben und Scenarien Beschreibungen
col <- c("black", "darkgreen", "darkmagenta", "darkorange1", "red", "blue")
colT <- c("black", "red", "blue")
colNA <- c("black", "darkgreen", "darkmagenta", "darkorange1")
#sc_name <- c("Reference", "NA50", "NA100",
#"NA100+", "ST+FT", "FT")
sc_nameNA <- c("Reference", "NA50", "NA100",
"NA100+")
sc_nameT <- c("Reference", "ST+FT", "FT")
## Gesamt ZF als barplot (nicht ins Paper, nur zur Veranschaulichung)
total_scale <- selectionindex[1:19]
gSD <- sqrt(10) * c(rep(1, 19),
sqrt(total_scale %*% G %*% total_scale))
par(mfrow=c(1,1))
gain <- numeric(12)
for(index in 1:6){
gain[index] <- colSums(selectionindex * BV_total[[index]][,cohorts_to_plot]) [length(cohorts_to_plot)]
}
gain <- gain[1:6]
barplot(gain, col=col, ylim=c(min(gain)-min(gain)*0.1, max(gain)))
abline(h = gain[1])
gain/gain[1]
###################################################################################################################
par(mfrow=c(2,2))
par(mar=c(5,5,4,2))
#par(mar=c(5,5,4,1))
####ADGf #########
{
total_scale <- selectionindex[1:19]
gSD <- sqrt(10) * c(rep(1, 19),
sqrt(total_scale %*% G %*% total_scale))
#par(mar=c(5,5,4,3))
trait.name = c("NL", "wool", "MC", "BC", "ADGf", "FLNf", "UMDf", "UFDf", "NA", "ADGs",
"FCR", "UMDs", "UFDs", "FLNs", "SW", "BMA", "WC", "SFA", "PKF")
for(bven in c(1)){
ylims <- c(0,0)
for(sc in 1:6){
ylims[1] <- min(ylims[1], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
ylims[2] <- max(ylims[2], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
}
#### Manuelle Festlegung der Grenzen des Plots
if(bven==2 || bven==3 || bven==4){
ylims <- c(-2,10)
} else{
ylims <- c(-0.25,1.25)
}
plot(rep[cohorts_to_plot] ,   BV_total[[1]][bven,cohorts_to_plot] / gSD[bven],
type="l", ylab="gSD", xlab="breeding cycle", main=expression("ADG"[f]), lwd=4, ylim=ylims, cex.lab=1.4, cex.main=1.8, cex.axis=1.4, xaxt="n", font.main=1, font.axis=1, font.lab=1)
axis(1, at=c(10,12,14,16,18,20), label = c(0,2,4,6,8,10), cex.axis=1.4, cex.lab= 1.4)
for(sc in c(5:6)){
lines( rep[cohorts_to_plot] ,   BV_total[[sc]][bven,cohorts_to_plot]/gSD[bven], type="l",  col=col[sc], lwd=4)
}
}
legend("topleft", sc_nameT, col=colT,  lwd=4, lty=7, cex = 1.4, bty = "n")
}
###FLNf#########################################################
{
total_scale <- selectionindex[1:19]
gSD <- sqrt(10) * c(rep(1, 19),
sqrt(total_scale %*% G %*% total_scale))
#par(mfrow=c(1,1))
#par(mar=c(5,5,4,3))
trait.name = c("NL", "wool", "MC", "BC", "ADGf", "FLNf", "UMDf", "UFDf", "NA", "ADGs",
"FCR", "UMDs", "UFDs", "FLNs", "SW", "BMA", "WC", "SFA", "PKF")
for(bven in c(2)){
ylims <- c(0,0)
for(sc in 1:6){
ylims[1] <- min(ylims[1], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
ylims[2] <- max(ylims[2], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
}
#### Manuelle Festlegung der Grenzen des Plots
if(bven==2 || bven==3 || bven==4){
ylims <- c(-2,10)
} else{
ylims <- c(-0.25,1.25)
}
plot(rep[cohorts_to_plot] ,   BV_total[[1]][bven,cohorts_to_plot] / gSD[bven],
type="l", ylab="gSD", xlab="breeding cycle", main=expression("FLN"[f]), lwd=4, ylim=ylims, cex.lab=1.4, cex.main=1.8, cex.axis=1.4, xaxt="n", font.main=1, font.axis=1, font.lab=1)
axis(1, at=c(10,12,14,16,18,20), label = c(0,2,4,6,8,10), cex.axis=1.4, cex.lab= 1.4)
for(sc in c(5:6)){
lines( rep[cohorts_to_plot] ,   BV_total[[sc]][bven,cohorts_to_plot]/gSD[bven], type="l", col=col[sc], lwd=4)
}
}
legend("topleft", sc_nameT, col=colT,  lwd=4, lty=7, cex = 1.4, bty = "n")
}
###UMDf#####################################
{
total_scale <- selectionindex[1:19]
gSD <- sqrt(10) * c(rep(1, 19),
sqrt(total_scale %*% G %*% total_scale))
#par(mfrow=c(1,1))
#par(mar=c(5,5,4,3))
trait.name = c("NL", "wool", "MC", "BC", "ADGf", "FLNf", "UMDf", "UFDf", "NA", "ADGs",
"FCR", "UMDs", "UFDs", "FLNs", "SW", "BMA", "WC", "SFA", "PKF")
for(bven in c(3)){
ylims <- c(0,0)
for(sc in 1:6){
ylims[1] <- min(ylims[1], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
ylims[2] <- max(ylims[2], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
}
#### Manuelle Festlegung der Grenzen des Plots
if(bven==2 || bven==3 || bven==4){
ylims <- c(-2,10)
} else{
ylims <- c(-0.25,1.25)
}
#  range <- c(min(BV_total[[1]][bven,cohorts_to_plot], BV_total[[2]][bven,cohorts_to_plot], BV_total[[3]][bven,cohorts_to_plot],
#                 BV_total[[4]][bven,cohorts_to_plot], BV_total[[5]][bven,cohorts_to_plot], BV_total[[6]][bven,cohorts_to_plot],
#                 BV_total[[7]][bven,cohorts_to_plot], BV_total[[8]][bven,cohorts_to_plot]),
#             max(BV_total[[1]][bven,cohorts_to_plot], BV_total[[2]][bven,cohorts_to_plot], BV_total[[3]][bven,cohorts_to_plot],
#                 BV_total[[4]][bven,cohorts_to_plot], BV_total[[5]][bven,cohorts_to_plot], BV_total[[6]][bven,cohorts_to_plot],
#                 BV_total[[7]][bven,cohorts_to_plot], BV_total[[8]][bven,cohorts_to_plot]))
plot(rep[cohorts_to_plot] ,   BV_total[[1]][bven,cohorts_to_plot] / gSD[bven],
type="l", ylab="gSD", xlab="breeding cycle", main=expression("UMD"[f]), lwd=4, ylim=ylims, cex.lab=1.4, cex.main=1.8, cex.axis=1.4, xaxt="n", font.main=1, font.axis=1, font.lab=1)
axis(1, at=c(10,12,14,16,18,20), label = c(0,2,4,6,8,10), cex.axis=1.4, cex.lab= 1.4)
for(sc in c(5:6)){
lines( rep[cohorts_to_plot] ,   BV_total[[sc]][bven,cohorts_to_plot]/gSD[bven], type="l",  col=col[sc], lwd=4)
}
}
legend("topleft", sc_nameT, col=colT,  lwd=4, lty=7, cex = 1.4, bty = "n")
}
###UFDf#################################################
{
total_scale <- selectionindex[1:19]
gSD <- sqrt(10) * c(rep(1, 19),
sqrt(total_scale %*% G %*% total_scale))
#par(mfrow=c(1,1))
#par(mar=c(5,5,4,3))
trait.name = c("NL", "wool", "MC", "BC", "ADGf", "FLNf", "UMDf", "UFDf", "NA", "ADGs",
"FCR", "UMDs", "UFDs", "FLNs", "SW", "BMA", "WC", "SFA", "PKF")
for(bven in c(4)){
ylims <- c(0,0)
for(sc in 1:6){
ylims[1] <- min(ylims[1], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
ylims[2] <- max(ylims[2], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
}
#### Manuelle Festlegung der Grenzen des Plots
if(bven==2 || bven==3 || bven==4){
ylims <- c(-2,10)
} else{
ylims <- c(-0.25,1.25)
}
plot(rep[cohorts_to_plot] ,   BV_total[[1]][bven,cohorts_to_plot] / gSD[bven],
type="l", ylab="gSD", xlab="breeding cycle", main=expression("UFD"[f]), lwd=4, ylim=ylims, cex.lab=1.4, cex.main=1.8, cex.axis=1.4, xaxt="n", font.main=1, font.axis=1, font.lab=1)
axis(1, at=c(10,12,14,16,18,20), label = c(0,2,4,6,8,10), cex.axis=1.4, cex.lab= 1.4)
for(sc in c(5:6)){
lines( rep[cohorts_to_plot] ,   BV_total[[sc]][bven,cohorts_to_plot]/gSD[bven], type="l",  col=col[sc], lwd=4)
}
}
legend("topleft", sc_nameT, col=colT,  lwd=4, lty=7, cex = 1.4, bty = "n")
}
##################################################################################################################
#### nursing ability plot ####
par(mfrow=c(1,1))
par(mar=c(5,5,4,3))
{
total_scale <- selectionindex[1:19] + selectionindex[20] * c(0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0) +
selectionindex[21] * c(0,0,0,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0) +
selectionindex[22] * c(0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,2,1)
gSD <- sqrt(10) * c(rep(1, 19),
sqrt(c(0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0) %*% G %*% c(0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0)),
sqrt(c(0,0,0,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0) %*% G %*% c(0,0,0,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0)),
sqrt(c(0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,2,1) %*% G %*% c(0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,2,1)),
sqrt(total_scale %*% G %*% total_scale))
#par(mfrow=c(1,1))
par(mar=c(5,5,4,3))
trait.name = c("NL", "wool", "MC", "BC", "ADGf", "FLNf", "UMDf", "UFDf", "NA", "ADGs",
"FCR", "UMDs", "UFDs", "FLNs", "SW", "BMA", "WC", "SFA", "PKF")
for(bven in c(9)){
ylims <- c(0,0)
for(sc in 1:6){
ylims[1] <- min(ylims[1], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
ylims[2] <- max(ylims[2], BV_total[[sc]][bven,cohorts_to_plot]/ gSD[bven])
}
#### Manuelle Festlegung der Grenzen des Plots
if(bven==2 || bven==3 || bven==4){
ylims <- c(-2,10)
} else{
ylims <- c(-0.25,1.25)
}
plot(rep[cohorts_to_plot] ,   BV_total[[1]][bven,cohorts_to_plot] / gSD[bven],
type="l", ylab="gSD", xlab="breeding cycle", main=trait.name[bven], lwd=4, ylim=ylims, cex.lab=1.4, cex.main=1.8, cex.axis=1.4, xaxt="n", font.main=1, font.axis=1, font.lab=1) ##font =1 not bold but plain
axis(1, at=c(10,12,14,16,18,20), label = c(0,2,4,6,8,10), cex.axis=1.4, cex.lab= 1.4)
for(sc in c(2:4)){
lines( rep[cohorts_to_plot] ,   BV_total[[sc]][bven,cohorts_to_plot]/gSD[bven], type="l",  col=col[sc], lwd=4)
}
}
legend("topleft", sc_nameNA, col=col,  lwd=4, lty=7, cex = 1.4, bty = "n") ##cex 1.4 als einheitliche Schriftgröße in main, axis und lab
}
##Figure 1: TMI
{
par(mfrow=c(1,2))
par(mar=c(5,5,4,2))
ylims <- c(0,4)
plot( rep[cohorts_to_plot] ,  colSums(selectionindex * BV_total[[1]][,cohorts_to_plot]/ gSD[23]), ylim=ylims, type="l", ylab="gSD", xlab="breeding cycle",   xaxt="n", main="TMI", cex.lab=1.4, cex.main=1.8, cex.axis=1.4, font.main=1, font.axis=1, font.lab=1, lwd=4)
axis(1, at=c(10,12,14,16,18,20), label = c(0,2,4,6,8,10), cex.axis=1.4, cex.lab= 1.4)
for(sc in 5:6){
lines( rep[cohorts_to_plot] ,  colSums(selectionindex * BV_total[[sc]][,cohorts_to_plot]/ gSD[23]), type="l", col=col[sc], lwd=4)
}
legend("topleft", sc_nameT, col=colT, lwd=4, lty=7, cex = 1.4, bty = "n")
plot( rep[cohorts_to_plot] ,  colSums(selectionindex * BV_total[[1]][,cohorts_to_plot]/ gSD[23]), ylim=ylims, type="l", xaxt="n", ylab="gSD", xlab="breeding cycle",  main="TMI", cex.lab=1.4, cex.main=1.8, cex.axis=1.4, font.main=1, font.axis=1, font.lab=1, lwd=4)
axis(1, at=c(10,12,14,16,18,20), label = c(0,2,4,6,8,10), cex.axis=1.4, cex.lab= 1.4)
for(sc in 2:4){
lines( rep[cohorts_to_plot] ,  colSums(selectionindex * BV_total[[sc]][,cohorts_to_plot]/ gSD[23]), type="l", col=col[sc], lwd=4)
}
legend("topleft", sc_nameNA, col=col[1:4], lwd=4, lty=7, cex = 1.4, bty = "n")
}
###### TORSTEN ADD
##Figure 1B: Relative difference in TMI
{
par(mfrow=c(1,2))
par(mar=c(5,5,4,2))
ylims <- c(-0.2,0.2)
plot( rep[cohorts_to_plot] ,  colSums(selectionindex * BV_total[[1]][,cohorts_to_plot]/ gSD[23]) - colSums(selectionindex * BV_total[[1]][,cohorts_to_plot]/ gSD[23]), ylim=ylims, type="l", ylab="relative differences to reference in gSD", xlab="breeding cycle",   xaxt="n", main="TMI", cex.lab=1.4, cex.main=1.8, cex.axis=1.4, font.main=1, font.axis=1, font.lab=1, lwd=4)
axis(1, at=c(10,12,14,16,18,20), label = c(0,2,4,6,8,10), cex.axis=1.4, cex.lab= 1.4)
for(sc in 5:6){
lines( rep[cohorts_to_plot] ,  colSums(selectionindex * BV_total[[sc]][,cohorts_to_plot]/ gSD[23]) -
colSums(selectionindex * BV_total[[1]][,cohorts_to_plot]/ gSD[23]), type="l", col=col[sc], lwd=4)
}
legend("topleft", sc_nameT, col=colT, lwd=4, lty=7, cex = 1.4, bty = "n")
plot( rep[cohorts_to_plot] ,  colSums(selectionindex * BV_total[[1]][,cohorts_to_plot]/ gSD[23]) -  colSums(selectionindex * BV_total[[1]][,cohorts_to_plot]/ gSD[23]), ylim=ylims, type="l", xaxt="n", ylab="gSD", xlab="breeding cycle",  main="TMI", cex.lab=1.4, cex.main=1.8, cex.axis=1.4, font.main=1, font.axis=1, font.lab=1, lwd=4)
axis(1, at=c(10,12,14,16,18,20), label = c(0,2,4,6,8,10), cex.axis=1.4, cex.lab= 1.4)
for(sc in 2:4){
lines( rep[cohorts_to_plot] ,  colSums(selectionindex * BV_total[[sc]][,cohorts_to_plot]/ gSD[23]) -  colSums(selectionindex * BV_total[[1]][,cohorts_to_plot]/ gSD[23]), type="l", col=col[sc], lwd=4)
}
legend("topleft", sc_nameNA, col=col[1:4], lwd=4, lty=7, cex = 1.4, bty = "n")
}
###ADGf
mean(Acc_total[[1]][5,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
mean(Acc_total[[5]][5,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
mean(Acc_total[[6]][5,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 6 & trait 5
###ADGf
mean(Acc_total[[1]][23,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
###ADGf
mean(Acc1_total[[1]][23,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
mean(Acc1_total[[5]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
mean(Acc1_total[[6]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 6 & trait 5
Acc1_total[[6]]
dim(Acc1_total[[6]])
###ADGf
mean(Acc1_total[[1]][23,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
mean(Acc1_total[[5]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
mean(Acc1_total[[6]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 6 & trait 5
###ADGf
mean(Acc1_total[[1]][23,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
mean(Acc1_total[[2]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
mean(Acc1_total[[3]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
mean(Acc1_total[[4]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
mean(Acc1_total[[5]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
mean(Acc1_total[[6]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 6 & trait 5
accs = matrix(0, nrow=6, ncol=23)
for(index in 1:23){
accs[1,index] = mean(Acc1_total[[1]][23,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
accs[2,index] = mean(Acc1_total[[2]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
accs[3,index] = mean(Acc1_total[[3]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
accs[4,index] = mean(Acc1_total[[4]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
accs[5,index] = mean(Acc1_total[[5]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
accs[6,index] = mean(Acc1_total[[6]][23,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 6 & trait 5
}
accs
accs = matrix(0, nrow=6, ncol=23)
for(index in 1:23){
accs[1,index] = mean(Acc1_total[[1]][index,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
accs[2,index] = mean(Acc1_total[[2]][index,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
accs[3,index] = mean(Acc1_total[[3]][index,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
accs[4,index] = mean(Acc1_total[[4]][index,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
accs[5,index] = mean(Acc1_total[[5]][index,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 5 & trait 5
accs[6,index] = mean(Acc1_total[[6]][index,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 6 & trait 5
}
accs
plot(accs[1,])
barplot(accs)
barplot(t(accs))
accs[,5]
accs[,6]
##UMDf
mean(Acc_total[[1]][7,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 1 & trait 7
mean(Acc_total[[5]][7,cohorts_to_plot], na.rm=TRUE)
mean(Acc_total[[6]][7,cohorts_to_plot], na.rm=TRUE)
mean(Acc1_total[[1]][7,cohorts_to_plot], na.rm=TRUE)  #####average accuracy across 30 breeding cycles for scenario 1 & trait 7
mean(Acc1_total[[5]][7,cohorts_to_plot], na.rm=TRUE)
mean(Acc1_total[[6]][7,cohorts_to_plot], na.rm=TRUE)
cohorts_to_plot
accs
accs[,23]
accs = matrix(0, nrow=6, ncol=23)
for(index in 1:23){
for(sc in 1:6){
accs[sc,index] = mean(Acc1_total[[sc]][index,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
}
}
trait.name
barplot(accs[,23])
barplot(accs[,23], main = "TMI")
par(mfrow=c(5,1))
barplot(accs[,23], main = "TMI")
barplot(accs[,23], main = "TMI")
par(mfrow=c(2,3))
barplot(accs[,23], main = "TMI")
trait.name = c("NL", "wool", "MC", "BC", "ADGf", "FLNf", "UMDf", "UFDf", "NA", "ADGs",
"FCR", "UMDs", "UFDs", "FLNs", "SW", "BMA", "WC", "SFA", "PKF")
par(mfrow=c(2,3))
barplot(accs[,23], main = "TMI")
for(bven in c(5,6, 7, 8,9)){
barplot(accs[,5], main = trait.name[bven])
}
trait.name = c("NL", "wool", "MC", "BC", "ADGf", "FLNf", "UMDf", "UFDf", "NA", "ADGs",
"FCR", "UMDs", "UFDs", "FLNs", "SW", "BMA", "WC", "SFA", "PKF")
par(mfrow=c(2,3))
barplot(accs[,23], main = "TMI")
for(bven in c(5,6, 7, 8,9)){
barplot(accs[,bven], main = trait.name[bven])
}
accs
accs = matrix(0, nrow=6, ncol=23)
vars = matrix(0, nrow=6, ncol=23)
for(index in 1:23){
for(sc in 1:6){
accs[sc,index] = mean(Acc1_total[[sc]][index,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
vars[sc,index] = sd(Acc1_total[[sc]][index,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
}
}
vars
accs = matrix(0, nrow=6, ncol=23)
sds = matrix(0, nrow=6, ncol=23)
for(index in 1:23){
for(sc in 1:6){
accs[sc,index] = mean(Acc1_total[[sc]][index,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
sds[sc,index] = sd(Acc1_total[[sc]][index,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
}
}
sds
pheno_matrix[7,]
sd(Acc_total[[1]][5,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
sd(Acc_total[[5]][5,cohorts_to_plot], na.rm=TRUE)
sd(Acc_total[[6]][5,cohorts_to_plot], na.rm=TRUE)
accs = matrix(0, nrow=6, ncol=23)
sds = matrix(0, nrow=6, ncol=23)
for(index in 1:23){
for(sc in 1:6){
accs[sc,index] = mean(Acc1_total[[sc]][index,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
sds[sc,index] = sd(Acc1_total[[sc]][index,cohorts_to_plot], na.rm=TRUE) #####average accuracy across 30 breeding cycles for scenario 1 & trait 5
}
}
sds
sds*sqrt(50)
# average across 50 simulation
sds * sqrt(50) # SD of a single simulation
Acc1_total
Acc1_total[[sc]][index,cohorts_to_plot]
# average across 50 simulation
sds * sqrt(50) # SD of a single simulation
evolutionary_log$selection.rate
evolutionary_log$selection.rate = cbind(evolutionary_log$selection.rate ,c(n_sel1, n_sel2, n_sel3))
evolutionary_log$selection.rate
evolutionary_log$n_off
evolutionary_log$center
new_setting
evolutionary_log$n_off
distance1
distance2
index =1
index2 = 2
dir1 = ((evolutionary_log$center[,index] - evolutionary_log$center[,index+1])) / evolutionary_log$sd[,iteration-1]
dir1
dir2 = ((evolutionary_log$center[,index2] - evolutionary_log$center[,index2+1])) /  evolutionary_log$sd[,iteration-1]
dir2
sum(dir1 * dir2) / sqrt(sum(dir1^2)) / sqrt(sum(dir2^2))
acos(sum(dir1 * dir2) / sqrt(sum(dir1^2)) / sqrt(sum(dir2^2)))
dir1 = c(3,1)
dir2= c(1,3)
acos(sum(dir1 * dir2) / sqrt(sum(dir1^2)) / sqrt(sum(dir2^2)))
dir2= c(3,1)
acos(sum(dir1 * dir2) / sqrt(sum(dir1^2)) / sqrt(sum(dir2^2)))
?acos
cos(acos(0.5))
cos(acos(0.3))
cos(acos(0.1))
cos(acos(-0.1))
cos(acos(3))
cos(acos(2))
distance4 = matrix(0, ncol = iteration-1, nrow=iteration-1) # number of parameters that moved in the same direction
for(index in 1:(iteration-1)){
for(index2 in 1:(iteration-1)){
dir1 = ((evolutionary_log$center[,index] - evolutionary_log$center[,index+1])) / evolutionary_log$sd[,iteration-1]
dir2 = ((evolutionary_log$center[,index2] - evolutionary_log$center[,index2+1])) /  evolutionary_log$sd[,iteration-1]
distance4[index,index2] = acos(sum(dir1 * dir2) / sqrt(sum(dir1^2)) / sqrt(sum(dir2^2)))
}
}
distance4
results_new
dim(results_new)
results_new[,20]
evolutionary_log$target_value_avg
results_new
which_selected
sorting$ix[-which_selected]
id_selected = sorting$ix[which_selected]
id_selected
sortingb
# we are removing the lines that we already selected
cand <- results_new[sorting$ix[-which_selected],] ## Not selected already selected individuals from the previous step
# apply smoothing on candidates, put the smooth value in the last columns, # expected performance of the candidates then will be added
# it should be smaller compare to before due to smoothing
for(index in 1:nrow(cand)){ # compute smooting
cand[index, ncol(cand)] <- approx_f(cand[index, param_cols], range/2, results_smooth)
}
sort_cand <- sort(cand[,ncol(cand)], index.return=TRUE, decreasing = TRUE)
sort_cand
cand
sort_cand
cand[,ncol(cand)]
approx_f
# we are removing the lines that we already selected
cand <- results_new[sorting$ix[-which_selected],] ## Not selected already selected individuals from the previous step
cand
sort_cand <- sort(cand[,ncol(cand)], index.return=TRUE, decreasing = TRUE)
sort_cand
sort_cand$ix
(1:nrow(results_new))[-which_selected]
potential_settings = (1:nrow(results_new))[-which_selected][sort_cand$ix]
potential_settings
sort_cand$ix
plot(potential_settings)
plot(diff(potential_settings))
id_selected
cand[activ_indi,]
cand[activ_indi,]
cand[activ_indi,]==t(results_new)
cand[activ_indi,]
colSums(cand[activ_indi,]==t(results_new))
which.max(colSums(cand[activ_indi,]==t(results_new)))
results_new[1104,]
results_new[1104,] == cand[activ_indi]
cand[activ_indi]
results_new[1104,] == cand[activ_indi,]
id_selected
id_selected
iteration = 3\
iteration = 3
evolutionary_log$n_off[,iteration-2]
evolutionary_log$n_off[1,iteration-2]
id_selected
sum(id_selected <= evolutionary_log$n_off[1,iteration-2])
if(evolutionary_log$n_off[2,iteration-2] > 0){
prop_noff2 = sum((id_selected <= sum(evolutionary_log$n_off[1:2,iteration-2])) & (id_selected > sum(evolutionary_log$n_off[1,iteration-2])) ) / evolutionary_log$n_off[2,iteration-2]
}
prop_noff2
prop_noff1
if(evolutionary_log$n_off[1,iteration-2] > 0){
prop_noff1 = sum(id_selected <= evolutionary_log$n_off[1,iteration-2]) / evolutionary_log$n_off[1,iteration-2]
}
prop_noff1
prop_noff1 = prop_noff2 = prop_noff3 = prop_noff4 = 0
if(evolutionary_log$n_off[1,iteration-2] > 0){
prop_noff1 = sum(id_selected <= evolutionary_log$n_off[1,iteration-2]) / evolutionary_log$n_off[1,iteration-2]
}
if(evolutionary_log$n_off[2,iteration-2] > 0){
prop_noff2 = sum((id_selected <= sum(evolutionary_log$n_off[1:2,iteration-2])) & (id_selected > sum(evolutionary_log$n_off[1,iteration-2])) ) / evolutionary_log$n_off[2,iteration-2]
}
if(evolutionary_log$n_off[3,iteration-2] > 0){
prop_noff3 = sum((id_selected <= sum(evolutionary_log$n_off[1:3,iteration-2])) & (id_selected > sum(evolutionary_log$n_off[1:2,iteration-2])) ) / evolutionary_log$n_off[3,iteration-2]
}
if(evolutionary_log$n_off[4,iteration-2] > 0){
prop_noff4 = sum((id_selected <= sum(evolutionary_log$n_off[1:4,iteration-2])) & (id_selected > sum(evolutionary_log$n_off[1:3,iteration-2])) ) / evolutionary_log$n_off[4,iteration-2]
}
if(iteration>2){
prop_noff1 = prop_noff2 = prop_noff3 = prop_noff4 = 0
if(evolutionary_log$n_off[1,iteration-2] > 0){
prop_noff1 = sum(id_selected <= evolutionary_log$n_off[1,iteration-2]) / evolutionary_log$n_off[1,iteration-2]
}
if(evolutionary_log$n_off[2,iteration-2] > 0){
prop_noff2 = sum((id_selected <= sum(evolutionary_log$n_off[1:2,iteration-2])) & (id_selected > sum(evolutionary_log$n_off[1,iteration-2])) ) / evolutionary_log$n_off[2,iteration-2]
}
if(evolutionary_log$n_off[3,iteration-2] > 0){
prop_noff3 = sum((id_selected <= sum(evolutionary_log$n_off[1:3,iteration-2])) & (id_selected > sum(evolutionary_log$n_off[1:2,iteration-2])) ) / evolutionary_log$n_off[3,iteration-2]
}
if(evolutionary_log$n_off[4,iteration-2] > 0){
prop_noff4 = sum((id_selected <= sum(evolutionary_log$n_off[1:4,iteration-2])) & (id_selected > sum(evolutionary_log$n_off[1:3,iteration-2])) ) / evolutionary_log$n_off[4,iteration-2]
}
evolutionary_log$proportion_sel = cbind(evolutionary_log$proportion_sel, c(prop_noff1, prop_noff2, prop_noff3, prop_noff4))
}
evolutionary_log$proportion_sel
