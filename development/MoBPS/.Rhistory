lines(acc_test[,index], lwd=2, col=index)
}
test1 = predict(model1, infra[training,dim2])
pred1 = predict(model1, infra[-training,dim2])
par(mfrow=c(1, 1))
for(index in 1:length(dim1)){
if(index == 1){
plot(acc_training[,index], xlim=c(1,300), ylim=c(-0.1,1),lwd=1, lty=2 ,col=index, type="l", xlab="included PCs", ylab="prediction accuracy")
} else{
lines(acc_training[,index], lwd=1, lty=2 , col=index)
}
lines(acc_test[,index], lwd=2, col=index)
}
acc_training = acc_test =  matrix(0, ncol=length(dim1), nrow=length(dim2))
for(index in 1:length(dim2)){
print(index)
if(length(dim1)>1){
acc_training[index, ] = diag(cor(test1[,,index], data[training, dim1]))
acc_test[index, ] = diag(cor(pred1[,,index], data[-training, dim1]))
} else{
acc_training[index, ] = (cor(test1[,,index], data[training, dim1]))
acc_test[index, ] = (cor(pred1[,,index], data[-training, dim1]))
}
}
par(mfrow=c(1, 1))
for(index in 1:length(dim1)){
if(index == 1){
plot(acc_training[,index], xlim=c(1,300), ylim=c(-0.1,1),lwd=1, lty=2 ,col=index, type="l", xlab="included PCs", ylab="prediction accuracy")
} else{
lines(acc_training[,index], lwd=1, lty=2 , col=index)
}
lines(acc_test[,index], lwd=2, col=index)
}
library(MoBPS)
#library(data.table)
#setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/")
# Perform a breeding value estimation using MIXBLUP
set.seed(1)
population <- creating.diploid(nsnp=500, chr.nr=5, nindi=10, n.additive = c(100,100), miraculix=TRUE, shuffle.cor = cbind(c(1,0), c(0,1)))
get.geno(population, database=cbind(1,1,1))
gen=NULL
cohorts=NULL
chromosome="all"
export.alleles=FALSE
remove.missing = TRUE
array = NUL
use.id=FALSE
array = NULL
non.genotyped.as.missing=FALSE
database = cbind(1,1,1)
if(length(chromosome)==1 && chromosome=="all"){
subsetting <- FALSE
chromosome <- 1:length(population$info$snp)
} else{
subsetting <- TRUE
}
if(length(array)>0){
temp1 <- which(population$info$array.name == array)
if(length(temp1)==1){
array <- temp1
}
if(!is.numeric(array)){
stop("Input for array can not be assigned! Check your input!")
}
}
if(population$info$miraculix){
if (requireNamespace("miraculix", quietly = TRUE)) {
codeOriginsU <- miraculix::codeOrigins
decodeOriginsU <- miraculix::decodeOrigins
} else{
codeOriginsU <- codeOriginsR
decodeOriginsU <- decodeOriginsR
}
} else{
codeOriginsU <- codeOriginsR
decodeOriginsU <- decodeOriginsR
}
if(length(population$info$origin.gen)>0){
population$info$origin.gen <- as.integer(population$info$origin.gen)
} else{
if(population$info$miraculix){
population$info$origin.gen <- 1:64L
} else{
population$info$origin.gen <- 1:32L
}
}
database <- get.database(population, gen, database, cohorts)
start.chromo <- cumsum(c(1,population$info$snp)[-(length(population$info$snp)+1)])
end.chromo <- population$info$cumsnp
relevant.snps <- NULL
for(index in chromosome){
relevant.snps <- c(relevant.snps, start.chromo[index]:end.chromo[index])
}
nsnp <- length(relevant.snps)
titel <- t(population$info$snp.base[,relevant.snps])
n.animals <- sum(database[,4] - database[,3] +1)
data <- matrix(0L, ncol=n.animals, nrow=nsnp)
before <- 0
names <- numeric(n.animals)
colnames(titel) <- c("Major_Allel", "Minor_Allel")
for(row in 1:nrow(database)){
animals <- database[row,]
nanimals <- database[row,4] - database[row,3] +1
if(nanimals>0){
if(population$info$miraculix){
if(subsetting){
data[, (before+1):(before+nanimals)] <- miraculix::computeSNPS(population,rep(animals[1], nanimals), rep(animals[2], nanimals) ,animals[3]:animals[4], what="geno")[relevant.snps,]
} else{
data[, (before+1):(before+nanimals)] <- miraculix::computeSNPS(population,rep(animals[1], nanimals), rep(animals[2], nanimals) ,animals[3]:animals[4], what="geno")
}
}
names[(before+1):(before+nanimals)] <- paste(if(animals[2]==1) "M" else "F", animals[3]:animals[4], "_", animals[1], sep="")
if(!population$info$miraculix){
rindex <- 1
for(index in animals[3]:animals[4]){
data[, before + rindex] <- colSums(compute.snps(population,animals[1], animals[2],index, decodeOriginsU=decodeOriginsU))[relevant.snps]
rindex <- rindex + 1
}
}
}
before <- before + nanimals
}
rownames(data) <- population$info$snp.name[relevant.snps]
if(non.genotyped.as.missing){
is_genotyped <- get.genotyped.snp(population, database = database)[relevant.snps,]
} else{
is_genotyped <- matrix(TRUE, nrow=nrow(data), ncol=ncol(data))
}
if(length(array)>0){
is_genotyped[!population$info$array.markers[[array]], ] <- FALSE
}
is_genotyped
sum(!is_genotyped)>0
if(sum(!is_genotyped)>0){
data[!is_genotyped] <- NA
}
remove.missing
remove.missing
if(remove.missing){
data <- data[rowMeans(is.na(data))<1,,drop=FALSE]
}
if(use.id){
colnames(data) <- get.id(population, database = database)
} else{
colnames(data) <- names
}
if(export.alleles){
return(list(titel,data))
} else{
return(data)
}
data
dim(data)
setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/development/MoBPS/")
devtools::build()
devtools::load_all()
get.geno(population, database=cbind(1,1,1))
setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/GitHub/MoBPS/development/MoBPS/")
devtools::load_all()
devtools::check()
?as
Matrix::as()
A = diag(5)
as(A, "sparseMatrix")
Matrix::as(A, "sparseMatrix")
methods::as(A, "sparseMatrix")
devtools::check()
setwd("C:/Users/pook001/OneDrive - Wageningen University & Research/")
data = list()
for(index in 2:6){
data[[index]] = (as.matrix(read.table(paste0("taxaSummary_L", index,".txt"))))
}
pheno = read.delim("C:/Users/pook001/Downloads/targets+sorted.txt", header=FALSE)
pheno[1,]
plot(pheno[,9])
data
order = scan("taxaSummary_L2.txt", what = "character", nlines = 1, skip = 1)[-(1:2)]
pheno[,1]
reorder = numeric(length(order))
for(index in 1:length(order)){
reorder[index] == which(pheno[,1]==order[index])
}
function (x, ...)
reorder
reorder = numeric(length(order))
for(index in 1:length(order)){
reorder[index] == which(pheno[,1]==order[index])
}
reorder
index
order[index]
reorder = numeric(length(order))
for(index in 1:length(order)){
reorder[index] = which(pheno[,1]==order[index])
}
pheno[,1]
index
order[index]
reorder = numeric(length(order))
for(index in 1:length(order)){
t = which(pheno[,1]==order[index])
if(length(t)==1){
reorder[index] = t
} else{
print(index)
print(t)
}
}
pheno = pheno[reorder,]
dim(pheno)
pheno
y = pheno[,2]
y
pheno[1,]
pheno = read.delim("C:/Users/pook001/Downloads/targets+sorted.txt", header=FALSE)
traits = pheno[1,]
plot(pheno[,9])
data
order = scan("taxaSummary_L2.txt", what = "character", nlines = 1, skip = 1)[-(1:2)]
reorder = numeric(length(order))
for(index in 1:length(order)){
t = which(pheno[,1]==order[index])
if(length(t)==1){
reorder[index] = t
} else{
print(index)
print(t)
}
}
pheno = pheno[reorder,]
y = pheno[,2]
traits
y = pheno[,12]
X = X[which(reorder!=0),]
X = t(data[[second]][,-1])
second
second = 6
X = t(data[[second]][,-1])
X = X[which(reorder!=0),]
storage.mode(y) = storage.mode(X) = "numeric"
X=scale(X)
G=tcrossprod(X)
G=G/mean(diag(G))
EVD=eigen(G)
rsq[index] = fitREML(y=y,EVD=EVD)$estimates['h2']
# Objective function
neg2_REML<-function(y,Xt,vars,d,n,nSuccess=1,nFailure=1){
###
# y=U'eHat where is eHat=OLS residuals
# Xt=X'U
# vars=c(varE,varU)
# d: eigenvalues
# n: length(y)
# objective function is -2*L2 (page 1 in http://www.aps.uoguelph.ca/~lrs/Animalz/lesson11/lesson11.pdf)
# gustavoc@msu.edu
###
varE=(vars[1])
varU=(vars[2])
w<-d*varU+varE
neg2_reml_1=sum(log(w))
Xt<-scale(Xt,center=F,scale=1/sqrt(w))
C=tcrossprod(Xt)
neg2_reml_2<-log(det(C))
neg2_reml_3<-sum((y^2)/w)
h2=varU/(varU+varE)
neg2LogPrior=-2* ( (nSuccess-1)*log(h2)+(nFailure-1)*log(1-h2))
out<-neg2_reml_1+neg2_reml_2+neg2_reml_3#+neg2LogPrior
return(out)
}
# Model fittting
fitREML<-function(y,EVD=NULL,K=NULL,n=length(y),X=matrix(nrow=n,ncol=1,1),
nSuccess=1,nFailure=1,computeHessian=F){
###
# y: phenotype
# EVD=eigen(G)
# X: incidence matrix for fixed effects
# gustavoc@msu.edu 11/30/2016
###
if(is.null(EVD)){
if(is.null(K)){
stop('provide either K or its eigenvalue decomposition')
}else{
EVD=eigen(K)
}
}
library(minqa)
library(numDeriv)
varY<-var(y)
tmp<-rep(TRUE,length(EVD$values))#EVD$values>1e-5
d=EVD$values[tmp]
U=EVD$vectors[,tmp]
eHat<-residuals(lsfit(y=y,x=X,intercept=F))
y<-crossprod(U,eHat)
Xt<-crossprod(X,U)
fm<-bobyqa(par=varY*rep(.5,2),fn=neg2_REML,lower=rep(1e-5,2)*varY,upper=rep(1.5,1.5)*varY,y=y,Xt=Xt,d=d,n=n,
nSuccess=nSuccess,nFailure=nFailure)
estimates=c(fm$par,fm$par[2]/sum(fm$par))
names(estimates)<-c('varE','varU','h2')
out=list(estimates=estimates,logREML=-2*fm$fval)
if(computeHessian){
COV1=solve(hessian(fun=neg2_REML,x=fm$par,y=y,Xt=Xt,d=d,n=n,
nSuccess=nSuccess,nFailure=nFailure))
X=matrix(nrow=100000,ncol=2,rnorm(200000))%*%chol(COV1)
X[,1]=X[,1]+estimates[1]
X[,2]=X[,2]+estimates[2]
COV=matrix(nrow=3,ncol=3,NA)
COV[1:2,1:2]=COV1
h2=X[,2]/rowSums(X)
COV[3,3]=var(h2)
COV[3,1]=COV[1,3]=cov(X[,1],h2)
COV[3,2]=COV[2,3]=cov(X[,2],h2)
out$SEs=sqrt(diag(COV))
out$vcov=COV
}
return(out)
}
fitREML(y=y,EVD=EVD)
hs = matrix(0, nrow=6, ncol=50)
colMeans(is.numeric(pheno))
colMeans(is.numeric(pheno))
pheno
pheno[1,]
is.numeric(pheno[1,])
as.numeric(pheno[1,])
which(is.na(as.numeric(pheno[1,])))
which(!is.na(as.numeric(pheno[1,])))
hs = matrix(0, nrow=6, ncol=29)
for(second in 2:6){
for(trait in which(!is.na(as.numeric(pheno[1,])))){
y = pheno[,trait]
X = t(data[[second]][,-1])
X = X[which(reorder!=0),]
storage.mode(y) = storage.mode(X) = "numeric"
X=scale(X)
G=tcrossprod(X)
G=G/mean(diag(G))
EVD=eigen(G)
hs[second, trait] = fitREML(y=y,EVD=EVD)$estimates['h2']
}
}
second
trait
y = pheno[,trait]
X = t(data[[second]][,-1])
X = X[which(reorder!=0),]
storage.mode(y) = storage.mode(X) = "numeric"
y
X
X=scale(X)
G=tcrossprod(X)
G=G/mean(diag(G))
EVD=eigen(G)
hs[second, trait] = fitREML(y=y,EVD=EVD)$estimates['h2']
y = pheno[,trait]
y
hs = matrix(0, nrow=6, ncol=29)
for(second in 2:6){
for(trait in which(!is.na(as.numeric(pheno[1,])))){
y = pheno[,trait]
X = t(data[[second]][,-1])
X = X[which(reorder!=0),]
storage.mode(y) = storage.mode(X) = "numeric"
if(sum(is.na(y))>0){
next
}
X=scale(X)
G=tcrossprod(X)
G=G/mean(diag(G))
EVD=eigen(G)
hs[second, trait] = fitREML(y=y,EVD=EVD)$estimates['h2']
}
}
y
hs
test <- rrBLUP::mixed.solve(y, K = G, method="REML", bounds = c(1e-9,1e9))
test
y
y_trait[sample(1:nrow(y), 0.2 * nrow(y))] = NA
y_trait = y
y_trait[sample(1:nrow(y), 0.2 * nrow(y))] = NA
sample(1:nrow(y), 0.2 * nrow(y))
1:nrow(y)
y_trait[sample(1:length(y), 0.2 * length(y))] = NA
y_trait
test <- rrBLUP::mixed.solve(y_trait, K = G, method="REML", bounds = c(1e-9,1e9))
test
cor(as.numeric(test$beta[1])[is.na(y_trait)] , y[is.na(y_trait)] )
as.numeric(test$beta[1])[is.na(y_trait)]
as.numeric(test$beta[1])
test$u
cor(as.numeric(test$u)[is.na(y_trait)] , y[is.na(y_trait)] )
hs = cors = matrix(0, nrow=6, ncol=29)
for(second in 2:6){
for(trait in which(!is.na(as.numeric(pheno[1,])))){
y = pheno[,trait]
X = t(data[[second]][,-1])
X = X[which(reorder!=0),]
storage.mode(y) = storage.mode(X) = "numeric"
if(sum(is.na(y))>0){
next
}
X=scale(X)
G=tcrossprod(X)
G=G/mean(diag(G))
EVD=eigen(G)
hs[second, trait] = fitREML(y=y,EVD=EVD)$estimates['h2']
for(int in 1:10){
y_trait = y
y_trait[sample(1:length(y), 0.2 * length(y))] = NA
test <- rrBLUP::mixed.solve(y_trait, K = G, method="REML", bounds = c(1e-9,1e9))
cors[second, trait] = cors + cor(as.numeric(test$u)[is.na(y_trait)] , y[is.na(y_trait)] )
}
}
}
cors[second, trait] = cors[second, trait] + cor(as.numeric(test$u)[is.na(y_trait)] , y[is.na(y_trait)] )
hs = cors = matrix(0, nrow=6, ncol=29)
for(second in 2:6){
for(trait in which(!is.na(as.numeric(pheno[1,])))){
y = pheno[,trait]
X = t(data[[second]][,-1])
X = X[which(reorder!=0),]
storage.mode(y) = storage.mode(X) = "numeric"
if(sum(is.na(y))>0){
next
}
X=scale(X)
G=tcrossprod(X)
G=G/mean(diag(G))
EVD=eigen(G)
hs[second, trait] = fitREML(y=y,EVD=EVD)$estimates['h2']
for(int in 1:10){
y_trait = y
y_trait[sample(1:length(y), 0.2 * length(y))] = NA
test <- rrBLUP::mixed.solve(y_trait, K = G, method="REML", bounds = c(1e-9,1e9))
cors[second, trait] = cors[second, trait] + cor(as.numeric(test$u)[is.na(y_trait)] , y[is.na(y_trait)] )
}
}
}
hs
cors
plot(cors)
plot(cors[1,])
plot(cors[6,])
lines(hs[6,])
plot(cors[6,]/10)
lines(hs[6,])
pheno
which(!is.na(as.numeric(pheno[1,])))
which(is.na(as.numeric(pheno[1,])))
pheno[,c(4,7,22,23,28,30,31)]
table(pheno[,c(4,7,22,23,28,30,31)])
table(pheno[,c(4)])
table(pheno[,c(7)])
table(pheno[,c(22)])
table(pheno[,c(23)])
table(pheno[,c(24)])
table(pheno[,c(25)])
table(pheno[,c(30)])
table(pheno[,c(31)])
tab =  matrix(0, nrow = 6, ncol = 6)
for(first in 2:6){
for(second in 2:6){
print(c(first,second))
rsq = numeric(nrow(data[[first]]))
for(index in 1:nrow(data[[first]])){
X = t(data[[second]][,-1])
storage.mode(y) = storage.mode(X) = "numeric"
X=scale(X)
G=tcrossprod(X)
G=G/mean(diag(G))
EVD=eigen(G)
rsq[index] = fitREML(y=y,EVD=EVD)$estimates['h2']
}
tab[first,second] = mean(rsq)
print(tab[first,second])
}}
library(BGLR)
tab = matrix(0, nrow = 6, ncol = 6)
for(first in 2:6){
for(second in 2:6){
print(c(first,second))
rsq = numeric(nrow(data[[first]]))
for(index in 1:nrow(data[[first]])){
y = as.numeric(data[[first]][index,-1])
X = t(data[[second]][,-1])
storage.mode(y) = storage.mode(X) = "numeric"
X=scale(X)
G=tcrossprod(X)
G=G/mean(diag(G))
EVD=eigen(G)
rsq[index] = fitREML(y=y,EVD=EVD)$estimates['h2']
}
tab[first,second] = mean(rsq)
print(tab[first,second])
}}
tab
colnames(tab) = rownames(tab) =  paste0("L", 1:6)
tab
tab[-1,-1]
cors
cors/10
colnames(cors) = traits[1:29]
cors
cors[,which(!is.na(as.numeric(pheno[1,])))]/10
which(!is.na(as.numeric(pheno[1,])))
cors[,which(!is.na(as.numeric(pheno[1,])))]
cors
pheno
trait
traits
cors
cors[,which(!is.na(as.numeric(pheno[1,])))]/10
